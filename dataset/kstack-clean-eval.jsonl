{"task_id": "10", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "processLine", "fn_name": "processLine", "fn_signature": "fun processLine(status: State, line: String): State {", "context": "// Frequency counting\ndata class Frequency<T>(val element: T, val occurrence: Int)\n\nfun <T> Collection<T>.mostFrequent(): Frequency<T> {\n    val (value: T, count: Int) = groupingBy { it }.eachCount().maxBy { it.value }!!\n    return Frequency(value, count)\n}\n\ntypealias GuardID = Int\ntypealias Minute = Int\n\nclass Day04(input: List<String>) {\n    data class Nap(val guard: GuardID, val minutes: IntRange)\n\n    data class State(val guard: GuardID? = null, val napStarted: Int? = null, val naps: List<Nap> = listOf()) {\n        fun beginShift(newGuard: GuardID) = copy(guard = newGuard, napStarted = null)\n        fun fallAsleep(minutes: Int) = copy(napStarted = minutes)\n        fun wakeUp(minutes: Int) = copy(napStarted = null, naps = naps + Nap(guard!!, napStarted!! until minutes))\n    }\n\n    companion object {\n        private val beginShiftRE = Regex(\"\"\".*Guard #(\\d+) begins shift\"\"\")\n        private val fallAsleepRE = Regex(\"\"\".*00:(\\d{2})] falls asleep\"\"\")\n        private val wakesUpRE = Regex(\"\"\".*00:(\\d{2})] wakes up\"\"\")\n        private fun MatchResult.intMatch(): Int = destructured.let{ (firstResult) -> firstResult.toInt() }\n\n        fun processLine(status: State, line: String): State = when {\n            /* GENERATE THIS FUNCTION */\n        }\n    }\n\n    private val guardNaps: Map<GuardID, List<Minute>> = input\n            .sorted()\n            .fold(State(), ::processLine).naps\n            .groupBy { it.guard }\n            .mapValues { it.value.flatMap { it.minutes } }\n\n    fun part1(): Int = guardNaps\n            .maxBy { it.value.size }!!\n            .let { (guardID: GuardID, minutes: List<Minute>) -> guardID * minutes.mostFrequent().element }\n\n    fun part2(): Int = guardNaps\n            .mapValues { it.value.mostFrequent() }\n            .maxBy { it.value.occurrence }!!\n            .let { (guardID: GuardID, mostFrequent: Frequency<Minute>) -> guardID * mostFrequent.element }\n}", "test": "fun main() {\n    val day04_sample = \"\"\"\n        [1518-11-01 00:00] Guard #10 begins shift\n        [1518-11-01 00:05] falls asleep\n        [1518-11-01 00:25] wakes up\n        [1518-11-01 00:30] falls asleep\n        [1518-11-01 00:55] wakes up\n        [1518-11-01 23:58] Guard #99 begins shift\n        [1518-11-02 00:40] falls asleep\n        [1518-11-02 00:50] wakes up\n        [1518-11-03 00:05] Guard #10 begins shift\n        [1518-11-03 00:24] falls asleep\n        [1518-11-03 00:29] wakes up\n        [1518-11-04 00:02] Guard #99 begins shift\n        [1518-11-04 00:36] falls asleep\n        [1518-11-04 00:46] wakes up\n        [1518-11-05 00:03] Guard #99 begins shift\n        [1518-11-05 00:45] falls asleep\n        [1518-11-05 00:55] wakes up\n    \"\"\".trimIndent()\n\n    val day04 = \"\"\"\n        [1518-08-08 00:45] falls asleep\n        [1518-05-02 00:52] falls asleep\n        [1518-05-07 00:56] wakes up\n        [1518-08-18 00:06] falls asleep\n        [1518-11-11 00:04] Guard #2179 begins shift\n        [1518-09-15 00:38] wakes up\n        [1518-10-19 00:22] wakes up\n        [1518-08-14 00:45] falls asleep\n        [1518-10-16 00:47] falls asleep\n        [1518-10-27 00:02] Guard #3181 begins shift\n        [1518-03-23 00:23] falls asleep\n        [1518-04-01 00:53] wakes up\n        [1518-05-08 00:57] wakes up\n        [1518-07-08 00:29] falls asleep\n        [1518-05-21 23:58] Guard #2879 begins shift\n        [1518-10-13 00:53] wakes up\n        [1518-09-04 00:56] falls asleep\n        [1518-08-30 00:01] falls asleep\n        [1518-03-24 00:48] wakes up\n        [1518-11-09 00:00] Guard #89 begins shift\n        [1518-09-13 23:52] Guard #3251 begins shift\n        [1518-10-13 00:25] falls asleep\n        [1518-04-26 00:33] falls asleep\n        [1518-08-23 00:04] Guard #1021 begins shift\n        [1518-10-25 00:50] wakes up\n        [1518-08-28 00:38] falls asleep\n        [1518-03-31 00:58] wakes up\n        [1518-04-16 00:56] wakes up\n        [1518-09-27 23:59] Guard #2179 begins shift\n        [1518-10-22 00:58] wakes up\n        [1518-11-07 00:29] wakes up\n        [1518-02-12 00:03] Guard #983 begins shift\n        [1518-10-31 00:39] wakes up\n        [1518-09-28 00:24] falls asleep\n        [1518-06-05 23:56] Guard #2843 begins shift\n        [1518-04-21 00:51] falls asleep\n        [1518-03-22 00:56] wakes up\n        [1518-04-30 00:03] Guard #3433 begins shift\n        [1518-08-20 00:53] wakes up\n        [1518-06-24 00:04] Guard #2179 begins shift\n        [1518-10-25 00:24] falls asleep\n        [1518-06-05 00:51] falls asleep\n        [1518-06-08 00:37] wakes up\n        [1518-04-11 00:07] falls asleep\n        [1518-09-19 00:03] falls asleep\n        [1518-06-23 00:45] wakes up\n        [1518-02-26 00:00] Guard #631 begins shift\n        [1518-05-05 00:30] falls asleep\n        [1518-08-26 00:58] wakes up\n        [1518-02-23 00:35] falls asleep\n        [1518-07-10 00:04] Guard #89 begins shift\n        [1518-07-08 00:38] falls asleep\n        [1518-04-26 00:47] wakes up\n        [1518-08-10 00:00] Guard #2843 begins shift\n        [1518-11-18 00:52] wakes up\n        [1518-09-01 00:54] falls asleep\n        [1518-09-24 00:52] wakes up\n        [1518-09-04 00:59] wakes up\n        [1518-10-03 00:29] falls asleep\n        [1518-08-18 00:03] Guard #631 begins shift\n        [1518-07-29 23:58] Guard #2801 begins shift\n        [1518-06-08 00:13] falls asleep\n        [1518-09-14 23:56] Guard #3251 begins shift\n        [1518-04-08 00:54] wakes up\n        [1518-08-21 23:47] Guard #631 begins shift\n        [1518-07-24 00:36] wakes up\n        [1518-03-27 00:51] falls asleep\n        [1518-04-03 00:55] wakes up\n        [1518-06-17 00:54] falls asleep\n        [1518-07-11 00:49] wakes up\n        [1518-04-04 00:30] falls asleep\n        [1518-09-28 23:59] Guard #2801 begins shift\n        [1518-05-02 00:31] wakes up\n        [1518-04-21 00:01] Guard #3433 begins shift\n        [1518-06-07 00:38] wakes up\n        [1518-06-09 23:59] Guard #1579 begins shift\n        [1518-10-29 00:51] wakes up\n        [1518-02-16 00:54] falls asleep\n        [1518-08-11 00:52] falls asleep\n        [1518-03-21 00:58] wakes up\n        [1518-09-20 00:58] wakes up\n        [1518-04-15 00:30] falls asleep\n        [1518-08-28 23:59] Guard #2879 begins shift\n        [1518-07-27 00:44] wakes up\n        [1518-10-20 00:55] wakes up\n        [1518-06-02 00:42] wakes up\n        [1518-08-26 00:43] wakes up\n        [1518-07-12 00:39] wakes up\n        [1518-09-25 00:00] Guard #2801 begins shift\n        [1518-03-14 00:41] falls asleep\n        [1518-06-23 00:59] wakes up\n        [1518-05-15 00:59] wakes up\n        [1518-02-23 00:41] wakes up\n        [1518-07-19 00:59] wakes up\n        [1518-04-23 00:32] falls asleep\n        [1518-02-22 00:57] wakes up\n        [1518-04-17 00:07] falls asleep\n        [1518-07-28 00:16] falls asleep\n        [1518-02-22 23:49] Guard #2971 begins shift\n        [1518-05-24 23:59] Guard #1579 begins shift\n        [1518-08-19 00:43] wakes up\n        [1518-07-05 00:16] falls asleep\n        [1518-06-01 23:56] Guard #2801 begins shift\n        [1518-06-10 00:53] wakes up\n        [1518-05-05 00:48] wakes up\n        [1518-11-01 23:58] Guard #89 begins shift\n        [1518-08-11 00:03] Guard #587 begins shift\n        [1518-09-27 00:49] wakes up\n        [1518-11-05 00:12] wakes up\n        [1518-06-27 23:58] Guard #1021 begins shift\n        [1518-07-01 00:53] falls asleep\n        [1518-02-25 00:02] Guard #89 begins shift\n        [1518-08-11 00:48] wakes up\n        [1518-06-22 23:57] Guard #3331 begins shift\n        [1518-03-18 00:52] wakes up\n        [1518-06-09 00:43] falls asleep\n        [1518-03-13 00:56] wakes up\n        [1518-03-30 00:49] wakes up\n        [1518-02-24 00:01] Guard #587 begins shift\n        [1518-10-27 00:10] falls asleep\n        [1518-10-02 00:28] falls asleep\n        [1518-02-15 00:03] Guard #1579 begins shift\n        [1518-11-17 00:41] wakes up\n        [1518-07-09 00:00] Guard #3181 begins shift\n        [1518-03-28 00:24] falls asleep\n        [1518-03-23 00:03] Guard #2971 begins shift\n        [1518-06-10 00:07] falls asleep\n        [1518-06-10 00:34] wakes up\n        [1518-06-28 00:51] wakes up\n        [1518-09-19 23:59] Guard #2179 begins shift\n        [1518-05-30 00:02] Guard #3331 begins shift\n        [1518-06-10 00:39] falls asleep\n        [1518-03-01 23:53] Guard #1069 begins shift\n        [1518-04-03 00:00] falls asleep\n        [1518-05-28 00:01] Guard #631 begins shift\n        [1518-03-24 00:54] falls asleep\n        [1518-08-03 23:59] Guard #2843 begins shift\n        [1518-10-17 23:59] Guard #2179 begins shift\n        [1518-03-06 00:16] wakes up\n        [1518-03-26 00:53] wakes up\n        [1518-04-15 23:58] Guard #1021 begins shift\n        [1518-04-28 00:03] Guard #2879 begins shift\n        [1518-09-04 00:42] falls asleep\n        [1518-03-25 00:01] Guard #983 begins shift\n        [1518-04-09 00:59] wakes up\n        [1518-03-19 00:31] falls asleep\n        [1518-09-25 00:26] falls asleep\n        [1518-02-23 00:28] wakes up\n        [1518-07-18 00:41] wakes up\n        [1518-11-15 00:38] falls asleep\n        [1518-07-16 00:42] wakes up\n        [1518-06-23 00:54] falls asleep\n        [1518-03-04 00:22] falls asleep\n        [1518-07-02 00:42] falls asleep\n        [1518-08-24 23:58] Guard #631 begins shift\n        [1518-06-03 00:02] falls asleep\n        [1518-08-29 00:56] wakes up\n        [1518-04-19 00:19] wakes up\n        [1518-08-24 00:09] falls asleep\n        [1518-08-24 00:35] wakes up\n        [1518-11-22 00:53] wakes up\n        [1518-07-26 00:26] falls asleep\n        [1518-10-08 00:48] falls asleep\n        [1518-04-11 00:00] Guard #2179 begins shift\n        [1518-09-30 00:50] wakes up\n        [1518-05-09 00:26] wakes up\n        [1518-08-18 00:24] falls asleep\n        [1518-06-01 00:54] wakes up\n        [1518-02-24 00:12] falls asleep\n        [1518-03-15 00:14] falls asleep\n        [1518-04-04 00:58] wakes up\n        [1518-10-01 00:50] wakes up\n        [1518-06-18 00:14] falls asleep\n        [1518-06-03 00:47] wakes up\n        [1518-07-31 00:51] wakes up\n        [1518-05-29 00:53] falls asleep\n        [1518-02-14 00:54] wakes up\n        [1518-06-16 00:59] wakes up\n        [1518-04-19 00:29] falls asleep\n        [1518-04-24 00:04] Guard #631 begins shift\n        [1518-10-05 00:50] wakes up\n        [1518-06-26 00:54] wakes up\n        [1518-11-13 00:37] wakes up\n        [1518-08-25 23:58] Guard #3181 begins shift\n        [1518-07-29 00:24] falls asleep\n        [1518-02-28 00:35] falls asleep\n        [1518-07-08 00:04] Guard #3181 begins shift\n        [1518-11-13 00:13] falls asleep\n        [1518-11-21 23:48] Guard #3181 begins shift\n        [1518-10-11 00:14] falls asleep\n        [1518-10-19 00:03] Guard #983 begins shift\n        [1518-09-06 00:46] falls asleep\n        [1518-08-27 00:54] wakes up\n        [1518-04-19 00:36] wakes up\n        [1518-10-06 00:01] Guard #3433 begins shift\n        [1518-09-14 00:05] falls asleep\n        [1518-10-10 00:12] falls asleep\n        [1518-03-19 23:54] Guard #3331 begins shift\n        [1518-06-20 00:12] wakes up\n        [1518-04-05 23:56] Guard #3251 begins shift\n        [1518-10-04 23:57] Guard #3433 begins shift\n        [1518-08-07 23:50] Guard #2671 begins shift\n        [1518-08-21 00:36] falls asleep\n        [1518-09-04 23:53] Guard #631 begins shift\n        [1518-05-19 00:20] wakes up\n        [1518-03-25 00:52] wakes up\n        [1518-03-06 00:25] wakes up\n        [1518-07-16 00:48] falls asleep\n        [1518-08-16 00:50] wakes up\n        [1518-07-10 00:23] falls asleep\n        [1518-04-26 00:06] falls asleep\n        [1518-11-06 00:57] wakes up\n        [1518-03-08 00:51] wakes up\n        [1518-08-19 00:52] wakes up\n        [1518-07-21 00:59] wakes up\n        [1518-02-16 00:03] Guard #2179 begins shift\n        [1518-11-14 00:16] falls asleep\n        [1518-06-18 23:49] Guard #2671 begins shift\n        [1518-09-21 00:53] falls asleep\n        [1518-11-05 23:58] Guard #89 begins shift\n        [1518-03-26 00:43] falls asleep\n        [1518-09-14 00:37] wakes up\n        [1518-06-12 23:58] Guard #2179 begins shift\n        [1518-06-05 00:53] wakes up\n        [1518-08-06 00:57] wakes up\n        [1518-06-30 00:02] Guard #631 begins shift\n        [1518-10-04 00:54] wakes up\n        [1518-05-18 23:53] Guard #631 begins shift\n        [1518-10-02 00:56] wakes up\n        [1518-08-01 00:06] falls asleep\n        [1518-08-13 23:58] Guard #2179 begins shift\n        [1518-10-03 00:39] wakes up\n        [1518-09-13 00:21] falls asleep\n        [1518-05-14 00:09] falls asleep\n        [1518-05-23 00:42] falls asleep\n        [1518-07-17 23:58] Guard #2843 begins shift\n        [1518-09-06 00:17] wakes up\n        [1518-08-19 00:39] falls asleep\n        [1518-10-18 00:32] wakes up\n        [1518-05-12 00:31] wakes up\n        [1518-05-26 00:00] Guard #2957 begins shift\n        [1518-09-02 00:55] wakes up\n        [1518-09-20 00:41] falls asleep\n        [1518-09-27 00:40] falls asleep\n        [1518-10-10 00:53] falls asleep\n        [1518-03-21 23:53] Guard #163 begins shift\n        [1518-06-19 00:42] wakes up\n        [1518-11-10 00:52] wakes up\n        [1518-07-07 00:29] wakes up\n        [1518-10-20 00:33] wakes up\n        [1518-10-30 23:56] Guard #2801 begins shift\n        [1518-06-09 00:36] wakes up\n        [1518-02-21 00:23] wakes up\n        [1518-05-14 00:36] wakes up\n        [1518-05-03 23:54] Guard #3251 begins shift\n        [1518-05-12 00:04] Guard #89 begins shift\n        [1518-05-10 23:56] Guard #587 begins shift\n        [1518-06-17 00:22] wakes up\n        [1518-03-16 00:58] wakes up\n        [1518-05-30 00:56] wakes up\n        [1518-09-11 00:43] wakes up\n        [1518-07-13 00:39] falls asleep\n        [1518-07-22 00:00] Guard #587 begins shift\n        [1518-03-11 00:02] falls asleep\n        [1518-10-08 00:40] wakes up\n        [1518-06-20 00:39] wakes up\n        [1518-04-16 00:49] falls asleep\n        [1518-06-24 00:56] wakes up\n        [1518-03-28 00:36] wakes up\n        [1518-05-15 00:43] falls asleep\n        [1518-02-21 00:33] falls asleep\n        [1518-03-10 00:12] wakes up\n        [1518-09-20 00:38] wakes up\n        [1518-07-20 00:27] wakes up\n        [1518-08-22 00:02] falls asleep\n        [1518-06-26 00:48] falls asleep\n        [1518-04-12 00:49] wakes up\n        [1518-09-06 23:54] Guard #983 begins shift\n        [1518-07-20 00:35] falls asleep\n        [1518-05-02 00:56] wakes up\n        [1518-05-12 00:44] falls asleep\n        [1518-09-02 23:51] Guard #1021 begins shift\n        [1518-11-03 00:32] falls asleep\n        [1518-07-09 00:39] wakes up\n        [1518-02-18 00:02] Guard #2837 begins shift\n        [1518-03-17 23:56] Guard #2837 begins shift\n        [1518-04-26 00:02] Guard #2671 begins shift\n        [1518-10-14 00:53] wakes up\n        [1518-07-04 00:01] falls asleep\n        [1518-03-05 00:24] falls asleep\n        [1518-09-24 00:02] Guard #3181 begins shift\n        [1518-04-19 00:06] falls asleep\n        [1518-02-10 23:47] Guard #631 begins shift\n        [1518-11-05 00:22] falls asleep\n        [1518-08-19 00:32] wakes up\n        [1518-03-27 00:53] wakes up\n        [1518-04-27 00:04] falls asleep\n        [1518-04-29 00:40] falls asleep\n        [1518-07-01 00:37] falls asleep\n        [1518-07-06 00:55] wakes up\n        [1518-08-23 00:52] wakes up\n        [1518-07-30 00:30] falls asleep\n        [1518-03-19 00:57] wakes up\n        [1518-05-09 00:12] falls asleep\n        [1518-03-22 00:18] wakes up\n        [1518-11-21 00:58] wakes up\n        [1518-07-02 00:49] wakes up\n        [1518-04-19 00:01] Guard #2801 begins shift\n        [1518-10-17 00:45] falls asleep\n        [1518-07-28 23:59] Guard #311 begins shift\n        [1518-08-10 00:36] falls asleep\n        [1518-03-29 23:56] Guard #1069 begins shift\n        [1518-04-11 00:13] wakes up\n        [1518-05-02 23:54] Guard #311 begins shift\n        [1518-09-01 00:42] wakes up\n        [1518-10-08 00:16] wakes up\n        [1518-03-29 00:06] falls asleep\n        [1518-11-11 00:15] falls asleep\n        [1518-10-15 00:57] wakes up\n        [1518-07-29 00:43] wakes up\n        [1518-06-01 00:40] falls asleep\n        [1518-09-01 00:31] falls asleep\n        [1518-07-03 00:21] falls asleep\n        [1518-10-12 23:59] Guard #163 begins shift\n        [1518-07-02 00:23] falls asleep\n        [1518-08-31 00:35] wakes up\n        [1518-08-08 00:19] wakes up\n        [1518-10-20 00:42] falls asleep\n        [1518-07-19 23:50] Guard #587 begins shift\n        [1518-06-15 00:55] wakes up\n        [1518-08-09 00:03] falls asleep\n        [1518-10-24 00:50] wakes up\n        [1518-09-12 00:04] Guard #2063 begins shift\n        [1518-07-07 00:00] Guard #3251 begins shift\n        [1518-09-01 00:12] wakes up\n        [1518-04-04 00:56] falls asleep\n        [1518-03-14 00:00] Guard #3331 begins shift\n        [1518-03-05 00:43] wakes up\n        [1518-10-20 00:51] falls asleep\n        [1518-08-29 00:40] falls asleep\n        [1518-07-20 00:03] falls asleep\n        [1518-10-02 23:56] Guard #311 begins shift\n        [1518-11-01 00:49] falls asleep\n        [1518-11-04 00:23] wakes up\n        [1518-08-11 23:58] Guard #311 begins shift\n        [1518-03-31 00:00] Guard #311 begins shift\n        [1518-11-15 00:30] falls asleep\n        [1518-04-30 00:38] falls asleep\n        [1518-06-12 00:14] wakes up\n        [1518-09-03 00:02] falls asleep\n        [1518-08-18 00:37] wakes up\n        [1518-03-05 00:26] wakes up\n        [1518-10-28 00:01] Guard #1069 begins shift\n        [1518-07-06 00:23] wakes up\n        [1518-10-27 00:25] wakes up\n        [1518-06-12 00:01] falls asleep\n        [1518-09-15 00:11] falls asleep\n        [1518-02-25 00:42] wakes up\n        [1518-07-12 00:02] Guard #2879 begins shift\n        [1518-02-27 00:21] falls asleep\n        [1518-03-21 00:11] falls asleep\n        [1518-03-09 00:57] wakes up\n        [1518-05-03 00:05] falls asleep\n        [1518-11-14 00:43] wakes up\n        [1518-03-10 00:53] falls asleep\n        [1518-05-18 00:26] falls asleep\n        [1518-09-26 23:57] Guard #631 begins shift\n        [1518-04-15 00:18] wakes up\n        [1518-03-26 00:01] Guard #2837 begins shift\n        [1518-05-03 00:54] wakes up\n        [1518-06-20 00:29] falls asleep\n        [1518-08-31 23:53] Guard #3331 begins shift\n        [1518-04-16 00:31] wakes up\n        [1518-04-24 00:56] wakes up\n        [1518-11-14 00:02] Guard #2971 begins shift\n        [1518-06-14 00:38] falls asleep\n        [1518-05-22 00:27] wakes up\n        [1518-10-14 00:14] falls asleep\n        [1518-04-08 00:05] falls asleep\n        [1518-10-12 00:08] falls asleep\n        [1518-10-08 23:58] Guard #3331 begins shift\n        [1518-08-16 00:04] Guard #3181 begins shift\n        [1518-04-08 00:06] wakes up\n        [1518-07-19 00:23] wakes up\n        [1518-09-08 00:48] falls asleep\n        [1518-04-13 23:59] Guard #3331 begins shift\n        [1518-11-16 00:29] wakes up\n        [1518-02-19 00:24] falls asleep\n        [1518-06-26 23:56] Guard #3331 begins shift\n        [1518-04-07 23:50] Guard #3181 begins shift\n        [1518-05-09 00:04] Guard #2179 begins shift\n        [1518-08-14 00:56] wakes up\n        [1518-08-20 00:00] Guard #631 begins shift\n        [1518-04-14 00:54] wakes up\n        [1518-07-31 00:23] falls asleep\n        [1518-07-05 00:03] falls asleep\n        [1518-07-16 00:00] Guard #1021 begins shift\n        [1518-06-25 23:56] Guard #2971 begins shift\n        [1518-11-22 00:00] falls asleep\n        [1518-08-12 00:39] wakes up\n        [1518-10-26 00:04] Guard #89 begins shift\n        [1518-05-10 00:16] falls asleep\n        [1518-03-20 00:42] wakes up\n        [1518-03-10 00:47] wakes up\n        [1518-02-25 00:26] falls asleep\n        [1518-02-16 00:07] falls asleep\n        [1518-07-25 00:56] wakes up\n        [1518-07-14 00:39] wakes up\n        [1518-06-01 00:48] wakes up\n        [1518-07-20 00:41] falls asleep\n        [1518-06-27 00:31] falls asleep\n        [1518-03-06 00:29] wakes up\n        [1518-07-19 00:31] falls asleep\n        [1518-04-26 00:14] wakes up\n        [1518-09-25 00:39] wakes up\n        [1518-06-27 00:21] wakes up\n        [1518-05-08 00:14] falls asleep\n        [1518-06-28 00:21] falls asleep\n        [1518-08-30 00:55] falls asleep\n        [1518-07-20 23:58] Guard #1579 begins shift\n        [1518-07-27 00:02] falls asleep\n        [1518-08-12 00:52] wakes up\n        [1518-07-02 00:31] wakes up\n        [1518-02-13 00:43] falls asleep\n        [1518-11-02 00:28] falls asleep\n        [1518-05-16 00:03] Guard #1021 begins shift\n        [1518-08-08 23:53] Guard #89 begins shift\n        [1518-03-21 00:20] wakes up\n        [1518-02-14 00:36] falls asleep\n        [1518-05-04 00:23] wakes up\n        [1518-03-12 00:02] Guard #631 begins shift\n        [1518-11-17 00:59] wakes up\n        [1518-03-02 00:54] wakes up\n        [1518-04-23 00:01] Guard #2843 begins shift\n        [1518-09-07 00:44] wakes up\n        [1518-06-21 00:01] falls asleep\n        [1518-11-15 00:33] wakes up\n        [1518-05-18 00:40] falls asleep\n        [1518-06-20 23:54] Guard #983 begins shift\n        [1518-07-19 00:15] falls asleep\n        [1518-03-05 00:34] falls asleep\n        [1518-05-06 00:00] Guard #1069 begins shift\n        [1518-07-22 00:46] wakes up\n        [1518-06-12 00:24] falls asleep\n        [1518-11-22 00:45] wakes up\n        [1518-05-16 00:41] falls asleep\n        [1518-03-26 23:56] Guard #2971 begins shift\n        [1518-11-16 00:13] falls asleep\n        [1518-07-01 00:56] wakes up\n        [1518-09-17 00:02] Guard #3331 begins shift\n        [1518-04-29 00:18] wakes up\n        [1518-10-16 00:51] wakes up\n        [1518-09-08 23:58] Guard #311 begins shift\n        [1518-10-02 00:02] falls asleep\n        [1518-11-18 00:28] falls asleep\n        [1518-07-03 00:53] wakes up\n        [1518-06-22 00:02] falls asleep\n        [1518-02-28 00:04] Guard #2837 begins shift\n        [1518-05-25 00:58] wakes up\n        [1518-07-24 00:43] falls asleep\n        [1518-03-06 00:20] falls asleep\n        [1518-06-15 00:02] Guard #3433 begins shift\n        [1518-04-06 00:51] wakes up\n        [1518-03-07 00:33] falls asleep\n        [1518-11-20 23:50] Guard #3181 begins shift\n        [1518-02-11 00:03] falls asleep\n        [1518-08-26 00:53] falls asleep\n        [1518-07-11 00:37] falls asleep\n        [1518-02-26 00:30] falls asleep\n        [1518-06-07 00:09] falls asleep\n        [1518-04-26 00:54] wakes up\n        [1518-10-15 00:00] Guard #2879 begins shift\n        [1518-10-10 00:23] wakes up\n        [1518-09-02 00:18] falls asleep\n        [1518-10-07 00:34] falls asleep\n        [1518-06-14 00:50] wakes up\n        [1518-09-16 00:01] Guard #2971 begins shift\n        [1518-08-04 00:39] wakes up\n        [1518-10-20 00:45] wakes up\n        [1518-09-06 00:56] wakes up\n        [1518-04-21 00:14] falls asleep\n        [1518-09-17 00:42] wakes up\n        [1518-05-20 00:28] wakes up\n        [1518-03-11 00:59] wakes up\n        [1518-08-06 00:44] wakes up\n        [1518-07-05 00:40] wakes up\n        [1518-11-06 00:52] falls asleep\n        [1518-03-04 00:01] Guard #3181 begins shift\n        [1518-05-13 00:03] Guard #89 begins shift\n        [1518-09-20 00:42] wakes up\n        [1518-05-27 00:11] falls asleep\n        [1518-03-10 00:11] falls asleep\n        [1518-04-07 00:27] falls asleep\n        [1518-02-15 00:49] wakes up\n        [1518-06-05 00:03] Guard #1069 begins shift\n        [1518-05-21 00:21] falls asleep\n        [1518-06-20 00:10] falls asleep\n        [1518-06-06 00:59] wakes up\n        [1518-05-11 00:16] falls asleep\n        [1518-02-27 00:06] falls asleep\n        [1518-02-12 23:59] Guard #1069 begins shift\n        [1518-11-20 00:58] wakes up\n        [1518-06-13 00:33] wakes up\n        [1518-09-30 00:00] Guard #2843 begins shift\n        [1518-08-02 00:41] wakes up\n        [1518-04-04 00:02] Guard #1579 begins shift\n        [1518-11-06 00:46] wakes up\n        [1518-05-06 00:24] falls asleep\n        [1518-09-14 00:14] falls asleep\n        [1518-08-19 00:48] falls asleep\n        [1518-04-07 00:37] wakes up\n        [1518-06-13 00:21] falls asleep\n        [1518-05-23 00:54] wakes up\n        [1518-04-22 00:29] wakes up\n        [1518-07-03 00:01] Guard #2671 begins shift\n        [1518-04-29 00:00] falls asleep\n        [1518-08-11 00:39] falls asleep\n        [1518-02-19 00:55] wakes up\n        [1518-02-20 23:53] Guard #1579 begins shift\n        [1518-10-09 00:59] wakes up\n        [1518-10-29 23:57] Guard #2957 begins shift\n        [1518-09-02 00:00] Guard #2837 begins shift\n        [1518-05-25 00:24] falls asleep\n        [1518-10-17 00:53] wakes up\n        [1518-04-24 00:51] falls asleep\n        [1518-09-29 00:33] falls asleep\n        [1518-04-11 00:28] falls asleep\n        [1518-04-14 00:41] falls asleep\n        [1518-06-01 00:29] falls asleep\n        [1518-09-18 00:31] falls asleep\n        [1518-08-04 00:56] falls asleep\n        [1518-06-08 00:04] Guard #631 begins shift\n        [1518-08-01 23:57] Guard #2801 begins shift\n        [1518-10-21 00:35] falls asleep\n        [1518-04-09 00:40] falls asleep\n        [1518-09-03 00:52] wakes up\n        [1518-04-27 00:47] wakes up\n        [1518-08-24 00:52] falls asleep\n        [1518-11-17 00:02] Guard #1069 begins shift\n        [1518-02-22 00:03] Guard #1021 begins shift\n        [1518-09-29 00:55] wakes up\n        [1518-06-26 00:09] falls asleep\n        [1518-06-29 00:46] falls asleep\n        [1518-11-17 23:59] Guard #1021 begins shift\n        [1518-05-23 00:01] Guard #1021 begins shift\n        [1518-08-05 23:57] Guard #3331 begins shift\n        [1518-03-29 00:45] wakes up\n        [1518-02-13 23:57] Guard #587 begins shift\n        [1518-03-10 00:59] wakes up\n        [1518-09-30 00:22] falls asleep\n        [1518-04-28 00:20] wakes up\n        [1518-03-12 23:59] Guard #2879 begins shift\n        [1518-10-09 00:38] falls asleep\n        [1518-06-21 00:57] wakes up\n        [1518-10-19 00:45] wakes up\n        [1518-08-12 00:50] falls asleep\n        [1518-07-24 00:05] falls asleep\n        [1518-10-29 00:48] falls asleep\n        [1518-08-26 00:50] wakes up\n        [1518-02-20 00:52] wakes up\n        [1518-06-16 23:47] Guard #1069 begins shift\n        [1518-06-06 00:17] falls asleep\n        [1518-11-03 00:00] Guard #2671 begins shift\n        [1518-07-24 00:50] wakes up\n        [1518-05-22 00:09] falls asleep\n        [1518-05-04 00:00] falls asleep\n        [1518-06-21 00:32] falls asleep\n        [1518-06-30 00:21] falls asleep\n        [1518-05-20 00:06] falls asleep\n        [1518-07-08 00:31] wakes up\n        [1518-03-21 00:25] falls asleep\n        [1518-09-05 23:57] Guard #1069 begins shift\n        [1518-03-10 23:47] Guard #2837 begins shift\n        [1518-08-30 00:41] wakes up\n        [1518-03-06 23:56] Guard #2837 begins shift\n        [1518-09-23 00:59] wakes up\n        [1518-11-09 00:34] wakes up\n        [1518-08-11 00:54] wakes up\n        [1518-04-14 00:52] falls asleep\n        [1518-04-30 00:52] wakes up\n        [1518-11-03 00:40] wakes up\n        [1518-02-21 00:03] falls asleep\n        [1518-05-19 00:05] falls asleep\n        [1518-02-22 00:12] falls asleep\n        [1518-03-31 00:53] wakes up\n        [1518-05-18 00:57] wakes up\n        [1518-04-12 00:33] falls asleep\n        [1518-03-10 00:23] falls asleep\n        [1518-03-06 00:00] falls asleep\n        [1518-09-25 00:17] falls asleep\n        [1518-07-28 00:41] wakes up\n        [1518-03-29 00:01] Guard #3251 begins shift\n        [1518-04-21 23:56] Guard #2971 begins shift\n        [1518-08-31 00:02] falls asleep\n        [1518-03-31 00:57] falls asleep\n        [1518-09-20 00:07] falls asleep\n        [1518-04-01 00:04] Guard #3433 begins shift\n        [1518-05-10 00:38] wakes up\n        [1518-04-03 00:32] wakes up\n        [1518-08-28 00:40] wakes up\n        [1518-05-12 00:54] wakes up\n        [1518-07-22 23:50] Guard #2801 begins shift\n        [1518-06-22 00:53] wakes up\n        [1518-07-04 00:48] wakes up\n        [1518-09-21 00:11] wakes up\n        [1518-11-09 00:27] falls asleep\n        [1518-04-08 00:32] falls asleep\n        [1518-07-17 00:00] Guard #587 begins shift\n        [1518-08-27 00:41] falls asleep\n        [1518-10-21 00:00] Guard #311 begins shift\n        [1518-10-05 00:49] falls asleep\n        [1518-09-10 00:00] Guard #3433 begins shift\n        [1518-07-28 00:26] wakes up\n        [1518-08-04 23:56] Guard #3109 begins shift\n        [1518-10-06 00:49] falls asleep\n        [1518-06-11 00:58] wakes up\n        [1518-09-08 00:02] Guard #163 begins shift\n        [1518-04-13 00:48] wakes up\n        [1518-06-18 00:02] Guard #311 begins shift\n        [1518-08-26 00:33] falls asleep\n        [1518-10-01 00:01] falls asleep\n        [1518-07-19 00:01] Guard #2837 begins shift\n        [1518-02-18 00:47] falls asleep\n        [1518-02-19 23:59] Guard #1021 begins shift\n        [1518-08-23 00:09] falls asleep\n        [1518-07-12 00:06] falls asleep\n        [1518-07-10 00:31] wakes up\n        [1518-03-29 00:07] wakes up\n        [1518-03-15 00:01] Guard #2179 begins shift\n        [1518-11-21 00:02] falls asleep\n        [1518-06-11 23:54] Guard #3251 begins shift\n        [1518-06-27 00:53] wakes up\n        [1518-03-03 00:04] Guard #311 begins shift\n        [1518-03-18 00:39] falls asleep\n        [1518-08-22 00:48] falls asleep\n        [1518-10-17 00:05] falls asleep\n        [1518-07-08 00:46] wakes up\n        [1518-09-23 00:00] Guard #89 begins shift\n        [1518-02-22 00:47] falls asleep\n        [1518-11-22 23:59] Guard #2971 begins shift\n        [1518-06-12 00:50] wakes up\n        [1518-04-18 00:46] wakes up\n        [1518-07-21 00:43] falls asleep\n        [1518-05-08 00:00] Guard #983 begins shift\n        [1518-04-30 00:56] falls asleep\n        [1518-09-19 00:42] wakes up\n        [1518-08-15 00:02] falls asleep\n        [1518-10-26 00:38] falls asleep\n        [1518-11-07 00:05] falls asleep\n        [1518-04-09 00:01] Guard #2179 begins shift\n        [1518-06-14 00:04] Guard #2971 begins shift\n        [1518-10-11 23:59] Guard #2971 begins shift\n        [1518-03-26 00:12] falls asleep\n        [1518-08-13 00:07] falls asleep\n        [1518-03-31 00:51] falls asleep\n        [1518-05-17 00:00] Guard #1069 begins shift\n        [1518-05-23 00:45] wakes up\n        [1518-08-30 00:59] wakes up\n        [1518-11-10 00:00] Guard #3433 begins shift\n        [1518-09-23 00:55] falls asleep\n        [1518-04-10 00:53] wakes up\n        [1518-11-06 23:52] Guard #2843 begins shift\n        [1518-09-14 00:50] falls asleep\n        [1518-11-09 00:49] wakes up\n        [1518-08-01 00:01] Guard #1069 begins shift\n        [1518-11-01 00:57] wakes up\n        [1518-10-18 00:16] falls asleep\n        [1518-02-28 23:59] Guard #2879 begins shift\n        [1518-11-05 00:11] falls asleep\n        [1518-10-22 00:22] falls asleep\n        [1518-03-06 00:28] falls asleep\n        [1518-07-13 23:46] Guard #311 begins shift\n        [1518-10-17 00:39] wakes up\n        [1518-04-25 00:09] falls asleep\n        [1518-05-07 00:39] falls asleep\n        [1518-02-19 00:01] Guard #983 begins shift\n        [1518-08-26 23:57] Guard #2879 begins shift\n        [1518-10-18 00:54] falls asleep\n        [1518-09-16 00:48] falls asleep\n        [1518-03-13 00:06] falls asleep\n        [1518-05-29 00:58] wakes up\n        [1518-11-18 00:50] falls asleep\n        [1518-10-07 00:29] wakes up\n        [1518-04-10 00:00] Guard #1069 begins shift\n        [1518-11-23 00:52] wakes up\n        [1518-11-03 23:57] Guard #2801 begins shift\n        [1518-08-30 23:50] Guard #3251 begins shift\n        [1518-09-08 00:58] wakes up\n        [1518-11-19 00:56] wakes up\n        [1518-03-27 00:41] wakes up\n        [1518-10-08 00:53] wakes up\n        [1518-10-14 00:02] Guard #2971 begins shift\n        [1518-11-15 00:40] wakes up\n        [1518-08-03 00:39] wakes up\n        [1518-10-23 23:59] Guard #89 begins shift\n        [1518-03-28 00:02] Guard #163 begins shift\n        [1518-06-03 00:51] falls asleep\n        [1518-08-19 00:07] falls asleep\n        [1518-09-10 00:13] falls asleep\n        [1518-04-22 00:52] falls asleep\n        [1518-03-01 00:27] falls asleep\n        [1518-05-16 00:45] wakes up\n        [1518-04-04 00:43] wakes up\n        [1518-02-27 00:39] wakes up\n        [1518-02-24 00:50] wakes up\n        [1518-10-21 00:38] wakes up\n        [1518-09-16 00:09] falls asleep\n        [1518-10-02 00:14] wakes up\n        [1518-07-07 00:11] falls asleep\n        [1518-09-25 23:56] Guard #2843 begins shift\n        [1518-03-17 00:19] falls asleep\n        [1518-10-23 00:47] wakes up\n        [1518-06-09 00:00] Guard #89 begins shift\n        [1518-09-26 00:45] wakes up\n        [1518-09-21 00:09] falls asleep\n        [1518-07-06 00:08] falls asleep\n        [1518-04-18 00:02] Guard #89 begins shift\n        [1518-02-23 00:02] falls asleep\n        [1518-06-22 00:30] falls asleep\n        [1518-06-14 00:11] falls asleep\n        [1518-08-26 00:49] falls asleep\n        [1518-04-10 00:11] falls asleep\n        [1518-10-01 23:51] Guard #3331 begins shift\n        [1518-11-18 23:56] Guard #3181 begins shift\n        [1518-07-18 00:29] falls asleep\n        [1518-05-30 00:15] falls asleep\n        [1518-08-29 23:46] Guard #163 begins shift\n        [1518-09-21 00:55] wakes up\n        [1518-10-09 00:43] wakes up\n        [1518-06-21 00:28] wakes up\n        [1518-09-18 00:34] wakes up\n        [1518-03-22 00:00] falls asleep\n        [1518-04-16 00:18] falls asleep\n        [1518-05-03 00:52] falls asleep\n        [1518-06-11 00:14] falls asleep\n        [1518-09-23 00:50] wakes up\n        [1518-03-08 23:58] Guard #3331 begins shift\n        [1518-05-15 00:04] Guard #163 begins shift\n        [1518-06-18 00:33] wakes up\n        [1518-09-17 23:57] Guard #311 begins shift\n        [1518-07-22 00:29] falls asleep\n        [1518-04-13 00:43] falls asleep\n        [1518-08-12 23:57] Guard #89 begins shift\n        [1518-10-23 00:38] falls asleep\n        [1518-06-04 00:59] wakes up\n        [1518-07-08 00:40] wakes up\n        [1518-03-16 00:42] falls asleep\n        [1518-08-13 00:47] wakes up\n        [1518-06-07 00:03] Guard #2879 begins shift\n        [1518-02-16 00:58] wakes up\n        [1518-05-25 00:40] wakes up\n        [1518-05-14 00:02] Guard #2671 begins shift\n        [1518-08-16 00:16] falls asleep\n        [1518-08-27 23:59] Guard #631 begins shift\n        [1518-10-07 00:00] Guard #2879 begins shift\n        [1518-06-25 00:59] wakes up\n        [1518-02-27 00:00] Guard #2801 begins shift\n        [1518-03-17 00:54] falls asleep\n        [1518-07-10 00:44] falls asleep\n        [1518-02-15 00:37] falls asleep\n        [1518-05-29 00:15] falls asleep\n        [1518-09-16 00:54] wakes up\n        [1518-07-05 23:59] Guard #2671 begins shift\n        [1518-04-18 00:23] falls asleep\n        [1518-08-24 00:58] wakes up\n        [1518-08-19 00:00] Guard #2837 begins shift\n        [1518-06-03 00:54] wakes up\n        [1518-05-17 00:34] falls asleep\n        [1518-04-09 00:23] falls asleep\n        [1518-10-10 23:57] Guard #2843 begins shift\n        [1518-03-24 00:59] wakes up\n        [1518-02-18 00:41] wakes up\n        [1518-10-25 00:48] falls asleep\n        [1518-02-28 00:53] wakes up\n        [1518-03-03 00:55] wakes up\n        [1518-04-01 00:36] falls asleep\n        [1518-02-24 00:39] wakes up\n        [1518-08-17 00:19] falls asleep\n        [1518-05-09 23:57] Guard #1579 begins shift\n        [1518-07-19 00:37] wakes up\n        [1518-10-18 00:57] wakes up\n        [1518-04-26 00:53] falls asleep\n        [1518-09-18 00:46] wakes up\n        [1518-04-22 00:54] wakes up\n        [1518-07-26 23:48] Guard #1069 begins shift\n        [1518-04-28 00:26] wakes up\n        [1518-06-08 00:45] falls asleep\n        [1518-10-31 00:47] falls asleep\n        [1518-05-13 00:53] wakes up\n        [1518-07-21 00:52] wakes up\n        [1518-09-09 00:32] falls asleep\n        [1518-08-02 00:34] falls asleep\n        [1518-02-27 00:09] wakes up\n        [1518-05-06 23:59] Guard #983 begins shift\n        [1518-03-17 00:57] wakes up\n        [1518-04-28 00:23] falls asleep\n        [1518-09-17 00:41] falls asleep\n        [1518-11-04 00:15] falls asleep\n        [1518-10-25 00:30] wakes up\n        [1518-08-09 00:57] wakes up\n        [1518-03-21 00:00] Guard #2671 begins shift\n        [1518-02-20 00:44] falls asleep\n        [1518-06-02 23:53] Guard #631 begins shift\n        [1518-05-31 00:01] Guard #2957 begins shift\n        [1518-09-24 00:21] falls asleep\n        [1518-06-21 23:52] Guard #1021 begins shift\n        [1518-06-16 00:35] falls asleep\n        [1518-10-07 23:57] Guard #3331 begins shift\n        [1518-04-22 00:08] falls asleep\n        [1518-09-21 00:04] Guard #3433 begins shift\n        [1518-10-04 00:19] falls asleep\n        [1518-04-02 00:00] Guard #2971 begins shift\n        [1518-08-13 00:57] falls asleep\n        [1518-08-06 00:39] falls asleep\n        [1518-03-05 23:52] Guard #2971 begins shift\n        [1518-06-04 00:15] falls asleep\n        [1518-04-03 00:51] falls asleep\n        [1518-09-18 23:51] Guard #3181 begins shift\n        [1518-10-15 00:15] falls asleep\n        [1518-09-11 00:54] wakes up\n        [1518-03-08 00:20] falls asleep\n        [1518-11-01 00:54] falls asleep\n        [1518-02-17 00:47] wakes up\n        [1518-06-29 00:02] falls asleep\n        [1518-10-19 00:27] falls asleep\n        [1518-09-10 23:59] Guard #311 begins shift\n        [1518-11-08 00:03] Guard #3109 begins shift\n        [1518-07-23 00:55] wakes up\n        [1518-09-04 00:51] wakes up\n        [1518-10-19 00:10] falls asleep\n        [1518-04-02 23:47] Guard #1069 begins shift\n        [1518-03-04 00:57] wakes up\n        [1518-09-13 00:52] wakes up\n        [1518-10-16 23:51] Guard #631 begins shift\n        [1518-10-07 00:09] falls asleep\n        [1518-05-23 00:50] falls asleep\n        [1518-04-26 23:48] Guard #2879 begins shift\n        [1518-10-21 00:42] falls asleep\n        [1518-07-13 00:54] wakes up\n        [1518-08-07 00:02] Guard #2957 begins shift\n        [1518-03-17 00:47] wakes up\n        [1518-07-28 00:01] Guard #2971 begins shift\n        [1518-08-22 00:59] wakes up\n        [1518-07-23 00:03] falls asleep\n        [1518-11-04 23:56] Guard #3331 begins shift\n        [1518-03-30 00:41] falls asleep\n        [1518-02-23 00:25] falls asleep\n        [1518-10-21 00:53] wakes up\n        [1518-07-10 23:57] Guard #631 begins shift\n        [1518-07-25 00:00] falls asleep\n        [1518-04-28 23:48] Guard #983 begins shift\n        [1518-05-21 00:00] Guard #631 begins shift\n        [1518-09-12 23:59] Guard #1069 begins shift\n        [1518-11-19 00:36] falls asleep\n        [1518-05-02 00:21] falls asleep\n        [1518-04-13 00:03] Guard #2179 begins shift\n        [1518-11-05 00:56] wakes up\n        [1518-08-14 00:06] falls asleep\n        [1518-09-23 00:40] falls asleep\n        [1518-11-12 00:17] falls asleep\n        [1518-04-02 00:53] wakes up\n        [1518-05-04 00:56] wakes up\n        [1518-04-13 00:26] falls asleep\n        [1518-10-21 23:59] Guard #311 begins shift\n        [1518-04-07 00:00] Guard #1021 begins shift\n        [1518-10-10 00:55] wakes up\n        [1518-05-03 00:45] wakes up\n        [1518-03-24 00:29] falls asleep\n        [1518-06-27 00:15] falls asleep\n        [1518-11-12 00:00] Guard #1069 begins shift\n        [1518-04-04 23:56] Guard #1021 begins shift\n        [1518-04-05 00:06] falls asleep\n        [1518-10-31 00:58] wakes up\n        [1518-04-29 00:47] wakes up\n        [1518-09-14 00:53] wakes up\n        [1518-11-20 00:04] Guard #311 begins shift\n        [1518-07-04 23:46] Guard #1579 begins shift\n        [1518-06-02 00:08] falls asleep\n        [1518-03-15 23:59] Guard #163 begins shift\n        [1518-08-14 00:40] wakes up\n        [1518-05-26 23:57] Guard #2179 begins shift\n        [1518-07-06 00:29] falls asleep\n        [1518-04-21 00:56] wakes up\n        [1518-02-16 00:48] wakes up\n        [1518-04-17 00:40] wakes up\n        [1518-08-21 00:02] Guard #3433 begins shift\n        [1518-05-18 00:04] Guard #3181 begins shift\n        [1518-05-24 00:03] Guard #2957 begins shift\n        [1518-09-09 00:44] wakes up\n        [1518-02-21 00:50] wakes up\n        [1518-07-13 00:02] Guard #163 begins shift\n        [1518-03-12 00:21] wakes up\n        [1518-09-03 23:58] Guard #983 begins shift\n        [1518-09-14 00:10] wakes up\n        [1518-10-31 00:13] falls asleep\n        [1518-04-15 00:00] Guard #3251 begins shift\n        [1518-07-14 00:00] falls asleep\n        [1518-02-22 00:33] wakes up\n        [1518-09-28 00:58] wakes up\n        [1518-04-25 00:03] Guard #1069 begins shift\n        [1518-04-13 00:39] wakes up\n        [1518-07-31 00:04] Guard #3331 begins shift\n        [1518-06-30 00:59] wakes up\n        [1518-06-01 00:53] falls asleep\n        [1518-10-28 00:49] wakes up\n        [1518-07-01 23:57] Guard #89 begins shift\n        [1518-04-29 00:52] falls asleep\n        [1518-02-17 00:36] falls asleep\n        [1518-03-23 00:51] wakes up\n        [1518-09-07 00:00] falls asleep\n        [1518-11-02 00:52] wakes up\n        [1518-09-01 00:01] falls asleep\n        [1518-07-17 00:14] falls asleep\n        [1518-05-11 00:36] wakes up\n        [1518-08-03 00:02] falls asleep\n        [1518-10-03 23:59] Guard #89 begins shift\n        [1518-03-15 00:41] wakes up\n        [1518-07-12 00:50] wakes up\n        [1518-08-21 00:58] wakes up\n        [1518-07-10 00:49] wakes up\n        [1518-06-19 00:05] falls asleep\n        [1518-05-30 00:29] wakes up\n        [1518-10-15 00:27] wakes up\n        [1518-02-13 00:55] wakes up\n        [1518-05-17 00:51] wakes up\n        [1518-06-09 00:58] wakes up\n        [1518-08-23 23:59] Guard #2671 begins shift\n        [1518-05-31 23:59] Guard #311 begins shift\n        [1518-08-20 00:34] falls asleep\n        [1518-07-20 00:37] wakes up\n        [1518-02-23 00:19] wakes up\n        [1518-04-21 00:32] wakes up\n        [1518-06-07 00:50] wakes up\n        [1518-07-09 00:24] falls asleep\n        [1518-10-28 23:59] Guard #631 begins shift\n        [1518-03-02 00:02] falls asleep\n        [1518-03-19 00:56] falls asleep\n        [1518-02-20 00:17] falls asleep\n        [1518-02-16 23:56] Guard #3331 begins shift\n        [1518-06-14 00:23] wakes up\n        [1518-03-22 00:55] falls asleep\n        [1518-10-19 23:48] Guard #587 begins shift\n        [1518-03-09 23:56] Guard #1579 begins shift\n        [1518-11-12 00:38] wakes up\n        [1518-07-28 00:36] falls asleep\n        [1518-09-26 00:25] falls asleep\n        [1518-07-21 00:56] falls asleep\n        [1518-07-12 00:46] falls asleep\n        [1518-05-04 00:48] falls asleep\n        [1518-09-10 00:59] wakes up\n        [1518-06-23 00:40] falls asleep\n        [1518-07-26 00:48] wakes up\n        [1518-08-02 00:53] falls asleep\n        [1518-06-17 00:58] wakes up\n        [1518-05-13 00:29] falls asleep\n        [1518-03-31 00:44] falls asleep\n        [1518-03-04 00:38] wakes up\n        [1518-09-05 00:03] falls asleep\n        [1518-09-16 00:31] wakes up\n        [1518-07-19 00:41] falls asleep\n        [1518-08-25 00:59] wakes up\n        [1518-06-22 00:27] wakes up\n        [1518-03-17 00:03] Guard #2843 begins shift\n        [1518-10-22 23:59] Guard #631 begins shift\n        [1518-10-24 00:24] falls asleep\n        [1518-07-17 00:55] wakes up\n        [1518-11-16 00:00] Guard #1069 begins shift\n        [1518-03-31 00:46] wakes up\n        [1518-03-09 00:07] falls asleep\n        [1518-05-21 00:42] wakes up\n        [1518-06-16 00:03] Guard #2843 begins shift\n        [1518-07-30 00:55] wakes up\n        [1518-05-18 00:36] wakes up\n        [1518-11-15 00:04] Guard #2879 begins shift\n        [1518-09-20 00:53] falls asleep\n        [1518-09-22 00:02] Guard #3109 begins shift\n        [1518-04-28 00:09] falls asleep\n        [1518-08-18 00:12] wakes up\n        [1518-04-25 00:52] wakes up\n        [1518-08-14 23:49] Guard #2837 begins shift\n        [1518-11-23 00:16] falls asleep\n        [1518-10-08 00:24] falls asleep\n        [1518-10-20 00:00] falls asleep\n        [1518-06-07 00:44] falls asleep\n        [1518-06-25 00:18] falls asleep\n        [1518-10-11 00:35] wakes up\n        [1518-11-09 00:37] falls asleep\n        [1518-06-28 23:53] Guard #1021 begins shift\n        [1518-08-22 00:04] wakes up\n        [1518-07-08 00:43] falls asleep\n        [1518-03-12 00:17] falls asleep\n        [1518-10-15 00:56] falls asleep\n        [1518-11-10 00:38] falls asleep\n        [1518-02-12 00:48] wakes up\n        [1518-10-08 00:14] falls asleep\n        [1518-11-17 00:29] falls asleep\n        [1518-08-04 00:37] falls asleep\n        [1518-10-12 00:34] wakes up\n        [1518-08-08 00:04] falls asleep\n        [1518-08-01 00:42] wakes up\n        [1518-09-11 00:46] falls asleep\n        [1518-09-25 00:18] wakes up\n        [1518-02-11 00:19] wakes up\n        [1518-03-20 00:04] falls asleep\n        [1518-05-25 00:56] falls asleep\n        [1518-04-06 00:21] falls asleep\n        [1518-06-20 00:52] wakes up\n        [1518-05-28 00:43] wakes up\n        [1518-03-23 23:58] Guard #2879 begins shift\n        [1518-08-15 00:50] wakes up\n        [1518-03-07 23:57] Guard #2879 begins shift\n        [1518-07-25 23:59] Guard #3181 begins shift\n        [1518-08-02 23:52] Guard #2879 begins shift\n        [1518-07-23 23:49] Guard #1021 begins shift\n        [1518-10-18 00:48] wakes up\n        [1518-04-23 00:55] wakes up\n        [1518-04-02 00:21] falls asleep\n        [1518-06-11 00:02] Guard #3331 begins shift\n        [1518-06-24 00:34] falls asleep\n        [1518-04-04 00:53] wakes up\n        [1518-04-09 00:33] wakes up\n        [1518-06-29 00:52] wakes up\n        [1518-05-12 00:20] falls asleep\n        [1518-05-27 00:59] wakes up\n        [1518-04-11 00:42] wakes up\n        [1518-09-01 00:58] wakes up\n        [1518-10-07 00:37] wakes up\n        [1518-04-11 23:58] Guard #2179 begins shift\n        [1518-11-20 00:57] falls asleep\n        [1518-03-30 00:29] falls asleep\n        [1518-04-14 00:46] wakes up\n        [1518-07-16 00:33] falls asleep\n        [1518-04-30 00:59] wakes up\n        [1518-03-01 00:44] wakes up\n        [1518-10-06 00:59] wakes up\n        [1518-05-02 00:00] Guard #1069 begins shift\n        [1518-06-08 00:53] wakes up\n        [1518-07-16 00:59] wakes up\n        [1518-05-06 00:39] wakes up\n        [1518-06-29 00:42] wakes up\n        [1518-02-18 00:51] wakes up\n        [1518-03-03 00:24] falls asleep\n        [1518-08-04 00:58] wakes up\n        [1518-08-12 00:35] falls asleep\n        [1518-03-27 00:36] falls asleep\n        [1518-05-04 23:58] Guard #1579 begins shift\n        [1518-03-25 00:10] falls asleep\n        [1518-06-19 23:57] Guard #631 begins shift\n        [1518-02-24 00:44] falls asleep\n        [1518-10-26 00:57] wakes up\n        [1518-03-14 00:44] wakes up\n        [1518-11-06 00:31] falls asleep\n        [1518-11-22 00:52] falls asleep\n        [1518-09-11 00:32] falls asleep\n        [1518-06-20 00:49] falls asleep\n        [1518-07-03 23:51] Guard #1021 begins shift\n        [1518-09-18 00:45] falls asleep\n        [1518-06-24 23:57] Guard #1021 begins shift\n        [1518-03-30 00:34] wakes up\n        [1518-03-07 00:45] wakes up\n        [1518-10-24 23:58] Guard #3331 begins shift\n        [1518-11-18 00:41] wakes up\n        [1518-02-20 00:37] wakes up\n        [1518-08-16 23:59] Guard #2971 begins shift\n        [1518-03-18 23:58] Guard #2801 begins shift\n        [1518-07-01 00:42] wakes up\n        [1518-04-05 00:54] wakes up\n        [1518-02-12 00:09] falls asleep\n        [1518-06-26 00:31] wakes up\n        [1518-05-01 00:00] Guard #3109 begins shift\n        [1518-08-08 00:59] wakes up\n        [1518-10-09 00:52] falls asleep\n        [1518-06-09 00:22] falls asleep\n        [1518-07-20 00:52] wakes up\n        [1518-09-30 23:50] Guard #2879 begins shift\n        [1518-11-11 00:33] wakes up\n        [1518-04-04 00:46] falls asleep\n        [1518-08-25 00:22] falls asleep\n        [1518-04-19 23:58] Guard #2063 begins shift\n        [1518-07-15 00:02] Guard #3109 begins shift\n        [1518-05-30 00:54] falls asleep\n        [1518-05-29 00:42] wakes up\n        [1518-04-17 00:01] Guard #3433 begins shift\n        [1518-03-19 00:35] wakes up\n        [1518-11-01 00:51] wakes up\n        [1518-02-26 00:55] wakes up\n        [1518-03-26 00:36] wakes up\n        [1518-10-18 00:39] falls asleep\n        [1518-03-04 00:43] falls asleep\n        [1518-06-15 00:52] falls asleep\n        [1518-10-16 00:02] Guard #2837 begins shift\n        [1518-06-01 00:30] wakes up\n        [1518-10-28 00:42] falls asleep\n        [1518-03-29 00:36] falls asleep\n        [1518-04-15 00:14] falls asleep\n        [1518-04-15 00:48] wakes up\n        [1518-08-17 00:30] wakes up\n        [1518-05-28 00:20] falls asleep\n        [1518-05-20 00:03] Guard #3251 begins shift\n        [1518-09-06 00:16] falls asleep\n        [1518-11-12 23:57] Guard #1579 begins shift\n        [1518-08-10 00:46] wakes up\n        [1518-08-02 00:56] wakes up\n        [1518-10-10 00:02] Guard #1021 begins shift\n        [1518-11-17 00:44] falls asleep\n        [1518-09-05 00:37] wakes up\n        [1518-08-13 00:58] wakes up\n        [1518-02-18 00:12] falls asleep\n        [1518-06-17 00:01] falls asleep\n        [1518-04-29 00:56] wakes up\n        [1518-07-01 00:03] Guard #3331 begins shift\n        [1518-08-06 00:47] falls asleep\n        [1518-05-29 00:00] Guard #311 begins shift\n        [1518-11-01 00:00] Guard #311 begins shift\n        [1518-03-04 23:58] Guard #1069 begins shift\n        [1518-06-04 00:01] Guard #3331 begins shift\n        [1518-07-05 00:13] wakes up\n        [1518-07-24 23:47] Guard #163 begins shift\n    \"\"\".trimIndent()\n\n    // Test: Parse start of shift\n    run {\n        val line = \"[1518-02-10 23:47] Guard #631 begins shift\"\n        val expected = Day04.State().beginShift(631)\n        val actual = Day04.processLine(Day04.State(), line)\n        check(actual == expected) { \"Failed: Parse start of shift\\nExpected: $expected\\nActual: $actual\" }\n    }\n\n    // Test: Part 1 sample\n    run {\n        val result = Day04(day04_sample.lines()).part1()\n        check(result == 240) { \"Failed: Part 1 sample\\nExpected: 240\\nActual: $result\" }\n    }\n\n    // Test: Part 1 actual input\n    run {\n        val result = Day04(day04.lines()).part1()\n        check(result == 30630) { \"Failed: Part 1 input\\nExpected: 30630\\nActual: $result\" }\n    }\n\n    // Test: Part 2 sample\n    run {\n        val result = Day04(day04_sample.lines()).part2()\n        check(result == 4455) { \"Failed: Part 2 sample\\nExpected: 4455\\nActual: $result\" }\n    }\n\n    // Test: Part 2 actual input\n    run {\n        val result = Day04(day04.lines()).part2()\n        check(result == 136571) { \"Failed: Part 2 input\\nExpected: 136571\\nActual: $result\" }\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Updates the guard state based on a single log line.\n *\n * Parses the input line to detect whether a guard begins a shift, falls asleep,\n * or wakes up, and updates the current state accordingly. The function uses\n * regular expressions to match the event type and extracts the relevant guard\n * ID or minute value to update the state. If the line does not match any known\n * pattern, an exception is thrown.\n *\n * @param status the current guard state, containing the active guard, nap start time, and recorded naps\n * @param line a log entry string describing a guard's action\n * @return a new [State] reflecting the changes implied by the log line\n */", "canonical_solution": "fun processLine(status: State, line: String): State = when {\n    line.matches(beginShiftRE) -> beginShiftRE.find(line)!!.intMatch().run(status::beginShift)\n    line.matches(fallAsleepRE) -> fallAsleepRE.find(line)!!.intMatch().run(status::fallAsleep)\n    line.matches(wakesUpRE) -> wakesUpRE.find(line)!!.intMatch().run(status::wakeUp)\n    else -> throw IllegalArgumentException(\"Failed to parse: $line\")\n}"}
{"task_id": "0", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "trapRainWater", "fn_name": "trapRainWater", "fn_signature": "private fun IntArray.trapRainWater(): Int {", "context": "/*\n * Copyright 2020 <NAME>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A custom [Iterator] implementation for custom [Stack].\n *\n * @param T the type of a data in this data structure.\n * @property stackNode the [Stack.Node] of this data structure.\n * @constructor Creates an [Iterator].\n */\nclass StackIterator<T>(private var stackNode: Stack.Node<T>?) : Iterator<T> {\n    /**\n     * Returns `true` if the iteration has more elements.\n     */\n    override fun hasNext(): Boolean = stackNode != null\n\n    /**\n     * Returns the next element in the iteration.\n     */\n    override fun next(): T {\n        if (!hasNext()) throw NoSuchElementException()\n        val current = stackNode!!\n        stackNode = current.next\n        return current.value\n    }\n}\n\n/**\n * A stack is a basic data structure that can be logically thought of as a linear structure represented by a real\n * physical stack or pile, a structure where insertion and deletion of items takes place at one end called top of\n * the stack. The basic concept can be illustrated by thinking of your data set as a stack of plates or books where\n * you can only take the top item off the stack in order to remove things from it. This structure is used all\n * throughout programming. The basic implementation of a stack is also called a LIFO (Last In First Out) to demonstrate\n * the way it accesses data, since as we will see there are various variations of stack implementations.\n * There are basically three operations that can be performed on stacks. They are 1) inserting an item into\n * a stack (push). 2) deleting an item from the stack (pop). 3) displaying the contents of the stack (peek or top).\n */\nclass Stack<T> : Collection<T> {\n    private var head: Node<T>? = null\n\n    class Node<T>(val value: T) {\n        var next: Node<T>? = null\n    }\n\n    override var size: Int = 0\n        private set\n\n    override fun contains(element: T): Boolean {\n        for (obj in this) {\n            if (obj == element) return true\n        }\n        return false\n    }\n\n    override fun containsAll(elements: Collection<T>): Boolean {\n        for (element in elements) {\n            if (!contains(element)) return false\n        }\n        return true\n    }\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun iterator(): Iterator<T> = StackIterator(head)\n\n    /**\n     * Returns the object [T] at the top of the [Stack] without removing it.\n     * @return An object [T]\n     * @throws NoSuchElementException\n     */\n    fun peek(): T {\n        if (size == 0) throw NoSuchElementException()\n        return head!!.value\n    }\n\n    /**\n     * Removes and returns the object [T] at the top of the [Stack].\n     * @return An object [T]\n     * @throws NoSuchElementException\n     */\n    fun poll(): T {\n        if (size == 0) throw NoSuchElementException()\n        val old = head!!\n        head = old.next\n        size--\n        return old.value\n    }\n\n    fun push(item: T) {\n        val newNode = Node(item)\n        newNode.next = head\n        head = newNode\n        size++\n    }\n}\n\nfun interface RainWaterStrategy {\n    operator fun invoke(arr: IntArray): Int\n}\n\nclass RainWaterStraightForward : RainWaterStrategy {\n    override operator fun invoke(arr: IntArray): Int {\n        return arr.trapRainWater()\n    }\n\n    private fun IntArray.trapRainWater(): Int {\n        /* GENERATE THIS FUNCTION */\n    }\n}\n\nclass RainWaterStack : RainWaterStrategy {\n    override operator fun invoke(arr: IntArray): Int {\n        return arr.trapRainWaterUsingStack()\n    }\n\n    private fun IntArray.trapRainWaterUsingStack(): Int {\n        var ans = 0\n        var current = 0\n        val stack = Stack<Int>()\n        while (current < this.size) {\n            while (stack.isNotEmpty() && this[current] > this[stack.peek()]) {\n                val top = stack.peek()\n                stack.poll()\n                if (stack.isEmpty()) break\n                val distance = current - stack.peek() - 1\n                val boundedHeight = this[current].coerceAtMost(this[stack.peek()] - this[top])\n                ans += distance * boundedHeight\n            }\n            stack.push(current++)\n        }\n        return ans\n    }\n}", "test": "fun main() {\n    val testCases = listOf(\n        Pair(intArrayOf(0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1), 6),\n        Pair(intArrayOf(), 0),\n        Pair(intArrayOf(1), 0),\n        Pair(intArrayOf(0, 1), 0),\n        Pair(intArrayOf(0, 1, 2, 1, 0, 3, 2), 3),\n    )\n\n    val strategies = listOf<RainWaterStrategy>(\n        RainWaterStraightForward(),\n        RainWaterStack()\n    )\n\n    for (strategy in strategies) {\n        for ((input, expected) in testCases) {\n            val actual = strategy.invoke(input)\n            if (actual != expected) {\n                throw AssertionError(\"Test failed for input=${input.joinToString()} with strategy=${strategy::class.simpleName}: expected=$expected, actual=$actual\")\n            }\n        }\n    }\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Calculates the total amount of trapped rainwater using the two-pointer approach.\n *\n * Iterates from both ends of the array towards the center, maintaining the maximum heights\n * encountered on the left and right. At each step, water trapped is determined by the\n * difference between the current height and the maximum boundary on that side.\n *\n * @receiver IntArray representing elevation heights where each index is a bar.\n * @return The total volume of water trapped between the bars.\n */", "canonical_solution": "private fun IntArray.trapRainWater(): Int {\n    if (this.isEmpty()) return 0\n\n    var low = 0\n    var high = size - 1\n    var maxLeft = 0\n    var maxRight = 0\n    var ans = 0\n\n    while (low <= high) {\n        if (this[low] <= this[high]) {\n            if (this[low] >= maxLeft) {\n                maxLeft = this[low]\n            } else {\n                ans += maxLeft - this[low]\n            }\n            low++\n        } else {\n            if (this[high] >= maxRight) maxRight = this[high]\n            ans += maxRight - this[high]\n            high--\n        }\n    }\n\n    return ans\n}"}
{"task_id": "92", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "outputValue", "fn_name": "outputValue", "fn_signature": "fun outputValue(patterns: List<String>, output: List<String>): Int {", "context": "fun findNumbers(input: List<String>): Int{\n    var one = 0\n    var four = 0\n    var seven = 0\n    var eight = 0\n    for(line in input){\n        val output = line.split(\"|\").last().trim().split(\" \")\n        one += output.count { it.length == 2 }\n        four += output.count { it.length == 4 }\n        seven += output.count { it.length == 3 }\n        eight += output.count { it.length == 7 }\n    }\n    return one + four + seven + eight\n}\n\nfun findOutputSum(input: List<String>): Int{\n    var sum = 0\n    for (line in input){\n        val (patterns, output) = line.split(\"|\").map { it.trim().split(\" \") }\n        sum += outputValue(patterns, output)\n    }\n    return sum\n}\n\nfun outputValue(patterns: List<String>, output: List<String>): Int {\n    /* GENERATE THIS FUNCTION */\n}", "test": "val input = \"\"\"\n    be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe\n    edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc\n    fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg\n    fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb\n    aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea\n    fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb\n    dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe\n    bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef\n    egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb\n    gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce\n\"\"\".trimIndent().lines()\n\nfun main() {\n\n    // Test 1: 1,4,7,8 appears 26 times\n    run {\n        val result = findNumbers(input)\n        if (result != 26) {\n            error(\"Test failed: Expected 26 but got $result\")\n        }\n    }\n\n    // Test 2: output values sum is 61229\n    run {\n        val result = findOutputSum(input)\n        if (result != 61229) {\n            error(\"Test failed: Expected 61229 but got $result\")\n        }\n    }\n\n    // Test 3: output value is 5353\n    run {\n        val result = outputValue(\n            \"acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab\".split(\" \"),\n            \"cdfeb fcadb cdfeb cdbaf\".split(\" \")\n        )\n        if (result != 5353) {\n            error(\"Test failed: Expected 5353 but got $result\")\n        }\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Decodes scrambled seven-segment display patterns into their numeric output value.\n *\n * This function takes a set of scrambled segment patterns and a list of output digit patterns,\n * deduces the correct wiring of segments by progressively narrowing down possible mappings,\n * and then translates the output patterns into their corresponding digits. It iteratively\n * eliminates impossible segment assignments until each segment is uniquely mapped, then\n * applies the resolved mapping to decode the output digits into an integer value.\n *\n * @param patterns the list of scrambled signal patterns representing all ten digits.\n * @param output the list of scrambled patterns that need to be decoded into digits.\n * @return the integer value obtained by decoding the output patterns.\n */", "canonical_solution": "fun outputValue(patterns: List<String>, output: List<String>): Int {\n    val map = mutableMapOf(\n        Pair('a', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('b', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('c', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('d', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('e', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('f', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('g', mutableListOf('a','b','c','d','e','f','g')),\n    )\n    while(!map.values.all { it.size == 1 }){\n        val foundOne = map['c']!!.size <= 2 && map['f']!!.size <= 2\n        for(pattern in patterns){\n            when{\n                pattern.length == 2 -> {\n                    map['c']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                    map['f']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                }\n                pattern.length == 3 && foundOne -> {\n                    val a = pattern.filterNot { map['c']!!.contains(it) || map['f']!!.contains(it) }\n                    map['a']!!.removeIf { !a.contains(it) }\n                }\n                pattern.length == 4 && map['d']!!.size == 1 && foundOne -> {\n                    val b = pattern.filterNot { map['d']!!.contains(it) || map['c']!!.contains(it) || map['f']!!.contains(it) }\n                    map['b']!!.removeIf { !b.contains(it) }\n                }\n                pattern.length == 4 -> {\n                    map['b']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                    map['c']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                    map['d']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                    map['f']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                }\n                pattern.length == 5 && foundOne -> {\n                    if(map['a']!!.size == 1){\n                        val dg = pattern.filterNot { map['a']!!.contains(it) || map['c']!!.contains(it) || map['f']!!.contains(it) }\n                        map['d']!!.removeIf { !dg.contains(it) }\n                        map['g']!!.removeIf { !dg.contains(it) }\n                    }\n                    if(map['b']!!.size == 1 && pattern.contains(map['b']!!.first())){\n                        map['f']!!.removeIf { !pattern.contains(it) }\n                    }\n                }\n            }\n        }\n        for(option in map){\n            if(option.value.size == 1){\n                map.filter { it.key != option.key }.forEach { (_, value) -> value.removeIf { it == option.value.first() } }\n            }\n        }\n    }\n    return output.map {\n        val a = it.contains(map['a']!!.first())\n        val b = it.contains(map['b']!!.first())\n        val c = it.contains(map['c']!!.first())\n        val d = it.contains(map['d']!!.first())\n        val e = it.contains(map['e']!!.first())\n        val f = it.contains(map['f']!!.first())\n        val g = it.contains(map['g']!!.first())\n        if(a && b && c && !d && e && f && g) return@map '0'\n        if(!a && !b && c && !d && !e && f && !g) return@map '1'\n        if(a && !b && c && d && e && !f && g) return@map '2'\n        if(a && !b && c && d && !e && f && g) return@map '3'\n        if(!a && b && c && d && !e && f && !g) return@map '4'\n        if(a && b && !c && d && !e && f && g) return@map '5'\n        if(a && b && !c && d && e && f && g) return@map '6'\n        if(a && !b && c && !d && !e && f && !g) return@map '7'\n        if(a && b && c && d && e && f && g) return@map '8'\n        '9'\n    }.joinToString(\"\").toInt()\n}"}
{"task_id": "73", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "addSandAt", "fn_name": "addSandAt", "fn_signature": "fun Grid.addSandAt(point: Point, limit: Int? = null, limitIsFloor: Boolean = false): Boolean {", "context": "import kotlin.math.absoluteValue\n\nclass Point(\n    val x: Int,\n    val y: Int\n) {\n    enum class Relationship {\n        HORIZONTAL, VERTICAL, DIAGONAL, SKEW, EQUAL\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (super.equals(other)) {\n            return true\n        }\n        val point = other as? Point\n        return point?.x == x && point.y == y\n    }\n\n    operator fun plus(other: Point): Point {\n        return Point(other.x + x, other.y + y)\n    }\n\n    override fun hashCode(): Int {\n        return x + y.rotateLeft(Int.SIZE_BITS/2)\n    }\n\n    companion object {\n        fun fromString(str: String): Point{\n            val (x, y) = str.trim().split(',').map { it.toInt() }\n            return Point(x,y)\n        }\n\n        fun fromStringOrNull(str: String): Point? {\n            return try { fromString(str) } catch (e: Exception) { null }\n        }\n    }\n\n    fun relationshipTo(point: Point): Relationship {\n        return if (point.x == x) {\n            if (point.y == y) {\n                Relationship.EQUAL\n            } else {\n                Relationship.VERTICAL\n            }\n        } else if (point.y == y) {\n            Relationship.HORIZONTAL\n        } else if ((point.y - y).absoluteValue == (point.x - x).absoluteValue) {\n            Relationship.DIAGONAL\n        } else {\n            Relationship.SKEW\n        }\n    }\n\n    infix fun to(point: Point): List<Point> {\n        val relationship = relationshipTo(point)\n        return when (relationship) {\n            Relationship.EQUAL, Relationship.VERTICAL -> {\n                if (point.y >= y) {\n                    (y..point.y).map { Point(x, it) }\n                } else {\n                    (y downTo point.y).map { Point(x, it) }\n                }\n            }\n            Relationship.HORIZONTAL -> {\n                if (point.x >= x) {\n                    (x..point.x).map { Point(it, y) }\n                } else {\n                    (x downTo point.x).map { Point(it, y) }\n                }\n            }\n            Relationship.DIAGONAL -> {\n                val xRange =\n                    if (point.x >= x) {\n                        (x..point.x)\n                    } else {\n                        (x downTo point.x)\n                    }\n                val yRange =\n                    if (point.y >= y) {\n                        (y..point.y)\n                    } else {\n                        (y downTo point.y)\n                    }\n                (xRange zip yRange).map { (x,y) -> Point(x, y) }\n            }\n            Relationship.SKEW -> {\n                throw IllegalArgumentException(\"Points are non-linear\")\n            }\n        }\n    }\n\n    fun cardinalDirectionsFromPoint(distance: Int = 0): List<Point> {\n        return listOf(\n            Point(x-1, y),\n            Point(x+1, y),\n            Point(x, y-1),\n            Point(x, y+1),\n        )\n    }\n\n    fun manhattanDistanceTo(point: Point): Int {\n        return (point.x - x).absoluteValue + (point.y - y).absoluteValue\n    }\n    override fun toString(): String {\n        return \"Point(${x}, ${y})\"\n    }\n}\n\nclass Grid {\n    operator fun get(x: Int, y: Int): Int {\n        return grid[y]?.get(x) ?: 0\n    }\n\n    operator fun set(x: Int, y: Int, value: Int) {\n        grid.getOrPut(y) { mutableMapOf() }[x] = value\n    }\n\n    operator fun get(point: Point): Int {\n        return get(point.x, point.y)\n    }\n\n    operator fun set(point: Point, value: Int) {\n        set(point.x, point.y, value)\n    }\n\n    val grid = mutableMapOf<Int, MutableMap<Int, Int>>()\n\n    override fun toString(): String {\n        return grid.toString()\n    }\n\n    fun allPoints(): List<Pair<Pair<Int, Int>, Int>> {\n        return grid.flatMap { (y, dict) -> dict.map { (x, count) -> Pair(Pair(x,y), count) } }\n    }\n}\n\nconst val rock = 1\nconst val sand = 2\n\nval Grid.maxY: Int get() {\n    return this.grid.keys.max()\n}\n\nfun Grid.addSandAt(point: Point, limit: Int? = null, limitIsFloor: Boolean = false): Boolean {\n    /* GENERATE THIS FUNCTION */\n}\n\nfun part1(input: List<String>): Int {\n    val cave = Grid()\n    for (line in input) {\n        val points = line.split(\"->\").map { Point.fromString(it) }\n        for (ix in 1 until points.size) {\n            val (pt1, pt2) = points.subList(ix-1, ix+1)\n            (pt1 to pt2).forEach { cave[it] = rock }\n        }\n    }\n\n    var count = 0\n    val limit = cave.maxY\n    while (cave.addSandAt(Point(500,0),limit)) ++count\n\n    return count\n}\n\nfun part2(input: List<String>): Int {\n    val cave = Grid()\n    for (line in input) {\n        val points = line.split(\"->\").map { Point.fromString(it) }\n        for (ix in 1 until points.size) {\n            val (pt1, pt2) = points.subList(ix-1, ix+1)\n            (pt1 to pt2).forEach { cave[it] = rock }\n        }\n    }\n\n    var count = 0\n    val limit = cave.maxY + 2\n    while (cave.addSandAt(Point(500,0), limit, true)) ++count\n\n    return count\n}", "test": "fun main() {\n    val testInput = listOf(\n        \"498,4 -> 498,6 -> 496,6\\n\",\n        \"503,4 -> 502,4 -> 502,9 -> 494,9\\n\",\n    )\n\n    fun assertEquals(actual: Any?, expected: Any?) {\n        if (actual != expected) {\n            throw IllegalStateException(\"Test failed: expected=$expected, actual=$actual\")\n        }\n    }\n\n    assertEquals(part1(testInput), 24)\n    assertEquals(part2(testInput), 93)\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Simulates dropping a unit of sand from a starting point into the grid until it settles or falls out.\n *\n * The function checks if the starting cell is empty, then iteratively attempts to move the sand downward.\n * At each step, it first tries to fall straight down, then diagonally down-left, then diagonally down-right.\n * If no further movement is possible, the sand settles at the current location. If a `limit` is given, it\n * constrains the vertical search space. When `limitIsFloor` is true, sand will settle at the limit row even\n * if no blocking cell exists beneath it.\n *\n * @param point the initial position where sand is dropped.\n * @param limit optional maximum Y boundary; defaults to the grid's maximum Y.\n * @param limitIsFloor if true, treats the `limit` row as a floor where sand can settle.\n * @return true if the sand settles in the grid, false if it cannot be placed.\n */", "canonical_solution": "fun Grid.addSandAt(point: Point, limit: Int? = null, limitIsFloor: Boolean = false): Boolean {\n    if (this[point] != 0) return false\n    var x = point.x\n    var lastY = (limit ?: maxY) - 1\n    for (y in (point.y..lastY)) {\n        val nextY = y + 1\n        if (this[x,nextY] == 0) continue\n        if (this[x-1,nextY] == 0) {\n            x=x-1\n            continue\n        }\n        if (this[x+1,nextY] == 0){\n            x=x+1\n            continue\n        }\n        this[x,y] = sand\n        return true\n    }\n\n    if (limitIsFloor) {\n        this[x,lastY] = sand\n        return true\n    }\n    return false\n}"}
{"task_id": "84", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "getValue", "fn_name": "getValue", "fn_signature": "private fun getValue(N: Int, i: Int): Pair<Int, Int> {", "context": "/**\n * 1006.笨阶乘 https://leetcode-cn.com/problems/clumsy-factorial/\n *\n * 解：以N=10为例，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n *                            = (10 * 9 / 8) + (7) + (-6 * 5 / 4) + (3) + (-2 * 1)\n * 以每个括号内的值为单位，不停累加即可得出最终值\n */\nfun clumsy(N: Int): Int {\n    require(N >= 0)\n    var result = 0\n    var i = 0\n    while (i < N) {\n        val pair = getValue(N, i)\n        result += pair.first\n        i = pair.second\n    }\n    return result\n}\n\nprivate fun getValue(N: Int, i: Int): Pair<Int, Int> {\n    /* GENERATE THIS FUNCTION */\n}", "test": "fun main() {\n    check(clumsy(0) == 0) { \"clumsy(0) should be 0\" }\n    check(clumsy(1) == 1) { \"clumsy(1) should be 1\" }\n    check(clumsy(2) == 2) { \"clumsy(2) should be 2\" }\n    check(clumsy(3) == 6) { \"clumsy(3) should be 6\" }\n    check(clumsy(4) == 7) { \"clumsy(4) should be 7\" }\n    check(clumsy(10) == 12) { \"clumsy(10) should be 12\" }\n    println(\"All tests passed!\")\n}", "description": "/**\n * Computes a partial term of the clumsy factorial expression starting at position i.\n *\n * Depending on the modulo of i by 4, this function applies multiplication, division,\n * and sign adjustment rules to generate the correct segment value and the next index\n * to continue from. Special handling is applied for the first segment (i == 0).\n *\n * @param N the number for which the clumsy factorial is being computed.\n * @param i the current position offset within the sequence of operations.\n * @return a pair where the first element is the computed segment value (possibly signed)\n *         and the second element is the next index offset to continue iteration from.\n */", "canonical_solution": "private fun getValue(N: Int, i: Int): Pair<Int, Int> {\n    require(i >= 0)\n    var value = N - i\n    if (i % 4 == 3) return value to i + 1\n    check(i % 4 == 0)\n    if (i < N - 1) {\n        value *= N - i - 1\n        if (i < N - 2) {\n            value /= N - i - 2\n        }\n    }\n    return if (i == 0) {\n        value to 3\n    } else {\n        value * -1 to i + 3\n    }\n}"}
{"task_id": "62", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "allNumbers", "fn_name": "allNumbers", "fn_signature": "fun allNumbers(): List<Pair<Int, List<Point>>> {", "context": "import kotlin.math.sign\n\ndata class Point(val x: Int, val y: Int) {\n    val neighbours: Set<Point>\n        get() = listOf(\n            Point(-1, -1), Point(0, -1), Point(1, -1),\n            Point(-1, 0), /*  this   */  Point(1, 0),\n            Point(-1, 1), Point(0, 1), Point(1, 1),\n        ).map { vector -> this + vector }\n            .toSet()\n\n    val orthogonalNeighbours: Set<Point>\n        get() = listOf(\n            Point(0, -1),\n            Point(-1, 0), Point(1, 0),\n            Point(0, 1),\n        ).map { vector -> this + vector }\n            .toSet()\n\n    val diagonalNeighbours: Set<Point>\n        get() = listOf(\n            Point(-1, -1), Point(1, -1),\n            Point(-1, 1), Point(1, 1),\n        ).map { vector -> this + vector }\n            .toSet()\n\n    fun isDiagonalTo(other: Point): Boolean = this in other.diagonalNeighbours\n\n    operator fun plus(vector: Point) = Point(x + vector.x, this.y + vector.y)\n    operator fun times(multiplier: Int) = Point(x = x * multiplier, y = y * multiplier)\n    operator fun rangeTo(other: Point): Set<Point> {\n        var cur = this\n        val points = mutableSetOf(cur)\n        while (cur != other) {\n            cur += cur.determineVectorTo(other)\n            points.add(cur)\n        }\n        return points\n    }\n    infix fun until(other: Point) = (this..other) - other\n\n    private fun determineVectorTo(other: Point): Point {\n        return if (this.x == other.x) Point(0, (other.y - this.y).sign)\n        else if (this.y == other.y) Point((other.x - this.x).sign, 0)\n        else Point((other.x - this.x).sign, (other.y - this.y).sign)\n    }\n\n    fun searchRight(pointPredicate: (Point) -> Boolean) : Point? =\n        if (pointPredicate(this + Point(1,0))) { this + Point(1,0) }\n        else null\n\n    companion object {\n        fun at(x:Int, y: Int) = Point(x,y)\n    }\n}\n\nfun String.parse() =\n    Schematic(lines().flatMapIndexed { y, line ->\n        line.mapIndexed { x, char ->\n            Point(x, y) to char\n        }\n    }.toMap())\ntypealias Gear = Pair<Point, Set<Int>>\n\nval Gear.ratio get() = this.second.map { it.toLong() }.reduce(Long::times)\n\nclass Schematic(private val points: Map<Point, Char>) {\n\n    fun allGears(): List<Gear> {\n        val numbersNextToAsterisks = allNumbersAdjacentToSymbol('*').toMap()\n        val allAsterisks = points.filterValues { it == '*' }.keys\n        return allAsterisks.map { asterisk ->\n            asterisk to numbersNextToAsterisks.filterValues { points -> points.any { point -> point in asterisk.neighbours } }.keys\n        }.filter { (_,numbers) -> numbers.size == 2 }\n    }\n\n    fun allNumbersAdjacentToSymbol(symbol: Char? = null): List<Pair<Int, List<Point>>> =\n        allNumbers().filter { (_, points) ->\n            points.any { point -> point.isAdjacentToASymbol(symbol) }\n        }\n\n    private fun Point.isAdjacentToASymbol(symbol: Char? = null) =\n        neighbours.any { neighbour ->\n            neighbour in this@Schematic.points.filterValues {\n                if (symbol == null) !it.isDigit() && it != '.'\n                else it == symbol\n            }.keys\n        }\n\n    fun allNumbers(): List<Pair<Int, List<Point>>> {\n        /* GENERATE THIS FUNCTION */\n    }\n}\n\nfun solve(string: String) = string.parse().allNumbersAdjacentToSymbol().sumOf { (n, _) -> n }\nfun solve2(string: String) = string.parse().allGears().sumOf { it.ratio }", "test": "// --- Inputs ---\nval exampleInput = \"\"\"\n    467..114..\n    ...*......\n    ..35..633.\n    ......#...\n    617*......\n    .....+.58.\n    ..592.....\n    ......755.\n    ...$.*....\n    .664.598..\n\"\"\".trimIndent()\n\nval actualInput = \"\"\"\n    .854...........................................................................362...........271...732........838.........24................\n    ...*.............................117*...........459........767*648....#.........*...................................$...&..=................\n    ....970.........368.124.+............57................653...........723.....366....*443..60.........536....441....45..879.....789...*......\n    ...........749*...-...+..330.....................215%...*................725.....953........%.................*............639......331.419.\n    .......706.....59.............*....=...262.............678...........857.*............189....................912.+589.846*...*..............\n    ..........*................393.59..418....*................151...........594...........*....584*258.......................17.997............\n    .......774....275........................777........841..............988.........121....908.........86.....482..295....................@....\n    .110..........%.....605..@.......305*18...............*....740.............840..*................52*.......*...........100...........250....\n    ...........*..............856..............412.........761....*....344....*.....505.....................121......709...-....-...............\n    ......980.269..189+............701..............22...$........343..*...684..............-375......223........97.*..........890......443.....\n    ..904*..................555.....*.......38.....*....207............773.......................824.....*.......*..../....618..................\n    ....................355*........362....*......442.$..........613...........%770.......526.....*.......418.....283..76....*....862...........\n    ...450....*292..............735.....149...........143..........*...458...........279.........43..769...................$..48.....*..........\n    ....*..413.........983*....*.................679.......642....214...#........107*......=.........*.....%...........276.39......196.889*624..\n    ...128.................658.515...890#...................../...........................60..../....528..359.....451...*.....56................\n    ...................719...................525.................$502............284-........@...489.................#..287.....@....+..........\n    ...849...............*................../.........................282.+649...............217............240.....................833.....930.\n    .......666...179.....986.526................./927......73.....176*...............@...459...........=946..*..488...126.....*.................\n    ..........@.....*549.....@...261.....370*951...........+.............114......170.......@...............269............471.891.$859.........\n    .............................../.................646.....-.327........*..237..............452......../......*620..713...............324.....\n    ..................=716.....753....................-....431..=.......692.%.......210.......*.......860....208...............81*655....$......\n    ......298....17*..........+....................................................*..........603................950.218.$......................\n    ................692...54......+778.809........140..*.........249............%.332..............*.........372*......*.328.....=..............\n    .......421.............#..............+........*....493.......*..........589..................286...............254..........458...672...258\n    ........*.....949.630.....725...609.........408.............108..............304.517......829.........666*..........724.182...........*.=...\n    .........435./....*..........*.*................580..................@.........*..&..147.-......221*......544..662/....*...........881......\n    ..750.............561......568.487.@...935.......*....106...........104......808.......*............333...................&900..............\n    ...................................287.$......930.....&.....*528.........332............755..................840../.............583.....209.\n    .371.299.................503.............................632................*.......&...................500........647..193.......-.........\n    ....*........-902..2.123..*...912.......775......./...............241........734....90.968.513..66.566...................*..&...............\n    ..................*....@.923...*.......*.....289..47.....785..710.......54................*......*....................767....452....=....597\n    .............348.362............607.....889.....#........*....*........*......$904................694...............................241.....\n    ....955........*.....559*792............................307..25.........449..............*751.404.....134.....841...........................\n    ......&.959...300............446.504.644....692...............................#.................-.....*.......*...758*35....................\n    .908$...*...........&..861...........=.....%....240............-..+..9.514...615.....&....-646.....538...144.751...........899.........545..\n    .......806.270*....946.@...............*..........*.555@....803..322.-............410..........514.................510..10..*.....858..-....\n    ...............373....................7.918.....699.........................710.......&...........-.....78%............+....34..............\n    ....653...............................................553.......896.......-......&...721....970.............................................\n    .......%...........379..377.....770@.................$.....126....*...712.287....951.........*......984*..........+.............+700........\n    ..............924...*....*.............422...................*...233.*........................124...........902....181......................\n    ................&....156..363.....*855....*.................884......509..879..755.......$...........*635......*........283.........661.....\n    ..559..........................393.........766...789.............683..................461..#......910.........904.........$.%......*.....13.\n    .........=...568.........680/.......................*......*522.#..........................747...........*113................702...952......\n    ....*....334...*...392..........910*...............233..189.........219.879............225......521...941...................................\n    .146.981......284.*.......*972......391.....789*...................................628*.....*....*................675.......................\n    ..................921..151......................983...............582......983.690.......213.137.268.............*..............24$.........\n    ....561....................600........106-...............226..................*.....996.............................681.....768.......852...\n    ..............................%............................$................=...963..$.....@............421*305.......*.....*........$......\n    .....923.285*.....961...........*......$812......812..851.............678.29.......*......501.....228..............385...853...........251..\n    .444*...............*...998...99.711.............+.....*......330.....*.........287...........781..+..........%445..........................\n    ......$....250=.....965...*.............................113...$......766....$.......941........-......658.............894........351........\n    ......335...............463.328*.....411....%.............................981.113......*5.............*...773=.573&....*............$.......\n    ..........%348..................460.....*5..517.......583.261.....889@.......................953.....496...............547............620...\n    ...299.................367.......................+....*................852.442.796.........*.@...............=................834.....*.....\n    ....*....772...487.......................#......938.462.956..41.643...*.....#.....*592....66...809.368..3..549........................772...\n    .566........*.....*320.....498..775.230.193....................*......961.........................*....*.......%283.....406.......495.......\n    ........292..585..............*.*.....*..........213...*309...................469..549......413........903................*....29..*........\n    .........*.......@.........551..806...489......................51.655.999*.......*.$.............21*.................300..931....*..595.....\n    ......878......62../...........................871......169..=..&..*......235..788...497..........................68....*.......191.........\n    .144.........+.....31............-...............*..623*....428.....955...............*.............424....89....*......728.............*665\n    .............447...............530...203...955.336..........................227........665.......$.........*.....669..............473.......\n    835...................*323..............*./...........=.....24..........*.........................452.......9.............263.........570...\n    ......568...803@.....................152.......209.933.....*....877..667.895............548...963......................................*....\n    .......$.........=............................*...........948..-...................171.*........*.605.765..-........90..............992.....\n    ..360..........#.476...........................564../.............755*...............+..709...11.....*......909..........696..124%..........\n    ........74...73................320.........658......739...=...........484...860*....................................314.....................\n    ...=509...*.........79.290........*...222...*.............46...940..............960.....473.....320..........$681......*591..269....../.....\n    ........887.94@......*..*.........302...+.784.554+............+......#......455........./............891..........457........*...609.120....\n    ....................874.246.....................................+.....228..*....&.........272....%..$.....*377.....*..52..604....%..........\n    .....44.....870*457................905.45......58...............956.........935.551...807..$.....21....356.......317....................%...\n    .........=...................267......*...300=.........543..............398..............#.................$.......................386...745\n    ..........145......+............................*......*...........7....$.............64...........646....675..1..930..770.....791.$........\n    ................744....462......443&......*389..575..965...805....+..14.......761*578..-...#..776...*..................-........-.......822.\n    ....668.484...............*............875.................*.........*....................227...*..908.............215......*.......270.....\n    .......*......771..........318....883......881...........655.@26..130..799.......876..91......28...........699.........807...510............\n    .............-........391*.........*.......+......903..................*.....379.*....@...........713........#............*.................\n    ..........+................196..230...........411....*965..682.......873....$.....916....755....&..=.....................296......+958.983..\n    ...*.....718.......279........%...............................*.271.............@.......*......932.......621..637.843..................*....\n    ..59..........%2...........................................400...*...142.870...746......256..........865*...........%...=.....%...409...761.\n    ............@...........122*157...........394........%.444.....207...-......*.........................................434..827...*..........\n    .....266..19.....=..............624.......*........398....*................373...........418...16.....654.878*.................890..........\n    ...............487..........884....*......199.227........723......914*411...........228..........%...................872................-...\n    .....937..608.................*....306........$....................................*..................522..309.@16.....*.............765....\n    ......#....................128../.................%136....140.................773...114...........33....*....*.........615.....303..........\n    .249.....590..$...949..768.......380......%...996..............833...28...310.#...................*..338.....770...559......................\n    ...+.854.../.678..*....................646...*.........................=...&..............#.....422...................#.231...714.122.......\n    ......*...........552........................741..........+.......437........455*768..134..69..........*........519.......*........*........\n    .......976.............466......497$.............607......783........*....*.............@..............28........-.........279......394.....\n    ............%....857...*....542.........915.543..$...............979...581.66......555....................331...................281.........\n    ....715......542..#..20....@........241...*...*.........701.......$...........113...../...193..96*305........&................/...#...489...\n    219*...................................#.599...845.....*.....................$....*.........*...................$....996...240........*.....\n    ..........151.520...554.............................665..........................1.398.=450..426.....198.....326.....+..........-....129....\n    .........*...........*.................687..............588....62..........504................................................970...........\n    ..........463.....776......804............*..............*.....*..........%....90/...834.790...514...740.770.......667......................\n    ....392..................................371...184........906.56....575.............*.............*.........*......*......435.....308.......\n    ....*..........*......908..........497...........................-.........884....849............374.....620....727......&........../.......\n    .125........862.326......&........+..........497.....&811.......213.......*...........465....................64.....993.....................\n    ......................%.....288...............*...-.......617...........-..677........*.....32..........-907.+........*.....=....48.475.....\n    .........787.........400.....*.......420....884.425......*.....420...727........#27..181.....*....414..............986......114./.....#..404\n    ........*.......%...........596....=.*....................863................$................428..*......899.....................114.......\n    .595=.112.737.699................382.888..........................315...@...325..........480........115..*.........-......368...............\n    ...........*......+.@......652.*...............................&.....@..182.......219$.........945+.............844...........996....744*...\n    ..87......749..535...395..#....339..564.....813....410.........135...........330.......828...........585......................*..........870\n    ...+........................$........+..967*.........*....921......321......%................612@....*......................44..............\n    .......764...716............818..327..............578.......*...../...........941..................736..@421........762.........282.........\n    861#......*..@.......982..........*.........+...............714.................*..867.....863........................@....614....=.........\n    ........549................*....260.........91................................85.....$........*.803*895..622.$..............*.........684...\n    ............770*346.....714.652......145.........270...286..........#.......................66..........*.....337.176.813...483...223*......\n    ..........................................*..392..&.........505...957.@.........158...285......881#....497.........+...*....................\n    .........=../..../.....588........227....639............741*..........443..681..........+..153........................335...................\n    ........201.671.96......$............*.....................................*........415.......*........-.......155...........848.58&........\n    ............................922......92...........180..........................&39...%....208..389......696.....*............=.......883.852\n    ....237.........950.........*............80..............................................*....................657.......................*...\n    ....../..611.......*.....671...443...971.&....366....381...442....458...$.......589.343.397.....463.......60.......&........125......&......\n    ..853...../..945..564...........*......*.......@......-................783..........*.......................*.......28......=.........373...\n    ................*.......+843..550..998.973.........+.....208.565..@..............231......292............+.365..172............+............\n    ......117......615..................*............299............&..862.895............/86...*....114..552........*...697.....733...388......\n    .....................................212..261........885...............*...903..26*..........50.....-..........158................*.........\n    ...../........11..360....748......................67....*272.....320...16.....*....137.905......239......470......................433.......\n    ...141........*.....%......+......967........-...%...........243...*.......904............*....*..............88.377......619...............\n    ................=.....-668....%.....=.+461..525.....662.....*......196..28..............778...940..400..682...*...*.........*..638*.........\n    779#..113........209...........744....................*...144..811....../...#......................-...*.....297..713.....50................\n    .........$................#.........844...6...........62.......*.............957...&.......112@.......211.............173....989............\n    ..749.......$......989..931................*....&............424.........709.......867............590...................*.......*..645......\n    ...*..290...573......*............437....227.....53......132............#....471%.............501..%..................733.....270.....=.....\n    ..637...*............596............................=....*.......400...............*...........*....................................#.......\n    ......958.....757%.........=.........228......624...746.81../.....*........../..718.198..38...184..............*820..774......./830.693.....\n    .........................453...405.=...=....................100.144.......728...........*...................498............$................\n    ..616............................*.756...310.........#52.............130.......=........506.....509.779..........723.......182..+...........\n    ...*....49.....-..............551..........*................789./.....*......306...613........./......*..491....*...............791..931....\n    ...863.....%.72......832.653........*490....814.....984.....=...741...568..........*.................998........567........+........#.......\n    .........171..........*..-.......406...............*....389.....................486.....630............../...............457.576............\n    ..............308..515..................373@......709..&..............*185..................689..........751........44..........*764........\n    ..............*..............661....=.........*.............993....984.....*.......908......=...273............../.*........................\n    .......582..335...260....59......998../.....39.760.313*174...*..........@.183......................*47....&994.887.577........*464.....22...\n    ......*...............................449..................802........762.....522..139+..154..266$......................46.323.....712*.....\n    ....827.....................................35......600*29.....724........488............*...............149*227.........*..................\n    ........@......278*............@..135..........594.........470*...........*....540*.......42..............................775.536..790......\n    .....990...........742......181....*..............*..@521................743.......552............310...*....+738.....................*.....\n    .......................125.......311............715........263...........................................173...................235....291...\n\"\"\".trimIndent()\n\n\nfun main() {\n    fun assertEquals(actual: Any?, expected: Any?) {\n        if (actual != expected) {\n            throw AssertionError(\"Expected <$expected> but got <$actual>\")\n        }\n    }\n\n    fun assertTrue(condition: Boolean, message: String = \"Assertion failed\") {\n        if (!condition) throw AssertionError(message)\n    }\n\n    fun <T> assertContainsExactlyInAnyOrder(actual: Collection<T>, expected: Collection<T>) {\n        val actualSet = actual.toSet()\n        val expectedSet = expected.toSet()\n        if (actualSet != expectedSet) {\n            throw AssertionError(\"Expected elements $expectedSet but got $actualSet\")\n        }\n        if (actual.size != expected.size) {\n            throw AssertionError(\"Expected ${expected.size} elements but got ${actual.size}\")\n        }\n    }\n\n    // --- solve part 1 ---\n    assertEquals(solve(exampleInput), 4361)\n    if (actualInput.isNotEmpty()) {\n        assertEquals(solve(actualInput), 553825)\n    }\n\n    // --- solve part 2 ---\n    assertEquals(solve2(exampleInput), 467835L)\n    if (actualInput.isNotEmpty()) {\n        assertEquals(solve2(actualInput), 49062287L)\n    }\n\n    // --- schematic's allNumbers ---\n    run {\n        val schematic = exampleInput.parse()\n        val numbers = schematic.allNumbers().map { it.first }\n        assertContainsExactlyInAnyOrder(\n            numbers,\n            listOf(467, 35, 633, 617, 592, 755, 664, 598, 114, 58)\n        )\n    }\n\n    // --- schematic's allNumbers adjacent to a symbol ---\n    run {\n        val schematic = exampleInput.parse()\n        val numbers = schematic.allNumbersAdjacentToSymbol().map { it.first }\n        assertContainsExactlyInAnyOrder(\n            numbers,\n            listOf(467, 35, 633, 617, 592, 755, 664, 598)\n        )\n    }\n\n    // --- schematic's gears ---\n    run {\n        val schematic = exampleInput.parse()\n        val allGears = schematic.allGears()\n        assertContainsExactlyInAnyOrder(\n            allGears,\n            listOf(\n                Point(3, 1) to setOf(467, 35),\n                Point(5, 8) to setOf(755, 598)\n            )\n        )\n        assertContainsExactlyInAnyOrder(\n            allGears.map { it.ratio },\n            listOf(16345L, 451490L)\n        )\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Extracts all contiguous numeric sequences from the schematic grid.\n *\n * Iterates row by row through the grid, detecting digits that have not\n * yet been grouped into a number. For each starting digit, it follows\n * rightward neighbours as long as they are digits, building the full\n * number string and collecting the corresponding grid points. Each\n * discovered number is stored along with the list of points that form\n * it. Numbers are not revisited once included in a sequence.\n *\n * @return a list of pairs, where each pair contains the integer value\n *         of the number found and the ordered list of points that make\n *         up its digits in the grid.\n */", "canonical_solution": "fun allNumbers(): List<Pair<Int, List<Point>>> {\n    val maxX = points.maxOf { (k, _) -> k.x }\n    val maxY = points.maxOf { (k, _) -> k.y }\n    val numbers = mutableListOf<Pair<Int, List<Point>>>()\n\n    (0..maxY).forEach { y ->\n        (0..maxX).forEach { x ->\n            val point = Point(x, y)\n            if (point !in numbers.flatMap { it.second } && points[point]?.isDigit() == true) {\n                var curNumber = \"${points[point]}\"\n                val curPoints = mutableListOf(point)\n                var curPoint = point\n                while (curPoint.searchRight { p -> points[p]?.isDigit() == true } != null) {\n                    val rightNeighbour = curPoint.searchRight { p -> points[p]?.isDigit() == true }\n                    curNumber += \"${points[rightNeighbour]}\"\n                    curPoints += rightNeighbour!!\n                    curPoint = rightNeighbour!!\n                }\n                numbers += curNumber.toInt() to curPoints\n            }\n        }\n    }\n    return numbers\n}"}
{"task_id": "46", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "searchWord", "fn_name": "searchWord", "fn_signature": "private fun searchWord(word: String, index: Int): Boolean {", "context": "/**\n * Design a data structure that supports adding new words and finding if a string matches any previously added string.\n * Your data structure should implement two methods\n * * `addWord(word)`- Adds word to the data structure\n * * `searchWorld(word)`- Returns true if there is any string in the data structure that matches word. Word may contain dots where a dot can be matched with any letter (a dot represents a wildcard).\n */\nclass Trie {\n    var value: Char? = null\n\n    private val trieMap: MutableMap<Char, Trie> = mutableMapOf()\n\n    fun addWord(word: String, index: Int = 0) {\n        val letter = word.getOrNull(index) ?: return\n        if (letter !in trieMap) {\n            val newTrie = Trie()\n            trieMap[letter] = newTrie\n            newTrie.value = letter\n            newTrie.addWord(word, index + 1)\n        } else {\n            val trie = trieMap[letter]!!\n            trie.addWord(word, index + 1)\n        }\n    }\n\n    override fun toString(): String {\n        return \"Trie($value, ${trieMap.values})\"\n    }\n\n    private fun depthFirstTraversal(trie: Trie, current: String, word: MutableList<String>) {\n        if (trie.trieMap.isEmpty()) {\n            word.add(current)\n        }\n        trie.trieMap.forEach { (k, v) ->\n            depthFirstTraversal(v, current + k, word)\n        }\n    }\n\n    fun searchWord(word: String, index: Int = 0): Boolean {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    fun branches(): List<String> {\n        val words = mutableListOf<String>()\n        depthFirstTraversal(this, \"\", words)\n        println(words)\n        return words\n    }\n}", "test": "fun main() {\n    fun assertTrue(condition: Boolean, message: String = \"Expected true but got false\") {\n        if (!condition) throw Error(message)\n    }\n\n    fun assertFalse(condition: Boolean, message: String = \"Expected false but got true\") {\n        if (condition) throw Error(message)\n    }\n\n    run {\n        val trie = Trie()\n        trie.addWord(\"hello\")\n        trie.addWord(\"word\")\n        trie.addWord(\"woke\")\n        trie.addWord(\"world\")\n\n        assertTrue(trie.searchWord(\"hello\"), \"Failed: hello should exist\")\n        assertTrue(trie.searchWord(\"word\"), \"Failed: word should exist\")\n        assertFalse(trie.searchWord(\"worry\"), \"Failed: worry should not exist\")\n        assertTrue(trie.searchWord(\"wo.d\"), \"Failed: wo.d should match woke/word/world\")\n        assertTrue(trie.searchWord(\"wor.d\"), \"Failed: wor.d should match world\")\n\n        trie.addWord(\"wore\")\n        trie.addWord(\"wop\")\n        trie.addWord(\"won\")\n        trie.addWord(\"worst\")\n\n        assertTrue(trie.searchWord(\"wor.t\"), \"Failed: wor.t should match worst\")\n        assertFalse(trie.searchWord(\"wor.ts\"), \"Failed: wor.ts should not exist\")\n        assertFalse(trie.searchWord(\"worm\"), \"Failed: worm should not exist before add\")\n        trie.addWord(\"worm\")\n        assertTrue(trie.searchWord(\"worm\"), \"Failed: worm should exist after add\")\n        assertTrue(trie.searchWord(\"w.rm\"), \"Failed: w.rm should match worm\")\n        assertTrue(trie.searchWord(\"w..m\"), \"Failed: w..m should match worm\")\n        assertTrue(trie.searchWord(\"...m\"), \"Failed: ...m should match worm\")\n        assertFalse(trie.searchWord(\"...ms\"), \"Failed: ...ms should not exist\")\n        assertTrue(trie.searchWord(\"w...\"), \"Failed: w... should match wore/worm/won/etc\")\n    }\n\n    run {\n        val trie = Trie()\n        trie.addWord(\"egg\")\n        trie.addWord(\"eggplant\")\n        trie.addWord(\"eggshell\")\n        trie.addWord(\"elephant\")\n        trie.addWord(\"eleanor\")\n        trie.addWord(\"eleven\")\n        trie.addWord(\"elegant\")\n        trie.addWord(\"evil\")\n\n        assertTrue(trie.searchWord(\"egg\"), \"Failed: egg should exist\")\n        assertTrue(trie.searchWord(\"eg.\"), \"Failed: eg. should match egg\")\n        assertTrue(trie.searchWord(\"eg.p.a.t\"), \"Failed: eg.p.a.t should match eggplant\")\n        assertTrue(trie.searchWord(\"elep.a.t\"), \"Failed: elep.a.t should match elephant\")\n        assertFalse(trie.searchWord(\"elope\"), \"Failed: elope should not exist\")\n        assertFalse(trie.searchWord(\"el.phat\"), \"Failed: el.phat should not exist\")\n        assertFalse(trie.searchWord(\"elev.ns\"), \"Failed: elev.ns should not exist\")\n        assertFalse(trie.searchWord(\"elevens\"), \"Failed: elevens should not exist\")\n        assertFalse(trie.searchWord(\"eleventh\"), \"Failed: eleventh should not exist\")\n        assertFalse(trie.searchWord(\"eleven.\"), \"Failed: eleven. should not exist\")\n\n        trie.addWord(\"watch\")\n        trie.addWord(\"witch\")\n        trie.addWord(\"with\")\n        trie.addWord(\"without\")\n        trie.addWord(\"withe\")\n        trie.addWord(\"wither\")\n        trie.addWord(\"wit\")\n        trie.addWord(\"withering\")\n        trie.branches()\n    }\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Recursively searches the trie for a word starting at a given index.\n *\n * Matches the current character of the word with the corresponding child node in the trie. \n * If the character is a dot (`.`), it is treated as a wildcard and the function attempts \n * to continue searching down all child branches. The recursion continues until the end of \n * the word is reached or no valid path is found.\n *\n * @param word the string to search for, which may contain wildcard dots ('.')\n * @param index the current position in the word being processed\n * @return true if the word matches any branch in the trie, false otherwise\n */", "canonical_solution": "fun searchWord(word: String, index: Int = 0): Boolean {\n    val letter = word.getOrNull(index) ?: return true\n    if (letter == '.') { // wildcard\n        // Ignore this and try to find any other node that matches next character\n        return trieMap.values.map {\n            it.searchWord(word, index + 1)\n        }.any { it }\n    } else {\n        val nextTrie = trieMap[letter] ?: return false\n        return nextTrie.searchWord(word, index + 1)\n    }\n}"}
{"task_id": "49", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "toposort", "fn_name": "toposort", "fn_signature": "private fun toposort(k: Int, matrix: Array<IntArray>): List<Int> {", "context": "// #Hard #Array #Matrix #Graph #Topological_Sort\n// #2023_07_02_Time_706_ms_(100.00%)_Space_65.8_MB_(100.00%)\n\nimport java.util.LinkedList\nimport java.util.Queue\n\nclass Solution {\n    // Using topological sort to solve this problem\n    fun buildMatrix(k: Int, rowConditions: Array<IntArray>, colConditions: Array<IntArray>): Array<IntArray> {\n        // First, get the topo-sorted of row and col\n        val row = toposort(k, rowConditions)\n        val col = toposort(k, colConditions)\n        // base case: when the length of row or col is less than k, return empty.\n        // That is: there is a loop in established graph\n        if (row.size < k || col.size < k) {\n            return Array(0) { IntArray(0) }\n        }\n        val res = Array(k) { IntArray(k) }\n        val map: MutableMap<Int, Int> = HashMap()\n        for (i in 0 until k) {\n            // we record the number corresbonding to each column:\n            // [number, column index]\n            map[col[i]] = i\n        }\n        // col: 3 2 1\n        // row: 1 3 2\n        for (i in 0 until k) {\n            // For each row: we have number row.get(i). And we need to know\n            // which column we need to assign, which is from map.get(row.get(i))\n            // known by map.get()\n            res[i][map[row[i]]!!] = row[i]\n        }\n        return res\n    }\n\n    private fun toposort(k: Int, matrix: Array<IntArray>): List<Int> {\n        /* GENERATE THIS FUNCTION */\n    }\n}", "test": "fun main() {\n    fun arraysEqual(a: Array<IntArray>, b: Array<IntArray>): Boolean {\n        if (a.size != b.size) return false\n        for (i in a.indices) {\n            if (!a[i].contentEquals(b[i])) return false\n        }\n        return true\n    }\n\n    fun assertEquals(actual: Array<IntArray>, expected: Array<IntArray>) {\n        if (!arraysEqual(actual, expected)) {\n            val actualStr = actual.joinToString(prefix = \"[\", postfix = \"]\") { it.joinToString(prefix = \"[\", postfix = \"]\") }\n            val expectedStr = expected.joinToString(prefix = \"[\", postfix = \"]\") { it.joinToString(prefix = \"[\", postfix = \"]\") }\n            throw IllegalStateException(\"Assertion failed!\\nExpected: $expectedStr\\nActual:   $actualStr\")\n        }\n    }\n\n    // Test 1\n    run {\n        val result = Solution().buildMatrix(\n            3,\n            arrayOf(intArrayOf(1, 2), intArrayOf(3, 2)),\n            arrayOf(intArrayOf(2, 1), intArrayOf(3, 2)),\n        )\n        val expected = arrayOf(\n            intArrayOf(0, 0, 1),\n            intArrayOf(3, 0, 0),\n            intArrayOf(0, 2, 0),\n        )\n        assertEquals(result, expected)\n    }\n\n    // Test 2\n    run {\n        val result = Solution().buildMatrix(\n            3,\n            arrayOf(intArrayOf(1, 2), intArrayOf(2, 3), intArrayOf(3, 1), intArrayOf(2, 3)),\n            arrayOf(intArrayOf(2, 1)),\n        )\n        val expected = arrayOf<IntArray>() // empty\n        assertEquals(result, expected)\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Performs a topological sort on a directed graph of size `k`.\n *\n * Builds a graph from dependency pairs in `matrix`, computes in-degrees,\n * and applies BFS (Kahn's algorithm) to generate a valid topological order.\n * If a cycle exists, the resulting list will have fewer than `k` elements.\n *\n * @param k the number of nodes in the graph, labeled from 1 to k.\n * @param matrix an array of edges where each element is a pair [from, to],\n *               representing a directed edge from `from` to `to`.\n * @return a list of nodes in topologically sorted order; may be shorter than k if cycles are present.\n */", "canonical_solution": "private fun toposort(k: Int, matrix: Array<IntArray>): List<Int> {\n    val deg = IntArray(k + 1)\n    val res: MutableList<Int> = ArrayList()\n    val graph: MutableList<MutableList<Int>> = ArrayList()\n    for (i in 0 until k) {\n        graph.add(ArrayList())\n    }\n    val queue: Queue<Int> = LinkedList()\n    for (a in matrix) {\n        val from = a[0]\n        val to = a[1]\n        graph[from - 1].add(to)\n        deg[to]++\n    }\n    for (i in 1..k) {\n        if (deg[i] == 0) {\n            queue.offer(i)\n            res.add(i)\n        }\n    }\n    while (queue.isNotEmpty()) {\n        val node = queue.poll()\n        val list: List<Int> = graph[node - 1]\n        for (i in list) {\n            if (--deg[i] == 0) {\n                queue.offer(i)\n                res.add(i)\n            }\n        }\n    }\n    return res\n}"}
{"task_id": "95", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "typeForHand", "fn_name": "typeForHand", "fn_signature": "fun typeForHand(cards: String): HandTypes {", "context": "enum class HandTypes {\n    FIVE_KIND, FOUR_KIND, FULL_HOUSE, THREE_KIND, TWO_PAIR, ONE_PAIR, HIGH_CARD\n}\n\nval scores = \"23456789TJQKA\".mapIndexed { index, c -> c to index }.toMap()\nval jScore = scores['J']!!\n\nfun typeForHand(cards: String): HandTypes {\n    /* GENERATE THIS FUNCTION */\n}\n\nfun wildTypeForHand(cards: String): HandTypes {\n    val counts = cards.groupingBy { it }.eachCount()\n    val jCount = counts['J'] ?: 0\n    return if (jCount in 1..4) {\n        val highest = (counts - 'J').entries.maxByOrNull { it.value }!!.key\n        typeForHand(cards.replace('J', highest))\n    } else {\n        typeForHand(cards)\n    }\n}\n\nfun String.asListOfScores() = map { scores[it]!! }\nfun sortHands(a: String, b: String) = a.asListOfScores().zip(b.asListOfScores()).map { compareValues(it.first, it.second) }.first { it != 0 }\n\nclass Hand(val cards: String, val bid: Long): Comparable<Hand> {\n    val type = typeForHand(cards)\n\n    val sortScore = cards.asListOfScores()\n        .fold(0) { acc, x -> (acc * 16) + x}\n\n    override fun compareTo(other: Hand): Int = (compareByDescending<Hand> { it.type }.thenBy { it.sortScore }).compare(this, other)\n    override fun toString(): String {\n        return \"Hand(cards='$cards', bid=$bid, type=$type)\"\n    }\n}\n\nclass Hand2(val cards: String, val bid: Long): Comparable<Hand2> {\n    val type = wildTypeForHand(cards)\n\n    val sortScore = cards.asListOfScores()\n        .map { if (it == jScore) { 0 } else { it + 1 } }\n        .fold(0) { acc, x -> (acc * 16) + x}\n\n    override fun compareTo(other: Hand2): Int = (compareByDescending<Hand2> { it.type }.thenBy { it.sortScore }).compare(this, other)\n    override fun toString(): String {\n        return \"Hand(cards='$cards', bid=$bid, type=$type)\"\n    }\n}\n\nfun part1(input: List<String>): Long {\n    val hands = input.map { Hand(it.substringBefore(' '), it.substringAfter(' ').toLong()) }\n    return hands\n        .sorted()\n        .mapIndexed { index, hand -> index + 1 to hand.bid }\n        .onEach { println(it) }\n        .sumOf { it.first * it.second }\n}\n\nfun part2(input: List<String>): Long {\n    val hands = input.map { Hand2(it.substringBefore(' '), it.substringAfter(' ').toLong()) }\n    return hands\n        .sorted()\n        .mapIndexed { index, hand -> index + 1 to hand.bid }\n        .onEach { println(it) }\n        .sumOf { it.first * it.second }\n}", "test": "fun main() {\n    val testInput = \"\"\"\n    32T3K 765\n    T55J5 684\n    KK677 28\n    KTJJT 220\n    QQQJA 483\n    \"\"\".trimIndent().split(\"\\n\")\n\n    val testValue = part1(testInput)\n    println(\"part1 result: $testValue\")\n    if (testValue != 6440L) {\n        throw Error(\"part1 failed: expected 6440 but got $testValue\")\n    }\n\n    val part2Value = part2(testInput)\n    println(\"part2 result: $part2Value\")\n    if (part2Value != 5905L) {\n        throw Error(\"part2 failed: expected 5905 but got $part2Value\")\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Determines the type of poker hand represented by the given cards.\n *\n * Groups the characters in the input string to count occurrences of each rank,\n * sorts these counts in descending order, and applies poker hand classification\n * rules. The logic checks for the highest-ranking hands first (five of a kind,\n * four of a kind, full house, etc.) and falls back to lower-ranking ones until\n * identifying the correct type.\n *\n * @param cards A string of exactly 5 characters, each representing a card rank (e.g., \"AKQJT\").\n * @return The corresponding [HandTypes] enum value that best describes the hand.\n */", "canonical_solution": "fun typeForHand(cards: String): HandTypes {\n    val counts = cards.groupingBy { it }.eachCount().values.sortedDescending()\n    if (counts[0] == 5) { return HandTypes.FIVE_KIND }\n    val (c1, c2) = counts\n    return if (c1 == 4) { HandTypes.FOUR_KIND }\n    else if (c1 == 3 && c2 == 2) { HandTypes.FULL_HOUSE }\n    else if (c1 == 3) { HandTypes.THREE_KIND }\n    else if (c1 == 2 && c2 == 2) { HandTypes.TWO_PAIR }\n    else if (c1 == 2) { HandTypes.ONE_PAIR }\n    else HandTypes.HIGH_CARD\n}"}
{"task_id": "33", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "findDirectoryToDelete", "fn_name": "findDirectoryToDelete", "fn_signature": "private fun findDirectoryToDelete(size: Long, entry: FileSystemEntry): FileSystemEntry? {", "context": "import java.io.File\n\nopen class PuzzleInput<T>(val expectedResult: T? = null)\nabstract class Puzzle<T, P : PuzzleInput<T>> {\n    fun solve(input: P) {\n        val solution = solution(input)\n        if(input.expectedResult != null) {\n            if(solution != input.expectedResult) {\n                println(\"$solution == ${input.expectedResult}\")\n            }\n            check(solution == input.expectedResult)\n        }\n        else {\n            println(solution)\n        }\n    }\n\n    abstract fun solution(input: P) : T\n}\n\nclass FileSystemEntry(val name: String, val parent: FileSystemEntry? = null, private var size: Long = 0) {\n    val children = mutableListOf<FileSystemEntry>()\n    val isDir = size == 0.toLong()\n    fun getEntrySize(): Long {\n        if(size == 0.toLong() && children.isNotEmpty()) {\n            size = children.sumOf { child ->\n                child.getEntrySize()\n            }\n        }\n        return size\n    }\n}\n\nclass Day7PuzzleSolution(private val targetDirSize: Long) : Puzzle<Long, Day7PuzzleInput>() {\n    override fun solution(input: Day7PuzzleInput): Long {\n        return getTotalSizeSmallDirectories(targetDirSize, input.root)\n    }\n\n    private fun getTotalSizeSmallDirectories(size: Long, entry: FileSystemEntry): Long {\n        val sizeOfSmallChildren = entry.children.sumOf { child ->\n            getTotalSizeSmallDirectories(size, child)\n        }\n        if(entry.isDir && entry.getEntrySize() <= size) {\n            return sizeOfSmallChildren + entry.getEntrySize()\n        }\n        return sizeOfSmallChildren\n    }\n}\n\nclass Day7PuzzleSolutionList(private val targetDirSize: Long) : Puzzle<Long, Day7PuzzleInputList>() {\n    override fun solution(input: Day7PuzzleInputList): Long {\n        return input.dirQueue.sumOf {dir ->\n            if(dir.getEntrySize() <= targetDirSize) {\n                dir.getEntrySize()\n            }\n            else {\n                0\n            }\n        }\n    }\n\n}\n\nclass Day7Puzzle2Solution : Puzzle<Long, Day7PuzzleInput>() {\n    override fun solution(input: Day7PuzzleInput): Long {\n        val targetDirSize = 30000000 - (70000000 - input.root.getEntrySize())\n        val result = findDirectoryToDelete(targetDirSize, input.root)\n        return result?.getEntrySize() ?: error(\"Did not find a directory\")\n    }\n\n    private fun findDirectoryToDelete(size: Long, entry: FileSystemEntry): FileSystemEntry? {\n        /* GENERATE THIS FUNCTION */\n    }\n}\n\nclass Day7Puzzle2SolutionList : Puzzle<Long, Day7PuzzleInputList>() {\n    override fun solution(input: Day7PuzzleInputList): Long {\n        val targetDirSize = 30000000 - (70000000 - input.root.getEntrySize())\n        var currentBest = input.root\n        for (dir in input.dirQueue) {\n            if (dir.getEntrySize() < currentBest.getEntrySize() && dir.getEntrySize() > targetDirSize) {\n                currentBest = dir\n            }\n        }\n        return currentBest.getEntrySize()\n    }\n}", "test": "// Minimal replacements for Day7PuzzleInput and Day7PuzzleInputList\n// Must extend PuzzleInput<Long> to satisfy Puzzle<T, P : PuzzleInput<T>>\nclass Day7PuzzleInput(val root: FileSystemEntry) : PuzzleInput<Long>(null)\n\nclass Day7PuzzleInputList(\n    val root: FileSystemEntry,\n    val dirQueue: MutableList<FileSystemEntry>\n) : PuzzleInput<Long>(null)\n\n\nfun main() {\n    val exampleInput = \"\"\"\n        $ cd /\n        $ ls\n        dir a\n        14848514 b.txt\n        8504156 c.dat\n        dir d\n        $ cd a\n        $ ls\n        dir e\n        29116 f\n        2557 g\n        62596 h.lst\n        $ cd e\n        $ ls\n        584 i\n        $ cd ..\n        $ cd ..\n        $ cd d\n        $ ls\n        4060174 j\n        8033020 d.log\n        5626152 d.ext\n        7214296 k\n    \"\"\".trimIndent()\n\n    val realInput = \"\"\"\n        $ cd /\n        $ ls\n        187585 dgflmqwt.srm\n        dir gnpd\n        200058 hbnlqs\n        dir jsv\n        dir mfhzl\n        dir nljtr\n        dir nwzp\n        61949 qdswp.wfj\n        21980 rbq.hpj\n        dir rfwwwgr\n        dir sbnhc\n        dir zhfl\n        136762 zwg\n        $ cd gnpd\n        $ ls\n        dir dcqq\n        dir dnscfz\n        dir dwqbhgc\n        dir lsrb\n        167581 ndwfr.pbv\n        dir pbgrdvmc\n        dir sbnhc\n        144703 sct\n        dir smfhldss\n        $ cd dcqq\n        $ ls\n        dir bfdng\n        155230 mfhzl.bpw\n        dir mhpqqq\n        dir mpbpcv\n        24140 mrrznmvr.mmz\n        $ cd bfdng\n        $ ls\n        dir hjlch\n        dir sbnhc\n        $ cd hjlch\n        $ ls\n        239759 sct\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        221334 hbnlqs\n        $ cd ..\n        $ cd ..\n        $ cd mhpqqq\n        $ ls\n        250305 nfqs.crt\n        dir qqhz\n        60892 rbq.hpj\n        64587 tbzlnq\n        dir tcbgmw\n        dir vnlmlq\n        $ cd qqhz\n        $ ls\n        148009 sct\n        $ cd ..\n        $ cd tcbgmw\n        $ ls\n        85006 sbnhc\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        21720 vsrrhvlt.qbs\n        $ cd ..\n        $ cd ..\n        $ cd mpbpcv\n        $ ls\n        146794 bdpld.ddm\n        $ cd ..\n        $ cd ..\n        $ cd dnscfz\n        $ ls\n        276175 mfhzl.ndh\n        248161 qjgzgm\n        dir vnlmlq\n        dir wwf\n        dir zjdhldlq\n        $ cd vnlmlq\n        $ ls\n        130051 ftjnfc\n        $ cd ..\n        $ cd wwf\n        $ ls\n        166550 dwvphbm.jtd\n        $ cd ..\n        $ cd zjdhldlq\n        $ ls\n        345090 hbnlqs\n        $ cd ..\n        $ cd ..\n        $ cd dwqbhgc\n        $ ls\n        310228 dwvphbm\n        157686 hbnlqs\n        48014 nfqs.crt\n        333356 rwb.njl\n        dir sbnhc\n        139174 sct\n        dir vjcl\n        $ cd sbnhc\n        $ ls\n        51605 bfqw.cjd\n        267184 fjvmbpf\n        169122 mfhzl.jrp\n        243630 sbnhc\n        $ cd ..\n        $ cd vjcl\n        $ ls\n        dir mfhzl\n        $ cd mfhzl\n        $ ls\n        302243 dcqq.djc\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd lsrb\n        $ ls\n        311814 dcqq.prd\n        200118 rbq.hpj\n        $ cd ..\n        $ cd pbgrdvmc\n        $ ls\n        119324 cqhdvmzp.npw\n        277930 jhlrpmqg\n        dir jlcqmq\n        204425 pddmq\n        dir rqmhwhc\n        257084 sbnhc\n        338348 vnlmlq\n        $ cd jlcqmq\n        $ ls\n        24876 mfhzl\n        $ cd ..\n        $ cd rqmhwhc\n        $ ls\n        36575 dlft.dtp\n        $ cd ..\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        dir sbq\n        dir vmslnrmc\n        $ cd sbq\n        $ ls\n        15689 hpzgsl.svb\n        $ cd ..\n        $ cd vmslnrmc\n        $ ls\n        dir lcqpws\n        136481 nfqs.crt\n        29838 sbnhc\n        $ cd lcqpws\n        $ ls\n        168866 dcqq.pdp\n        322264 jmtwr.fzj\n        18732 sct\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd smfhldss\n        $ ls\n        dir wfbssqj\n        $ cd wfbssqj\n        $ ls\n        134050 tgghrp.hjq\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd jsv\n        $ ls\n        dir bwc\n        dir dcqq\n        260913 lzcqm.wzr\n        dir rhstw\n        dir vnlmlq\n        $ cd bwc\n        $ ls\n        221975 bdv.mfq\n        dir crbnzrtw\n        dir dcqq\n        dir gdgh\n        101246 gqcfrzmn\n        dir gsst\n        dir jwrhclh\n        dir nbwfdvsv\n        dir qnwhfv\n        dir sbnhc\n        $ cd crbnzrtw\n        $ ls\n        dir dmmpcrz\n        204859 dwvphbm.csz\n        dir jdh\n        dir mpgdhg\n        202360 nfqs.crt\n        dir sbnhc\n        302165 scpq.gpd\n        dir shfhmdw\n        dir wmjgmd\n        $ cd dmmpcrz\n        $ ls\n        dir mfhzl\n        $ cd mfhzl\n        $ ls\n        121861 hbnlqs\n        $ cd ..\n        $ cd ..\n        $ cd jdh\n        $ ls\n        dir dwvphbm\n        $ cd dwvphbm\n        $ ls\n        8977 ntdtdq\n        $ cd ..\n        $ cd ..\n        $ cd mpgdhg\n        $ ls\n        48235 dcqq\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        dir dbb\n        $ cd dbb\n        $ ls\n        275648 gcsdd.pdw\n        dir rbbgrtm\n        dir rmlm\n        111336 sbnhc.qrn\n        153146 sct\n        $ cd rbbgrtm\n        $ ls\n        304685 rbq.hpj\n        $ cd ..\n        $ cd rmlm\n        $ ls\n        dir wfr\n        $ cd wfr\n        $ ls\n        197220 dhjjr.dqq\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd shfhmdw\n        $ ls\n        221308 mhnfzmz.gqp\n        $ cd ..\n        $ cd wmjgmd\n        $ ls\n        dir psrshrws\n        dir zrtpgbg\n        $ cd psrshrws\n        $ ls\n        202052 twgfblm\n        $ cd ..\n        $ cd zrtpgbg\n        $ ls\n        48134 hsnzvhvm.gnp\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd dcqq\n        $ ls\n        63600 tlclsj.pvg\n        181384 tzjn\n        90096 wgq.lrm\n        $ cd ..\n        $ cd gdgh\n        $ ls\n        78450 hrcdgnpv.ctz\n        $ cd ..\n        $ cd gsst\n        $ ls\n        345240 nfqs.crt\n        199259 sct\n        $ cd ..\n        $ cd jwrhclh\n        $ ls\n        dir ftjcr\n        177499 nhdh.bbn\n        dir sbnhc\n        dir vnlmlq\n        dir wqjnwgpj\n        $ cd ftjcr\n        $ ls\n        dir glfptjpb\n        121761 gqp\n        36602 lcgfmtf.zct\n        dir mfhzl\n        dir rrrrgbqv\n        236133 wdmwgzvs.jnw\n        dir zwrmjlh\n        $ cd glfptjpb\n        $ ls\n        dir fdnppcr\n        dir gchhnd\n        dir gdphvds\n        98000 gqhv\n        $ cd fdnppcr\n        $ ls\n        dir dwvphbm\n        dir ngsgrgp\n        $ cd dwvphbm\n        $ ls\n        dir wrg\n        $ cd wrg\n        $ ls\n        265022 cqhdvmzp.npw\n        316916 nfqs.crt\n        $ cd ..\n        $ cd ..\n        $ cd ngsgrgp\n        $ ls\n        110198 sct\n        $ cd ..\n        $ cd ..\n        $ cd gchhnd\n        $ ls\n        253836 hbnlqs\n        39462 mfhzl\n        211458 nfqs.crt\n        $ cd ..\n        $ cd gdphvds\n        $ ls\n        dir dpdb\n        $ cd dpdb\n        $ ls\n        342610 vnlmlq\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd mfhzl\n        $ ls\n        dir cptj\n        $ cd cptj\n        $ ls\n        100729 nvctqj.gjw\n        $ cd ..\n        $ cd ..\n        $ cd rrrrgbqv\n        $ ls\n        166055 dwvphbm.rvb\n        303762 hbnlqs\n        277411 wzr.rgz\n        $ cd ..\n        $ cd zwrmjlh\n        $ ls\n        32583 dvfnw\n        $ cd ..\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        dir hwtmwp\n        334229 mfhzl\n        299303 vtrfbw.dng\n        $ cd hwtmwp\n        $ ls\n        dir zjmrr\n        $ cd zjmrr\n        $ ls\n        279103 cqhdvmzp.npw\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        dir btqsh\n        dir clhclcr\n        237487 cqhdvmzp.npw\n        11669 gqhltqf\n        91205 hbnlqs\n        dir qwbnvzv\n        234450 rqlnhpc.qfd\n        dir vbrc\n        dir vfdqq\n        $ cd btqsh\n        $ ls\n        dir lgh\n        dir ljrjpg\n        34333 rbq.hpj\n        15387 vzldp.ffs\n        $ cd lgh\n        $ ls\n        176966 vnlmlq\n        $ cd ..\n        $ cd ljrjpg\n        $ ls\n        231230 cqhdvmzp.npw\n        dir dwvphbm\n        dir mfhzl\n        251554 rdrbn.clr\n        180447 sbnhc\n        $ cd dwvphbm\n        $ ls\n        dir vghvsmq\n        $ cd vghvsmq\n        $ ls\n        132209 cqhdvmzp.npw\n        dir jqmgn\n        $ cd jqmgn\n        $ ls\n        95992 clbvg.bmr\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd mfhzl\n        $ ls\n        dir dcqq\n        $ cd dcqq\n        $ ls\n        dir vjhl\n        $ cd vjhl\n        $ ls\n        dir nbhmzl\n        $ cd nbhmzl\n        $ ls\n        155454 sbnhc.flh\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd clhclcr\n        $ ls\n        dir jwqwhq\n        268077 njcmcfl.ctm\n        $ cd jwqwhq\n        $ ls\n        256988 rbq.hpj\n        $ cd ..\n        $ cd ..\n        $ cd qwbnvzv\n        $ ls\n        167852 dln.zrn\n        dir hpwpm\n        131149 lsc.tjj\n        dir mfhzl\n        dir mzhwwrtp\n        201277 sbnhc.pfh\n        147232 zlmgttpl\n        $ cd hpwpm\n        $ ls\n        135194 jpzt.fjn\n        $ cd ..\n        $ cd mfhzl\n        $ ls\n        166015 jrcqvgf.jdg\n        $ cd ..\n        $ cd mzhwwrtp\n        $ ls\n        231983 dgrvfdmp\n        121846 dwvphbm.lvp\n        $ cd ..\n        $ cd ..\n        $ cd vbrc\n        $ ls\n        320029 wbhs.mpd\n        $ cd ..\n        $ cd vfdqq\n        $ ls\n        277998 nfqs.crt\n        dir qzgwglhc\n        dir vnlmlq\n        68520 wsc.vhz\n        dir zfdhthfn\n        $ cd qzgwglhc\n        $ ls\n        25046 cqhdvmzp.npw\n        250876 dwvphbm\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        212688 hbnlqs\n        8202 mlpl.tsp\n        69495 vnlmlq.thv\n        281200 vzdwr.tbl\n        $ cd ..\n        $ cd zfdhthfn\n        $ ls\n        233242 dstb.hrs\n        269387 nfqs.crt\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd wqjnwgpj\n        $ ls\n        dir hfd\n        dir lbft\n        dir rtlw\n        dir vbf\n        $ cd hfd\n        $ ls\n        224694 cqhdvmzp.npw\n        100103 dbmwn.tqz\n        $ cd ..\n        $ cd lbft\n        $ ls\n        60107 hbnlqs\n        $ cd ..\n        $ cd rtlw\n        $ ls\n        dir ntpb\n        $ cd ntpb\n        $ ls\n        341166 mfhzl.pvj\n        $ cd ..\n        $ cd ..\n        $ cd vbf\n        $ ls\n        54177 ghrscj.tlh\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd nbwfdvsv\n        $ ls\n        107273 mptw.qmn\n        $ cd ..\n        $ cd qnwhfv\n        $ ls\n        55633 hbnlqs\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        173163 vnlmlq\n        $ cd ..\n        $ cd ..\n        $ cd dcqq\n        $ ls\n        217679 hbnlqs\n        146747 ltp\n        $ cd ..\n        $ cd rhstw\n        $ ls\n        dir clh\n        dir grz\n        dir ntjtzr\n        dir qrjgl\n        dir rzqp\n        dir tzgrs\n        dir zrdh\n        $ cd clh\n        $ ls\n        212153 cqhdvmzp.npw\n        $ cd ..\n        $ cd grz\n        $ ls\n        346002 cqhdvmzp.npw\n        $ cd ..\n        $ cd ntjtzr\n        $ ls\n        271549 rbq.hpj\n        308693 sbnhc.zrv\n        $ cd ..\n        $ cd qrjgl\n        $ ls\n        119344 jfshwj\n        $ cd ..\n        $ cd rzqp\n        $ ls\n        327891 dcqq\n        210282 hlmnv.jph\n        118199 nfqs.crt\n        dir rwh\n        $ cd rwh\n        $ ls\n        285057 rmvrnb\n        $ cd ..\n        $ cd ..\n        $ cd tzgrs\n        $ ls\n        23830 cjqrr\n        $ cd ..\n        $ cd zrdh\n        $ ls\n        dir dcqq\n        dir dwvphbm\n        188911 rbq.hpj\n        dir vpnzs\n        $ cd dcqq\n        $ ls\n        277454 hbnlqs\n        dir jnncgzgm\n        $ cd jnncgzgm\n        $ ls\n        199664 dcqq.tgm\n        $ cd ..\n        $ cd ..\n        $ cd dwvphbm\n        $ ls\n        221700 fgnznr.dhf\n        $ cd ..\n        $ cd vpnzs\n        $ ls\n        254459 fvcf.zcj\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        dir gfsj\n        $ cd gfsj\n        $ ls\n        dir hddvr\n        $ cd hddvr\n        $ ls\n        dir mqmnzb\n        $ cd mqmnzb\n        $ ls\n        341835 jjjh\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd mfhzl\n        $ ls\n        dir pccldwf\n        $ cd pccldwf\n        $ ls\n        126977 nvcw\n        318605 rljpfnc.dzd\n        $ cd ..\n        $ cd ..\n        $ cd nljtr\n        $ ls\n        dir slztzqd\n        $ cd slztzqd\n        $ ls\n        55754 bpwghjpg.bfq\n        205753 pfplh\n        319151 vdlmjj.mmn\n        dir vnlmlq\n        $ cd vnlmlq\n        $ ls\n        dir mfhzl\n        338081 zhjrrs\n        dir zpj\n        $ cd mfhzl\n        $ ls\n        dir dcqq\n        dir lgfb\n        dir rjbprpnl\n        343125 vnlmlq.zpr\n        $ cd dcqq\n        $ ls\n        288030 rbq.hpj\n        $ cd ..\n        $ cd lgfb\n        $ ls\n        22119 cqhdvmzp.npw\n        238775 wbmnzgt.vnl\n        $ cd ..\n        $ cd rjbprpnl\n        $ ls\n        244896 lvgg.jvz\n        $ cd ..\n        $ cd ..\n        $ cd zpj\n        $ ls\n        339679 dcqq\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd nwzp\n        $ ls\n        dir mfhzl\n        dir vnlmlq\n        $ cd mfhzl\n        $ ls\n        107297 dwvphbm.nvb\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        dir mdj\n        $ cd mdj\n        $ ls\n        87553 dbtct.nws\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd rfwwwgr\n        $ ls\n        287719 flpwrp\n        74896 mfhzl\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        232949 dcqq.rnj\n        dir dwvphbm\n        $ cd dwvphbm\n        $ ls\n        21955 pcqbfbv.bfg\n        $ cd ..\n        $ cd ..\n        $ cd zhfl\n        $ ls\n        dir jvnlhq\n        dir vnlmlq\n        180619 wcd.jsr\n        $ cd jvnlhq\n        $ ls\n        20692 clp.vmd\n        dir dbn\n        91389 jqbp.zss\n        dir njmdrb\n        dir sbnhc\n        dir sdrrzp\n        192374 vnlmlq.lvj\n        $ cd dbn\n        $ ls\n        293401 dcqq\n        $ cd ..\n        $ cd njmdrb\n        $ ls\n        270463 dvzbtnbb.vth\n        dir gdvtg\n        219739 hsdg.rss\n        dir mfhzl\n        285584 mhq\n        dir mllvdccz\n        234503 nfqs.crt\n        $ cd gdvtg\n        $ ls\n        294243 dllnh\n        27407 rws.vqt\n        $ cd ..\n        $ cd mfhzl\n        $ ls\n        dir dwvphbm\n        154477 nbphv.pjc\n        dir qpnncj\n        33994 splscqn.tqz\n        dir vnlmlq\n        $ cd dwvphbm\n        $ ls\n        87960 sct\n        $ cd ..\n        $ cd qpnncj\n        $ ls\n        182692 lqbbz\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        285614 bfrjhpv.dvn\n        121146 nfqs.crt\n        84544 sbnhc\n        $ cd ..\n        $ cd ..\n        $ cd mllvdccz\n        $ ls\n        184878 bsjzsmw.pwt\n        184061 dcqq.bbm\n        243546 dwvphbm.rdw\n        dir ftmrszgl\n        8251 rbq.hpj\n        dir tgvchzn\n        $ cd ftmrszgl\n        $ ls\n        267439 bdrn.gfb\n        257447 npcrg.gjn\n        $ cd ..\n        $ cd tgvchzn\n        $ ls\n        227775 lqbftlg.scr\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        245520 tjp.pml\n        $ cd ..\n        $ cd sdrrzp\n        $ ls\n        dir dcqq\n        7894 gstzs\n        dir rnjcrjj\n        dir sbnhc\n        $ cd dcqq\n        $ ls\n        340987 sjb.nss\n        $ cd ..\n        $ cd rnjcrjj\n        $ ls\n        67782 rbq.hpj\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        156705 zwr.rtg\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        dir dwvphbm\n        dir jgc\n        dir lbh\n        dir lrwt\n        dir rhszw\n        213882 sbnhc.dzl\n        dir vnlmlq\n        2798 vwwbhsnb.dms\n        $ cd dwvphbm\n        $ ls\n        257972 zccsn.bdr\n        $ cd ..\n        $ cd jgc\n        $ ls\n        85911 cqhdvmzp.npw\n        dir fnvjv\n        49760 grsw\n        dir ntz\n        249818 rgzqq.tlr\n        $ cd fnvjv\n        $ ls\n        288935 dcqq.bsq\n        dir nwlbbwtq\n        264238 tcwwzs.zwg\n        $ cd nwlbbwtq\n        $ ls\n        dir qcm\n        318151 sbnhc.lwr\n        322077 stb.cqj\n        $ cd qcm\n        $ ls\n        147721 crrdn\n        dir gctnt\n        59476 rbq.hpj\n        dir sbnhc\n        $ cd gctnt\n        $ ls\n        328909 dwvphbm\n        82536 rjnz\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        35956 nfqs.crt\n        89464 qvhvlcl.nzq\n        dir vvn\n        $ cd vvn\n        $ ls\n        119247 fztlb.qch\n        79030 vnlmlq\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ntz\n        $ ls\n        234879 mfhzl\n        $ cd ..\n        $ cd ..\n        $ cd lbh\n        $ ls\n        dir dwvphbm\n        24310 jgsp.ggs\n        dir lft\n        $ cd dwvphbm\n        $ ls\n        295434 rbq.hpj\n        $ cd ..\n        $ cd lft\n        $ ls\n        dir dcqq\n        dir dwvphbm\n        123657 mfhzl.nhq\n        $ cd dcqq\n        $ ls\n        dir tgp\n        $ cd tgp\n        $ ls\n        271647 gmmq.tmp\n        $ cd ..\n        $ cd ..\n        $ cd dwvphbm\n        $ ls\n        dir pftcdtd\n        108321 qtqhqwnt\n        $ cd pftcdtd\n        $ ls\n        28073 hwqzcr.zcp\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd lrwt\n        $ ls\n        38953 hzhzfw.tpv\n        59885 vnlmlq\n        $ cd ..\n        $ cd rhszw\n        $ ls\n        dir hsfbh\n        dir mmflqvsd\n        20071 rhdbms\n        162563 rpjjld\n        dir vnlmlq\n        $ cd hsfbh\n        $ ls\n        255050 lglw.jvw\n        99814 pzvw\n        28443 sbct.hng\n        168934 sbnhc.fnt\n        dir wnwztl\n        $ cd wnwztl\n        $ ls\n        dir brwhjj\n        215806 dcqq\n        214967 mqhv.wwq\n        82998 vcm.mhc\n        $ cd brwhjj\n        $ ls\n        171935 rbq.hpj\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd mmflqvsd\n        $ ls\n        109141 dcqq.mdc\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        dir blggqt\n        117656 dcqq.vlg\n        dir fpw\n        195879 gsb.dvw\n        dir mfhzl\n        5068 mnfdf\n        dir mtg\n        dir vnlmlq\n        $ cd blggqt\n        $ ls\n        195700 ntv.zjn\n        $ cd ..\n        $ cd fpw\n        $ ls\n        143105 sct\n        $ cd ..\n        $ cd mfhzl\n        $ ls\n        dir cpcczt\n        47767 nzzcn.qhp\n        dir zdv\n        $ cd cpcczt\n        $ ls\n        209755 vnlmlq.lbw\n        $ cd ..\n        $ cd zdv\n        $ ls\n        335546 sbnhc.ccg\n        $ cd ..\n        $ cd ..\n        $ cd mtg\n        $ ls\n        244632 dcqq.frr\n        240873 tpvqthc.ljw\n        dir zdtnqtcw\n        $ cd zdtnqtcw\n        $ ls\n        80980 nfqs.crt\n        $ cd ..\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        153953 dwvphbm\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd vnlmlq\n        $ ls\n        dir dcqq\n        dir dwvphbm\n        155333 mmhjscr.mrh\n        293720 nfqs.crt\n        dir qnv\n        dir rdvq\n        226720 zgmtqvws\n        160920 zgnft\n        $ cd dcqq\n        $ ls\n        142227 cqhdvmzp.npw\n        199798 twqppvs\n        $ cd ..\n        $ cd dwvphbm\n        $ ls\n        58807 cdbdnrqh.fgq\n        224321 hbnlqs\n        340073 sbnhc\n        337932 sct\n        2613 vdc.nwz\n        $ cd ..\n        $ cd qnv\n        $ ls\n        244311 cqhdvmzp.npw\n        273687 jhqt.glz\n        dir mnrh\n        240044 nfqs.crt\n        49861 pwsgmlq.hcw\n        dir rdrs\n        126195 vnlmlq.frr\n        $ cd mnrh\n        $ ls\n        276125 hbnlqs\n        $ cd ..\n        $ cd rdrs\n        $ ls\n        dir dqgw\n        213018 dwvphbm\n        13785 hbnlqs\n        dir lbpjczw\n        116081 nfqs.crt\n        154367 rbq.hpj\n        77634 sct\n        $ cd dqgw\n        $ ls\n        dir rpcfdr\n        $ cd rpcfdr\n        $ ls\n        dir swvlhbg\n        $ cd swvlhbg\n        $ ls\n        309244 sct\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd lbpjczw\n        $ ls\n        69436 rbq.hpj\n        $ cd ..\n        $ cd ..\n        $ cd ..\n        $ cd rdvq\n        $ ls\n        128806 dcqq.qzr\n        64132 dcqq.vgc\n        dir hht\n        165359 jzj.rqv\n        dir sbnhc\n        $ cd hht\n        $ ls\n        dir vnlmlq\n        $ cd vnlmlq\n        $ ls\n        49895 wct\n        $ cd ..\n        $ cd ..\n        $ cd sbnhc\n        $ ls\n        265434 vnlmlq\n    \"\"\".trimIndent()\n\n    // Parser: build FileSystem tree from string\n    fun buildInput(lines: String, withDirQueue: Boolean = false): Pair<FileSystemEntry, MutableList<FileSystemEntry>> {\n        val root = FileSystemEntry(\"/\")\n        val dirQueue = mutableListOf<FileSystemEntry>()\n        val filePattern = Regex(\"(\\\\d+) (.*)\")\n        var currentDir = root\n        for (line in lines.lineSequence()) {\n            when {\n                line.startsWith(\"$ cd ..\") -> {\n                    currentDir = currentDir.parent ?: currentDir\n                }\n                line.startsWith(\"$ cd \") -> {\n                    val dir = line.removePrefix(\"$ cd \")\n                    currentDir = currentDir.children.find { it.name == dir } ?: currentDir\n                }\n                line.startsWith(\"dir \") -> {\n                    val dir = FileSystemEntry(line.removePrefix(\"dir \"), currentDir)\n                    currentDir.children.add(dir)\n                    if (withDirQueue) dirQueue.add(dir)\n                }\n                filePattern.matches(line) -> {\n                    val (size, name) = filePattern.find(line)!!.destructured\n                    currentDir.children.add(FileSystemEntry(name, currentDir, size.toLong()))\n                }\n            }\n        }\n        root.getEntrySize()\n        return root to dirQueue\n    }\n\n    // Simple assertion\n    fun assertEquals(expected: Long, actual: Long, label: String) {\n        if (expected != actual) {\n            throw RuntimeException(\"Test failed: $label → expected $expected but got $actual\")\n        } else {\n            println(\"Passed: $label\")\n        }\n    }\n\n    // Example input tree\n    val (exampleRoot, exampleQueue) = buildInput(exampleInput, true)\n    // Real input tree\n    val (realRoot, realQueue) = buildInput(realInput, true)\n\n    // Run the 8 original test cases:\n    assertEquals(95437,\n        Day7PuzzleSolution(100000).solution(Day7PuzzleInput(exampleRoot)),\n        \"Day7PuzzleSolution example\")\n\n    assertEquals(1428881,\n        Day7PuzzleSolution(100000).solution(Day7PuzzleInput(realRoot)),\n        \"Day7PuzzleSolution real\")\n\n    assertEquals(95437,\n        Day7PuzzleSolutionList(100000).solution(Day7PuzzleInputList(exampleRoot, exampleQueue)),\n        \"Day7PuzzleSolutionList example\")\n\n    assertEquals(1428881,\n        Day7PuzzleSolutionList(100000).solution(Day7PuzzleInputList(realRoot, realQueue)),\n        \"Day7PuzzleSolutionList real\")\n\n    assertEquals(24933642,\n        Day7Puzzle2Solution().solution(Day7PuzzleInput(exampleRoot)),\n        \"Day7Puzzle2Solution example\")\n\n    assertEquals(10475598,\n        Day7Puzzle2Solution().solution(Day7PuzzleInput(realRoot)),\n        \"Day7Puzzle2Solution real\")\n\n    assertEquals(24933642,\n        Day7Puzzle2SolutionList().solution(Day7PuzzleInputList(exampleRoot, exampleQueue)),\n        \"Day7Puzzle2SolutionList example\")\n\n    assertEquals(10475598,\n        Day7Puzzle2SolutionList().solution(Day7PuzzleInputList(realRoot, realQueue)),\n        \"Day7Puzzle2SolutionList real\")\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Recursively finds the smallest directory that can be deleted to free at least the given size.\n *\n * Traverses the file system tree starting from the given entry, skipping non-directories and\n * those smaller than the required size. For each directory, it checks its children and\n * updates the candidate directory if a smaller valid one is found. If no smaller child fits,\n * the current directory is returned as the valid candidate.\n *\n * @param size the minimum required size that the directory must free.\n * @param entry the current file system entry to evaluate (could be a directory or file).\n * @return the smallest directory entry that meets or exceeds the size requirement, or null if none found.\n */", "canonical_solution": "private fun findDirectoryToDelete(size: Long, entry: FileSystemEntry): FileSystemEntry? {\n    if(!entry.isDir || entry.getEntrySize() < size) return null\n\n    var potentialDir: FileSystemEntry? = null\n    for(child in entry.children) {\n        val potentialChildDir = findDirectoryToDelete(size, child)\n        if(potentialChildDir != null) {\n            if(potentialDir == null || potentialDir.getEntrySize() > potentialChildDir.getEntrySize()) {\n                potentialDir = potentialChildDir\n            }\n        }\n    }\n    if(potentialDir != null) {\n        return potentialDir\n    }\n    return entry\n}"}
{"task_id": "16", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "potentialSteps", "fn_name": "potentialSteps", "fn_signature": "private fun potentialSteps(position: Position, locations: List<List<Int>>): List<Position> {", "context": "// import readInput\n\nimport java.io.File\n\n/**\n * Reads lines from the given input txt file.\n */\nfun readInput(name: String) = File(\"src\", name)\n    .readLines()\n\n// import util.toAlphabetPosition\n\n/**\n * Identifies the position in the alphabet starting at 'a' = 1 and 'A' = 27\n */\nfun Char.toAlphabetPosition(): Int {\n    if (!isLetter()) {\n        throw IllegalArgumentException(\"Passed in non letter.\")\n    }\n\n    return when (isLowerCase()) {\n        true -> code - 'a'.code + 1\n        else -> code - 'A'.code + 27\n    }\n}\n\ndata class Position(\n    val row: Int,\n    val column: Int\n)\n\ndata class Heatmap (\n    val startingPosition: Position,\n    val endingPosition: Position,\n    val locations: List<List<Int>>\n)\n\nobject Day12 {\n\n    /**\n     * @return\n     */\n    fun solutionOne(text: List<String>): Int {\n        val startingElevation = 'a'.toAlphabetPosition()\n        val endingElevation = 'z'.toAlphabetPosition()\n\n        val heatmap = parseText(\n            text = text,\n            startingElevation = startingElevation,\n            endingElevation = endingElevation\n        )\n\n        val path = findPath(heatmap, heatmap.startingPosition, heatmap.endingPosition)!!\n        return path.size - 1\n    }\n\n    /**\n     * @return\n     */\n    fun solutionTwo(text: List<String>): Int {\n        val startingElevation = 'a'.toAlphabetPosition()\n        val endingElevation = 'z'.toAlphabetPosition()\n\n        val heatmap = parseText(\n                text = text,\n                startingElevation = startingElevation,\n                endingElevation = endingElevation\n        )\n\n        val lowestLocations = mutableListOf<Position>()\n        heatmap.locations.forEachIndexed { rowIndex, row ->\n            row.forEachIndexed { colIndex, height ->\n                if (height == 1) {\n                    lowestLocations.add(Position(rowIndex, colIndex))\n                }\n            }\n        }\n\n        return lowestLocations\n            .mapNotNull { position ->\n                findPath(heatmap, position, heatmap.endingPosition)?.size\n            }\n            .minByOrNull { it }!! - 1\n    }\n\n    private fun parseText(\n        text: List<String>,\n        startingElevation: Int,\n        endingElevation: Int\n    ): Heatmap {\n\n        var startingPosition = Position(0, 0)\n        var endingPosition = Position(0,0)\n\n        val locations = text.mapIndexed() { row, line ->\n            line.mapIndexed { column, letter ->\n                when (letter) {\n                    'S' -> {\n                        startingPosition = Position(row, column)\n                        startingElevation\n                    }\n                    'E' -> {\n                        endingPosition = Position(row, column)\n                        endingElevation\n                    }\n                    else -> letter.toAlphabetPosition()\n                }\n            }\n        }\n\n        return Heatmap(\n            startingPosition = startingPosition,\n            endingPosition = endingPosition,\n            locations = locations\n        )\n    }\n\n    private fun findPath(heatmap: Heatmap, startingPosition: Position, endingPosition: Position): List<Position>? {\n        val shortestDistance = mutableMapOf<Position, List<Position>>()\n        val toEvaluateDistance = mutableListOf<Pair<List<Position>, Position>>() // path to positionToEvaluate\n\n        val startingElevation = heatmap.locations[startingPosition.row][startingPosition.column]\n\n        shortestDistance[startingPosition] = listOf(startingPosition)\n        val potentialSteps = potentialSteps(startingPosition, heatmap.locations)\n        potentialSteps.forEach { position ->\n            toEvaluateDistance.add(listOf(startingPosition) to position)\n        }\n\n        while (toEvaluateDistance.isNotEmpty()) {\n            val (path, position) = toEvaluateDistance.removeFirst()\n            val fullPath = path + position\n\n            when (val previousShortest = shortestDistance[position]) {\n                null -> {\n                    shortestDistance[position] = fullPath\n                    potentialSteps(position, heatmap.locations).forEach { potentialNextStep ->\n                        toEvaluateDistance.add(fullPath to potentialNextStep)\n                    }\n                }\n                else -> {\n                    if (fullPath.size < previousShortest.size) {\n                        shortestDistance[position] = fullPath\n                        potentialSteps(position, heatmap.locations).forEach { potentialNextStep ->\n                            toEvaluateDistance.add(fullPath to potentialNextStep)\n                        }\n                    }\n                }\n            }\n        }\n\n        return shortestDistance[endingPosition]\n    }\n\n    private fun potentialSteps(position: Position, locations: List<List<Int>>): List<Position> {\n        /* GENERATE THIS FUNCTION */\n    }\n}", "test": "fun main() {\n    val sampleText = listOf(\n        \"Sabqponm\",\n        \"abcryxxl\",\n        \"accszExk\",\n        \"acctuvwj\",\n        \"abdefghi\",\n    )\n\n    val result1 = Day12.solutionOne(sampleText)\n    if (result1 != 31) {\n        throw IllegalStateException(\"Test failed for solutionOne: expected 31, got $result1\")\n    }\n\n    val result2 = Day12.solutionTwo(sampleText)\n    if (result2 != 29) {\n        throw IllegalStateException(\"Test failed for solutionTwo: expected 29, got $result2\")\n    }\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Determines all valid next positions that can be stepped to from a given position,\n * based on elevation constraints in the heatmap grid.\n *\n * Evaluates the four orthogonal neighbors (up, down, left, right) and includes only those\n * within bounds whose elevation is at most one unit higher than the current position.\n *\n * @param position the current position in the grid.\n * @param locations a 2D grid of elevations representing the heatmap.\n * @return a list of valid neighboring positions that can be moved to.\n */", "canonical_solution": "private fun potentialSteps(position: Position, locations: List<List<Int>>): List<Position> {\n    val elevation = locations[position.row][position.column]\n    val possibleOtherPositions = mutableListOf<Position>()\n\n    // up\n    if (position.row > 0 && locations[position.row - 1][position.column] <= elevation + 1) {\n        possibleOtherPositions.add(Position(position.row - 1, position.column))\n    }\n\n    // down\n    if (position.row < locations.size - 1 && locations[position.row + 1][position.column] <= elevation + 1) {\n        possibleOtherPositions.add(Position(position.row + 1, position.column))\n    }\n\n    // left\n    if (position.column > 0 && locations[position.row][position.column - 1] <= elevation + 1) {\n        possibleOtherPositions.add(Position(position.row, position.column - 1))\n    }\n\n    // right\n    if (position.column < locations.first().size - 1 && locations[position.row][position.column + 1] <= elevation + 1) {\n        possibleOtherPositions.add(Position(position.row, position.column + 1))\n    }\n\n    return possibleOtherPositions\n}"}
{"task_id": "11", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "maxPoints", "fn_name": "maxPoints", "fn_signature": "fun maxPoints(grid: Array<IntArray>, queries: IntArray): IntArray {", "context": "// #Hard #Array #Sorting #Breadth_First_Search #Heap_Priority_Queue #Union_Find\n// #2023_07_04_Time_581_ms_(100.00%)_Space_62.6_MB_(100.00%)\n\nimport java.util.ArrayDeque\nimport java.util.Arrays\nimport java.util.PriorityQueue\nimport java.util.Queue\n\nclass Solution {\n    private val dirs = arrayOf(intArrayOf(-1, 0), intArrayOf(1, 0), intArrayOf(0, -1), intArrayOf(0, 1))\n\n    fun maxPoints(grid: Array<IntArray>, queries: IntArray): IntArray {\n        /* GENERATE THIS FUNCTION */\n    }\n}", "test": "fun main() {\n    fun assertEqual(actual: IntArray, expected: IntArray) {\n        if (actual.size != expected.size) {\n            throw IllegalStateException(\"Expected size ${expected.size}, but got ${actual.size}\")\n        }\n        for (i in actual.indices) {\n            if (actual[i] != expected[i]) {\n                throw IllegalStateException(\"Mismatch at index $i: expected ${expected[i]}, got ${actual[i]}\")\n            }\n        }\n    }\n\n    val sol = Solution()\n\n    // Test case 1\n    val result1 = sol.maxPoints(\n        arrayOf(\n            intArrayOf(1, 2, 3),\n            intArrayOf(2, 5, 7),\n            intArrayOf(3, 5, 1)\n        ),\n        intArrayOf(5, 6, 2)\n    )\n    assertEqual(result1, intArrayOf(5, 8, 1))\n\n    // Test case 2\n    val result2 = sol.maxPoints(\n        arrayOf(\n            intArrayOf(5, 2, 1),\n            intArrayOf(1, 1, 2)\n        ),\n        intArrayOf(3)\n    )\n    assertEqual(result2, intArrayOf(0))\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Computes the number of reachable cells with values strictly less than each query threshold.\n *\n * For each query value, the function explores the grid starting from the top-left cell (0,0),\n * expanding into neighboring cells using BFS. Cells with values lower than the current query\n * threshold are counted as accessible, while others are deferred using a priority queue until\n * future queries with higher thresholds. Queries are processed in ascending order, and results\n * are mapped back to the original query indices.\n *\n * @param grid 2D array of integers representing cell values in the grid.\n * @param queries Array of threshold values; for each query, counts how many cells are reachable\n *                with values less than the threshold.\n * @return An integer array where each element corresponds to the count of accessible cells for\n *         the respective query in the input order.\n */", "canonical_solution": "fun maxPoints(grid: Array<IntArray>, queries: IntArray): IntArray {\n    val r = grid.size\n    val c = grid[0].size\n    val res = IntArray(queries.size)\n    val index = arrayOfNulls<Int>(queries.size)\n    for (i in queries.indices) {\n        index[i] = i\n    }\n    Arrays.sort(index, { o: Int?, m: Int? -> queries[o!!].compareTo(queries[m!!]) })\n    val q1: Queue<IntArray> = ArrayDeque()\n    val q2 = PriorityQueue({ a: IntArray, b: IntArray -> a[2].compareTo(b[2]) })\n    q2.offer(intArrayOf(0, 0, grid[0][0]))\n    val visited = Array(r) { BooleanArray(c) }\n    var count = 0\n    visited[0][0] = true\n    for (i in queries.indices) {\n        val currLimit = queries[index[i]!!]\n        while (q2.isNotEmpty() && q2.peek()[2] < currLimit) {\n            q1.offer(q2.poll())\n        }\n        while (q1.isNotEmpty()) {\n            val curr = q1.poll()\n            count++\n            for (dir in dirs) {\n                val x = dir[0] + curr[0]\n                val y = dir[1] + curr[1]\n                if (x < 0 || y < 0 || x >= r || y >= c || visited[x][y]) {\n                    continue\n                }\n                if (!visited[x][y] && grid[x][y] < currLimit) {\n                    q1.offer(intArrayOf(x, y, grid[x][y]))\n                } else {\n                    q2.offer(intArrayOf(x, y, grid[x][y]))\n                }\n                visited[x][y] = true\n            }\n        }\n        res[index[i]!!] = count\n    }\n    return res\n}"}
{"task_id": "35", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "nextRingNodeOptimised", "fn_name": "nextRingNodeOptimised", "fn_signature": "fun nextRingNodeOptimised(i: Int) {", "context": "fun <T: Any> permutations(elements: Iterable<T>, r: Int = -1) = sequence {\n    val input = elements.toList()\n    val n = input.size\n    val k = if (r == -1) n else r\n    if (k == 0 || k > n) return@sequence\n    var indices = (0 until n).toMutableList()\n    val cycles = (n downTo n - k + 1).toMutableList()\n    yield(List(k) { input[indices[it]] })\n    while (true) {\n        var i = k - 1\n        while (i >= 0) {\n            if (--cycles[i] == 0) {\n                indices = (indices.take(i) + indices.slice(i + 1..indices.lastIndex) +\n                        indices[i]).toMutableList()\n                cycles[i] = n - i\n                if (i-- == 0) return@sequence\n            } else {\n                val j = cycles[i]\n                indices[n-j] = indices[i].also { indices[i] = indices[n-j] }\n                yield(List(k) { input[indices[it]] })\n                break\n            }\n        }\n    }\n}\n\n/**\n * Problem 68: Magic 5-Gon Ring\n *\n * https://projecteuler.net/problem=68\n *\n * Goal: Given N, representing a magic N-gon ring, and S, representing the total to which each\n * ring's line sums, return all concatenated strfings (in lexicographic order) representing the N\n * sets of solutions.\n *\n * Constraints: 3 <= N <= 10\n *\n * Magic 3-Gon Ring (as seen in above link): The ring has 3 external nodes, each ending a line of\n * 3 nodes (6 nodes total representing digits 1 to 6). The ring can be completed so the lines\n * reach 4 different totals, [9, 12], so there are 8 solutions in total:\n *      9 -> [{4,2,3}, {5,3,1}, {6,1,2}], [{4,3,2}, {6,2,1}, {5,1,3}]\n *      10 -> [{2,3,5}, {4,5,1}, {6,1,3}], [{2,5,3}, {6,3,1}, {4,1,5}]\n *      11 -> [{1,4,6}, {3,6,2}, {5,2,4}], [{1,6,4}, {5,4,2}, {3,2,6}]\n *      12 -> [{1,5,6}, {2,6,4}, {3,4,5}], [{1,6,5}, {3,5,4}, {2,4,6}]\n *      So the maximum concatenated string for a magic 3-gon is \"432621513\".\n *\n * e.g.: N = 3, S = 9\n *       solutions = [\"423531612\", \"432621513\"]\n */\n\nclass Magic5GonRing {\n    /**\n     * Project Euler specific implementation that requests the maximum 16-digit string solution\n     * from all solutions for a magic 5-gon ring that uses numbers 1 to 10 in its nodes.\n     *\n     * For the solution to have 16 digits, the number 10 has to be an external node, as, if it\n     * were placed on the internal ring, it would be used by 2 unique lines & would create a\n     * 17-digit concatenation. So, at minimum, the line with 10 as an external node will sum to 13.\n     *\n     * To create the largest lexicographic concatenation, larger numbers ideally should be placed\n     * first. Based on the magic 3-gon ring example detailed in the problem description, if the\n     * largest numbers are external nodes and the smallest numbers are ring nodes, the maximum\n     * solution occurs at the lowest total achieved by the following:\n     *\n     *      (externalNodes.sum() + 2 * internalNodes.sum()) / N\n     *\n     *      e.g. ([4, 5, 6].sum() + 2 * [1, 2, 3].sum()) / 3 = 9\n     *\n     * The maximum solution indeed occurs when S = 14 with the largest numbers on the external\n     * nodes, but all totals up to 27 were explored given the speed of the recursive solution below.\n     *\n     * N.B. Solutions exist for the following totals: [14, 16, 17, 19].\n     */\n    fun maxMagic5GonSolution(): String {\n        val solutions = mutableListOf<List<String>>()\n        for (s in 13..27) {\n            val solution = magicRingSolutionsOptimised(5, s)\n            if (solution.isNotEmpty()) {\n                solutions.add(solution)\n            }\n        }\n        return solutions.flatten().filter { it.length == 16 }.sortedDescending()[0]\n    }\n\n    /**\n     * Solution uses recursion to search through all permutations ([n] * 2 digits choose 3) from an\n     * increasingly smaller set of remaining digits. Permutations are checked to see if they sum\n     * to [s] & if their middle digit matches the last digit of the permutation found previously.\n     *\n     * A stack of the remaining digits to use is cached so the search can continue if a solution\n     * that cannot close the ring is reached. This is done by adding the elements of the last\n     * permutation back to the stack if the solution becomes invalid.\n     *\n     * Rather than searching for a final permutation that completes the ring, the expected list is\n     * generated based on the remaining digits possible & checked to see if it complements the\n     * starter list & adds up to [s].\n     *\n     * SPEED (WORST) 1.57s for N = 7, S = 23\n     */\n    fun magicRingSolutions(n: Int, s: Int): List<String> {\n        val solutions = mutableListOf<String>()\n        val allDigits = (1..n * 2).toMutableSet()\n\n        fun nextRingLine(solution: MutableList<List<Int>>) {\n            if (allDigits.size == 2) {\n                val expected = listOf(\n                    (allDigits - setOf(solution.last()[2])).first(),\n                    solution.last()[2],\n                    solution[0][1]\n                )\n                if (expected[0] > solution[0][0] && expected.sum() == s) {\n                    solutions.add(\n                        solution.flatten().joinToString(\"\") +\n                                expected.joinToString(\"\")\n                    )\n                }\n            } else {\n                for (perm in permutations(allDigits, 3)) {\n                    if (\n                        perm[1] != solution.last()[2] ||\n                        perm[0] < solution[0][0] ||\n                        perm.sum() != s\n                    ) continue\n                    solution.add(perm)\n                    allDigits.removeAll(perm.toSet() - setOf(perm[2]))\n                    nextRingLine(solution)\n                }\n            }\n            allDigits.addAll(solution.removeLast())\n        }\n\n        // starter must have the lowest external node, which limits the digits it can have\n        val starterMax = n * 2 - n + 1\n        for (starter in permutations(allDigits, 3)) {\n            if (starter[0] > starterMax || starter.sum() != s) continue\n            allDigits.removeAll(starter.toSet() - setOf(starter[2]))\n            nextRingLine(mutableListOf(starter))\n            allDigits.clear()\n            allDigits.addAll((1..n * 2).toMutableSet())\n        }\n        return solutions.sorted()\n    }\n\n    /**\n     * While still using recursion, the solution is optimised by not generating all permutations\n     * of 3-digit lines. Instead, nodes on the internal ring alone are recursively generated from\n     * an increasingly smaller set of available digits and the corresponding external node for\n     * every pair of ring nodes is calculated.\n     *\n     * SPEED (BETTER) 66.16ms for N = 7, S = 23\n     */\n    fun magicRingSolutionsImproved(n: Int, s: Int): List<String> {\n        val solutions = mutableListOf<String>()\n        val allDigits = (1..n * 2)\n        val remainingDigits = allDigits.toMutableSet()\n        val ringNodes = IntArray(n)\n        val externalNodes = IntArray(n)\n\n        fun nextRingNode(i: Int) {\n            if (i == n - 1) {\n                externalNodes[i] = s - ringNodes[i] - ringNodes[0]\n                if (\n                    externalNodes[i] in remainingDigits &&\n                    // first external node must be smallest of all external nodes\n                    externalNodes[0] == externalNodes.minOrNull()\n                ) {\n                    var solution = \"\"\n                    for (j in 0 until n) {\n                        solution += \"${externalNodes[j]}${ringNodes[j]}${ringNodes[(j+1)%n]}\"\n                    }\n                    solutions.add(solution)\n                }\n            } else {\n                for (digit in allDigits) {\n                    if (digit !in remainingDigits) continue\n                    val nextExternal = s - ringNodes[i] - digit\n                    if (nextExternal == digit || nextExternal !in remainingDigits) continue\n                    ringNodes[i+1] = digit\n                    externalNodes[i] = nextExternal\n                    val justUsed = setOf(digit, nextExternal)\n                    remainingDigits.removeAll(justUsed)\n                    nextRingNode(i + 1)\n                    // solution found or not; either way backtrack to try a different ring node\n                    remainingDigits.addAll(justUsed)\n                }\n            }\n        }\n\n        for (digit in allDigits) {\n            ringNodes[0] = digit\n            remainingDigits.remove(digit)\n            nextRingNode(0)\n            // solutions found or not; either way backtrack to start ring with a novel node\n            remainingDigits.clear()\n            remainingDigits.addAll(allDigits.toMutableSet())\n        }\n        return solutions.sorted()\n    }\n\n    /**\n     * This solution is identical to the above improved solution but cuts speed in half by taking\n     * advantage of the pattern that all solutions present in pairs.\n     *\n     * e.g. when N = 4, S = 12, the 1st solution will be found when the starter digit = 2, with\n     *\n     *      ringNodes = [2, 6, 1 ,3] and externalNodes = [4, 5, 8, 7] -> \"426561813732\"\n     *\n     * If the 1st 2 elements of ringNodes are swapped & the rest reversed, and all elements of\n     * externalNodes, except the static lowest external, are also reversed, the arrays become:\n     *\n     *      ringNodes = [6, 2, 3, 1] and externalNodes = [4, 7, 8, 5] -> \"462723831516\"\n     *\n     * This latter solution would have been eventually found when the starter digit = 6.\n     *\n     * Instead, any duplicate searches are eliminated by reversing all solutions when found & not\n     * allowing starter digits to explore adjacent ring digits that are smaller (as these would\n     * already have been found by previous iterations). So the starter digit 6 would only end up\n     * searching through ringNodes = [6, [7, 12], X, X]\n     *\n     * Lastly, neither digit 1 nor digit n need to be assessed as they will be found in later or\n     * earlier iterations.\n     *\n     * SPEED (BEST) 36.84ms for N = 7, S = 23\n     */\n    fun magicRingSolutionsOptimised(n: Int, s: Int): List<String> {\n        val solutions = mutableListOf<String>()\n        val allDigits = (1..n * 2)\n        val remainingDigits = allDigits.toMutableSet()\n        val ringNodes = IntArray(n)\n        val externalNodes = IntArray(n)\n\n        fun nextRingNodeOptimised(i: Int) {\n            /* GENERATE THIS FUNCTION */\n        }\n\n        for (digit in 2 until n * 2) {\n            ringNodes[0] = digit\n            remainingDigits.remove(digit)\n            nextRingNodeOptimised(0)\n            remainingDigits.clear()\n            remainingDigits.addAll(allDigits.toMutableSet())\n        }\n        return solutions.sorted()\n    }\n}", "test": "fun main() {\n    val tool = Magic5GonRing()\n\n    fun assertEquals(expected: Any, actual: Any) {\n        if (expected != actual) {\n            throw Error(\"assertEquals failed:\\nExpected: $expected\\nActual:   $actual\")\n        }\n    }\n\n    fun <T> assertContentEquals(expected: List<T>, actual: List<T>) {\n        if (expected.size != actual.size || expected != actual) {\n            throw Error(\"assertContentEquals failed:\\nExpected: $expected\\nActual:   $actual\")\n        }\n    }\n\n    // HR Problem correct for magic 3-gon ring\n    run {\n        val n = 3\n        val expected = listOf(\n            listOf(\"423531612\", \"432621513\"),\n            listOf(\"235451613\", \"253631415\"),\n            listOf(\"146362524\", \"164542326\"),\n            listOf(\"156264345\", \"165354246\")\n        )\n        for (s in 9..12) {\n            assertContentEquals(expected[s-9], tool.magicRingSolutions(n, s))\n            assertContentEquals(expected[s-9], tool.magicRingSolutionsImproved(n, s))\n            assertContentEquals(expected[s-9], tool.magicRingSolutionsOptimised(n, s))\n        }\n    }\n\n    // HR Problem correct for magic 4-gon ring\n    run {\n        val n = 4\n        val expected = listOf(\n            listOf(\"426561813732\", \"462723831516\"),\n            listOf(\"256364841715\", \"265751814346\", \"328481715652\", \"382625751418\"),\n            listOf(\"158284743635\", \"185653734248\", \"248581617374\", \"284347671518\"),\n            listOf(\"168483537276\", \"186267573438\"),\n            emptyList()\n        )\n        for (s in 12..16) {\n            assertContentEquals(expected[s-12], tool.magicRingSolutions(n, s))\n            assertContentEquals(expected[s-12], tool.magicRingSolutionsImproved(n, s))\n            assertContentEquals(expected[s-12], tool.magicRingSolutionsOptimised(n, s))\n        }\n    }\n\n    // HR Problem correct for magic 6-gon ring\n    run {\n        val n = 6\n        val expected = listOf(\n            listOf(\n                \"467872122393511511016\", \"467971111510521223836\", \"476106111159531232827\",\n                \"476863123210251151917\", \"629791111585410431232\", \"692122310348451151719\"\n            ),\n            listOf(\"3105115212246489817110\", \"3510710191868412421125\"),\n            listOf(\n                \"1117107282969412435311\", \"1117973123410458562611\", \"1711211686510541243937\",\n                \"1711511312346498921027\", \"2116126110184879735311\", \"2125115393747810816112\",\n                \"2125658108111179734312\", \"2512412393711711018685\", \"2512612110184879731135\",\n                \"2611511393747810811216\", \"2896941243531171111018\", \"2981081711151131234649\"\n            )\n        )\n        for (s in 17..19) {\n            assertContentEquals(expected[s-17], tool.magicRingSolutions(n, s))\n            assertContentEquals(expected[s-17], tool.magicRingSolutionsImproved(n, s))\n            assertContentEquals(expected[s-17], tool.magicRingSolutionsOptimised(n, s))\n        }\n    }\n\n    // PE problem correct\n    run {\n        val expected = \"6531031914842725\"\n        assertEquals(expected, tool.maxMagic5GonSolution())\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Recursively constructs valid ring configurations by selecting the next internal node\n * and calculating its corresponding external node, while pruning duplicate searches.\n *\n * For each recursive step, the function:\n * - Determines the required external node based on the current ring node and the target sum [s].\n * - Validates that the external node is distinct, available, and ensures the smallest external\n *   node starts the sequence to avoid symmetric duplicates.\n * - Builds two mirrored solutions (original and reversed) when a valid ring is completed,\n *   exploiting the fact that solutions exist in pairs.\n * - Uses backtracking to restore removed digits and explore alternative branches.\n *\n * @param i The index of the current internal ring node being assigned.\n * @return Unit (results are collected in the enclosing [solutions] list).\n */", "canonical_solution": "fun magicRingSolutionsOptimised(n: Int, s: Int): List<String> {\n    val solutions = mutableListOf<String>()\n    val allDigits = (1..n * 2)\n    val remainingDigits = allDigits.toMutableSet()\n    val ringNodes = IntArray(n)\n    val externalNodes = IntArray(n)\n\n    fun nextRingNodeOptimised(i: Int) {\n        if (i == n - 1) {\n            externalNodes[i] = s - ringNodes[i] - ringNodes[0]\n            if (\n                externalNodes[i] in remainingDigits &&\n                externalNodes[0] == externalNodes.minOrNull()\n            ) {\n                var solution1 = \"\"\n                var solution2 = \"\"\n                for (j in 0 until n) {\n                    solution1 += \"${externalNodes[j]}${ringNodes[j]}${ringNodes[(j+1)%n]}\"\n                    solution2 += \"${externalNodes[(n-j)%n]}${ringNodes[(n-j+1)%n]}${ringNodes[(n-j)%n]}\"\n                }\n                solutions.add(solution1)\n                solutions.add(solution2)\n            }\n        } else {\n            val searchRange = if (i == 0) (ringNodes[0] + 1)..(n * 2) else allDigits\n            for (digit in searchRange) {\n                if (digit !in remainingDigits) continue\n                val nextExternal = s - ringNodes[i] - digit\n                if (nextExternal == digit || nextExternal !in remainingDigits) continue\n                ringNodes[i+1] = digit\n                externalNodes[i] = nextExternal\n                val justUsed = setOf(digit, nextExternal)\n                remainingDigits.removeAll(justUsed)\n                nextRingNodeOptimised(i + 1)\n                remainingDigits.addAll(justUsed)\n            }\n        }\n    }\n\n    for (digit in 2 until n * 2) {\n        ringNodes[0] = digit\n        remainingDigits.remove(digit)\n        nextRingNodeOptimised(0)\n        remainingDigits.clear()\n        remainingDigits.addAll(allDigits.toMutableSet())\n    }\n    return solutions.sorted()\n}"}
{"task_id": "40", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "nextPosition", "fn_name": "nextPosition", "fn_signature": "private fun nextPosition(generator: InfiniteGenerator<Char>, current: String, directions: Direction): String {", "context": "interface Day<T> {\n    fun getInput(): T\n    fun part1(input: T): Any\n    fun part2(input: T): Any\n\n    fun run() {\n        val input = getInput()\n        warmup(input)\n        var start = System.nanoTime()\n        println(\"Part 1: ${part1(input)} (${(System.nanoTime() - start) / 1_000_000.0}ms)\")\n        start = System.nanoTime()\n        println(\"Part 2: ${part2(input)} (${(System.nanoTime() - start) / 1_000_000.0}ms)\")\n    }\n\n    fun readInputFile(day: String): String {\n        return this.javaClass.classLoader.getResource(\"day$day.txt\")!!\n            .readText()\n    }\n\n    /**\n     * Run this code before performance testing. Use this to run code to trigger compiler optimization.\n     *\n     * The default is a no-op method. Override to provide Day specific optimization code.\n     *\n     * Any code executed in this method will not be timed during part 1 or part 2\n     */\n    fun warmup(input: T) {\n        //No-op\n    }\n}\n\nfun gcd(num1: Long, num2: Long): Long {\n    if (num2 == 0L) {\n        return num1\n    }\n    return gcd(num2, num1 % num2)\n}\n\nfun lcm(numbers: List<Long>): Long {\n    var lcm = numbers[0]\n    for (i in 1 until numbers.size) {\n        val num1 = lcm\n        val num2 = numbers[i]\n        val gcdValue = gcd(num1, num2)\n        lcm = (lcm * num2) / gcdValue\n    }\n    return lcm\n}\n\ntypealias Direction = Map<String, Pair<String,String>>\n\n/**\n * Day 8: Haunted Wasteland\n *\n * The puzzle input consists of two parts. The first part is a set of instructions indicating which\n * direction to take (R = right, L = left). Those instructions repeat forever.\n * The second part maps a starting position to two possible ending positions (a left and a right)\n */\nclass Day8: Day<Pair<String, Direction>> {\n    override fun getInput(): Pair<String, Direction> {\n        return parseInput(readInputFile(\"8\"))\n    }\n\n    /**\n     * Part1: The starting position is AAA and the ending position is ZZZ\n     * Following the instructions, how many steps does it take to get to the end?\n     */\n    override fun part1(input: Pair<String, Direction>): Int {\n        val (instructionString, directions) = input\n        val instructionGenerator = InfiniteGenerator(instructionString.toCharArray().toList())\n        var current = \"AAA\"\n        while (current != \"ZZZ\") {\n            current = nextPosition(instructionGenerator, current, directions)\n        }\n        return instructionGenerator.num\n    }\n\n    /**\n     * Part 2: There are multiple starting points (every position that ends with A)\n     * and multiple ending points (every position that ends with Z)\n     *\n     * Starting at all possible starting locations at the same time, how many steps until\n     * each position has reached and end point at the same time?\n     */\n    override fun part2(input: Pair<String, Direction>): Long {\n        val (instructionString, directions) = input\n        val currentPositions = directions.keys.filter { it.endsWith(\"A\") }.toMutableList()\n\n        // find how long it takes to reach the end from each starting position\n        val endIndexes = currentPositions.map { start ->\n            var current = start\n            val instructionGenerator = InfiniteGenerator(instructionString.toCharArray().toList())\n            while (!current.endsWith(\"Z\")){\n                current = nextPosition(instructionGenerator, current, directions)\n            }\n            instructionGenerator.num.toLong()\n        }\n\n        // Note: This only works because for this puzzle, the repeating pattern of the instructions\n        // starts at the same time for each starting location. That does not necessarily have to be true\n        return lcm(endIndexes)\n    }\n\n    fun parseInput(input: String): Pair<String, Direction> {\n        val (instructions, directionList) = input.split(\"\\n\\n\")\n        val directionMap = directionList.lines().map { line ->\n            val (key, lrPair) = line.split(\" = \")\n            val (left, right) = lrPair.removeSuffix(\")\").removePrefix(\"(\").split(\", \")\n            Pair(key, Pair(left, right))\n        }.associate { (key, pair) -> key to pair }.toMap()\n        return Pair(instructions, directionMap)\n    }\n\n    private fun nextPosition(generator: InfiniteGenerator<Char>, current: String, directions: Direction): String {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    override fun warmup(input: Pair<String, Direction>) {\n        part1(input)\n    }\n}\n\nclass InfiniteGenerator<T>(private val order: List<T>) {\n    var num = 0\n    fun next(): T {\n        return order[num % order.size].also { num++ }\n    }\n}", "test": "fun main() {\n  val day = Day8()\n\n  // --- testPart1 ---\n  run {\n    val input = \"\"\"\n      LLR\n\n      AAA = (BBB, BBB)\n      BBB = (AAA, ZZZ)\n      ZZZ = (ZZZ, ZZZ)\n    \"\"\".trimIndent()\n    val result = day.part1(day.parseInput(input))\n    if (result != 6) {\n      throw RuntimeException(\"testPart1 failed: expected 6, got $result\")\n    }\n  }\n\n  // --- testPart2 ---\n  run {\n    val input = \"\"\"\n      LR\n\n      11A = (11B, XXX)\n      11B = (XXX, 11Z)\n      11Z = (11B, XXX)\n      22A = (22B, XXX)\n      22B = (22C, 22C)\n      22C = (22Z, 22Z)\n      22Z = (22B, 22B)\n      XXX = (XXX, XXX)\n    \"\"\".trimIndent()\n    val result = day.part2(day.parseInput(input))\n    if (result != 6L) {\n      throw RuntimeException(\"testPart2 failed: expected 6, got $result\")\n    }\n  }\n\n  // --- testLcm ---\n  run {\n    val result1 = lcm(listOf(1L, 2L, 8L, 3L))\n    if (result1 != 24L) {\n      throw RuntimeException(\"testLcm (case1) failed: expected 24, got $result1\")\n    }\n\n    val result2 = lcm(listOf(2L, 7L, 3L, 9L, 4L))\n    if (result2 != 252L) {\n      throw RuntimeException(\"testLcm (case2) failed: expected 252, got $result2\")\n    }\n  }\n\n  println(\"All tests passed!\")\n}", "description": "/**\n * Determines the next position in the navigation graph based on the current location\n * and the next instruction from the infinite instruction generator.\n *\n * Retrieves the next instruction ('L' or 'R') from the generator, looks up the possible\n * destinations from the directions map, and returns the appropriate next position.\n * Throws an exception if the instruction is not recognized.\n *\n * @param generator cyclic generator producing navigation instructions ('L' or 'R')\n * @param current the current node identifier in the map\n * @param directions mapping of each node to its left and right destination nodes\n * @return the identifier of the next node to move to\n */", "canonical_solution": "private fun nextPosition(generator: InfiniteGenerator<Char>, current: String, directions: Direction): String {\n    return when(val instruction = generator.next()) {\n        'L' -> directions.getValue(current).first\n        'R' -> directions.getValue(current).second\n        else -> throw IllegalArgumentException(\"Invalid instruction $instruction\")\n    }\n}"}
{"task_id": "64", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "search", "fn_name": "search", "fn_signature": "private fun search(cur: Int, pe: IntArray, onesol: MutableList<Int>, n: Int) {", "context": "/*\n * Designed and developed by 2022 ashtanko (Oleksii Shtanko)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.FILE)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class DFS(val info: String = \"\")\n\n/**\n * 1125. Smallest Sufficient Team\n * @see <a href=\"https://leetcode.com/problems/smallest-sufficient-team/\">Source</a>\n */\nfun interface SmallestSufficientTeam {\n    operator fun invoke(reqSkills: Array<String>, people: List<List<String>>): IntArray\n}\n\n@DFS\nclass SmallestSufficientTeamDFS : SmallestSufficientTeam {\n    private var sol: MutableList<Int> = ArrayList()\n\n    override operator fun invoke(reqSkills: Array<String>, people: List<List<String>>): IntArray {\n        val idx: MutableMap<String, Int> = HashMap()\n        var n = 0\n        for (s in reqSkills) idx[s] = n++ // skills are represented by 0, 1, 2....\n\n        val pe = IntArray(people.size)\n        for (i in pe.indices) {\n            for (p in people[i]) {\n                val skill = idx[p]!!\n                pe[i] += 1 shl skill\n            }\n        } // each person is transferred to a number, of which the bits of 1 means the guy has the skill\n\n        search(0, pe, ArrayList(), n)\n        val ans = IntArray(sol.size)\n        for (i in sol.indices) ans[i] = sol[i]\n        return ans\n    }\n\n    private fun search(cur: Int, pe: IntArray, onesol: MutableList<Int>, n: Int) {\n        /* GENERATE THIS FUNCTION */\n    }\n}", "test": "fun main() {\n    fun assertEqual(actual: IntArray, expected: IntArray) {\n        if (actual.size != expected.size) {\n            throw IllegalStateException(\n                \"Assertion failed: size mismatch. Expected=${expected.contentToString()}, Actual=${actual.contentToString()}\"\n            )\n        }\n        for (i in actual.indices) {\n            if (actual[i] != expected[i]) {\n                throw IllegalStateException(\n                    \"Assertion failed at index $i. Expected=${expected.contentToString()}, Actual=${actual.contentToString()}\"\n                )\n            }\n        }\n    }\n\n    val strategy = SmallestSufficientTeamDFS()\n\n    // Test case 1\n    run {\n        val reqSkills = arrayOf(\"java\", \"nodejs\", \"reactjs\")\n        val people = listOf(\n            listOf(\"java\"),\n            listOf(\"nodejs\"),\n            listOf(\"nodejs\", \"reactjs\"),\n        )\n        val expected = intArrayOf(0, 2)\n        val actual = strategy.invoke(reqSkills, people)\n        assertEqual(actual, expected)\n    }\n\n    val strategy2 = SmallestSufficientTeamDFS()\n\n    // Test case 2\n    run {\n        val reqSkills = arrayOf(\"algorithms\", \"math\", \"java\", \"reactjs\", \"csharp\", \"aws\")\n        val people = listOf(\n            listOf(\"algorithms\", \"math\", \"java\"),\n            listOf(\"algorithms\", \"math\", \"reactjs\"),\n            listOf(\"java\", \"csharp\", \"aws\"),\n            listOf(\"reactjs\", \"csharp\"),\n            listOf(\"csharp\", \"math\"),\n            listOf(\"aws\", \"java\"),\n        )\n        val expected = intArrayOf(1, 2)\n        val actual = strategy2.invoke(reqSkills, people)\n        assertEqual(actual, expected)\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Recursive backtracking search to find the smallest sufficient team.\n *\n * Explores all combinations of people to cover the required skills by representing\n * skills as bitmasks. At each step, it checks if all skills are covered, prunes\n * suboptimal solutions, and tries adding people who can cover the next uncovered skill.\n * Uses backtracking to explore and retract choices.\n *\n * @param cur current bitmask of covered skills\n * @param pe array where each element is a bitmask representing a person's skills\n * @param onesol current partial team (list of indices of selected people)\n * @param n total number of required skills\n * @return nothing directly; updates the global `sol` with the smallest team found\n */", "canonical_solution": "private fun search(cur: Int, pe: IntArray, onesol: MutableList<Int>, n: Int) {\n    if (cur == (1 shl n) - 1) {\n        if (sol.isEmpty() || onesol.size < sol.size) {\n            sol = ArrayList(onesol)\n        }\n        return\n    }\n    if (sol.isNotEmpty() && onesol.size >= sol.size) {\n        return\n    }\n    var zeroBit = 0\n    while (cur shr zeroBit and 1 == 1) zeroBit++\n    for (i in pe.indices) {\n        val per = pe[i]\n        if (per shr zeroBit and 1 == 1) {\n            onesol.add(i)\n            search(cur or per, pe, onesol, n)\n            onesol.removeAt(onesol.size - 1)\n        }\n    }\n}"}
{"task_id": "45", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "guessNumber", "fn_name": "guessNumber", "fn_signature": "fun guessNumber(maxNumber: Int): Int {", "context": "/**\n * I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower.\n * You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):\n */\ninternal data class NumberGuessingGame(val luckyNumber: Int) {\n    /**\n     * @return 0 if the given number is equal to [luckyNumber]; -1 if [luckyNumber] is lower than the given number;\n     * 1 if [luckyNumber] is higher than the given number.\n     */\n    private fun guess(guessedNumber: Int): Int {\n        return when {\n            guessedNumber == luckyNumber -> 0\n            guessedNumber > luckyNumber -> -1\n            else -> 1\n        }\n    }\n\n    /**\n     * Guesses the lucky number using binary search and the given maximum number. The limit for guessing is 1 to [maxNumber] (inclusive).\n     * @return the guessed number.\n     */\n    fun guessNumber(maxNumber: Int): Int {\n        /* GENERATE THIS FUNCTION */\n    }\n}", "test": "fun main() {\n    fun assertEquals(expected: Int, actual: Int) {\n        if (expected != actual) {\n            throw IllegalStateException(\"Assertion failed: expected=$expected, actual=$actual\")\n        }\n    }\n\n    // Equivalent to guessNumberTest()\n    assertEquals(1, NumberGuessingGame(1).guessNumber(1))\n    assertEquals(6, NumberGuessingGame(6).guessNumber(10))\n    assertEquals(699, NumberGuessingGame(699).guessNumber(1400))\n    assertEquals(3, NumberGuessingGame(3).guessNumber(1400))\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Finds the hidden lucky number between 1 and [maxNumber] using a binary search strategy.\n *\n * The function repeatedly selects a midpoint (pivot) between the current left and right bounds,\n * calls the internal `guess` function to compare it with the lucky number, and narrows down\n * the search range accordingly:\n * - If the pivot matches the lucky number, it returns the pivot immediately.\n * - If the lucky number is lower, the search continues in the left half.\n * - If the lucky number is higher, the search continues in the right half.\n * The process repeats until the number is found or the range becomes invalid.\n *\n * @param maxNumber the maximum bound of the range to search, with the range being [1, maxNumber].\n * @return the lucky number if found; -1 if no valid number is identified (error case).\n */", "canonical_solution": "fun guessNumber(maxNumber: Int): Int {\n    var right = maxNumber\n    var left = 1\n    var pivot: Int\n    while (left <= right) {\n        pivot = left + (right - left) / 2\n        val guessResult = guess(pivot)\n        when (guessResult) {\n            0 -> return pivot\n            -1 -> right = pivot\n            1 -> left = pivot + 1\n        }\n    }\n    return -1\n}"}
{"task_id": "26", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "split", "fn_name": "split", "fn_signature": "fun <T : Any> List<T>.split(isMarker: (T) -> Boolean): List<List<T>> {", "context": "fun part1(input: List<String>): Int {\n    return input.split { string -> string.isEmpty() }\n        .map { list ->\n            list.sumOf { string -> string.toInt() }\n        }.max()\n}\n\nfun part2(input: List<String>): Int {\n    return input.split { string -> string.isEmpty() }\n        .map { list ->\n            list.sumOf { string -> string.toInt() }\n        }.sortedDescending()\n        .take(3)\n        .sum()\n}\n\nfun <T : Any> List<T>.split(isMarker: (T) -> Boolean): List<List<T>> {\n    /* GENERATE THIS FUNCTION */\n}", "test": "fun main() {\n    val testInputRaw = \"\"\"\n        1000\n        2000\n        3000\n\n        4000\n\n        5000\n        6000\n\n        7000\n        8000\n        9000\n\n        10000\n    \"\"\"\n\n    val testInput = testInputRaw.trimIndent().lines()\n\n    if (part1(testInput) != 24000) {\n        throw IllegalStateException(\"part1(testInput) failed: expected 24000, got ${part1(testInput)}\")\n    }\n\n    if (part2(testInput) != 45000) {\n        throw IllegalStateException(\"part2(testInput) failed: expected 45000, got ${part2(testInput)}\")\n    }\n    \n    println(\"All tests passed.\")\n}", "description": "/**\n * Splits the list into sublists whenever an element matches the given marker condition.\n *\n * Iterates through the list, starting a new sublist each time the predicate `isMarker`\n * returns true for an element. Elements matching the marker are not included in the\n * resulting sublists. The last segment after the final marker is also added.\n *\n * @param isMarker a predicate function that determines whether an element is a split marker.\n * @return a list of sublists, each containing consecutive elements between markers.\n */", "canonical_solution": "fun <T : Any> List<T>.split(isMarker: (T) -> Boolean): List<List<T>> {\n    val result = mutableListOf<List<T>>()\n    var previousIndex = 0\n    forEachIndexed { index, value ->\n        if (isMarker(value)) {\n            result.add(subList(previousIndex, index))\n            previousIndex = index + 1\n        } else if (index == size -1) {\n            result.add(subList(previousIndex, size))\n        }\n    }\n    return result\n}"}
{"task_id": "29", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "traverse", "fn_name": "traverse", "fn_signature": "private fun traverse(nextLocations: (Point2D) -> List<Pair<Point2D, Int>>): Int {", "context": "/*\n * Copyright (c) 2023 by Todd Ginsberg\n */\n\n/**\n * Advent of Code 2023, Day 23 - A Long Walk\n * Problem Description: http://adventofcode.com/2023/day/23\n * Blog Post/Commentary: https://todd.ginsberg.com/post/advent-of-code/2023/day23/\n */\n\nimport kotlin.math.max\n\nimport kotlin.math.absoluteValue\n\ndata class Point2D(val x: Int, val y: Int) {\n    fun neighbors(): Set<Point2D> =\n        setOf(\n            this + NORTH_WEST,\n            this + NORTH,\n            this + NORTH_EAST,\n            this + WEST,\n            this + EAST,\n            this + SOUTH_WEST,\n            this + SOUTH,\n            this + SOUTH_EAST\n        )\n\n    fun cardinalNeighbors(): Set<Point2D> =\n        setOf(\n            this + NORTH,\n            this + EAST,\n            this + SOUTH,\n            this + WEST\n        )\n\n    fun distanceTo(other: Point2D): Int =\n        (x - other.x).absoluteValue + (y - other.y).absoluteValue\n\n    operator fun minus(other: Point2D): Point2D =\n        Point2D(x - other.x, y - other.y)\n\n    operator fun plus(other: Point2D): Point2D =\n        Point2D(x + other.x, y + other.y)\n\n    operator fun times(amount: Int): Point2D =\n        Point2D(x * amount, y * amount)\n\n    companion object {\n        val ORIGIN = Point2D(0, 0)\n        val NORTH = Point2D(0, -1)\n        val EAST = Point2D(1, 0)\n        val SOUTH = Point2D(0, 1)\n        val WEST = Point2D(-1, 0)\n        val NORTH_WEST = NORTH + WEST\n        val NORTH_EAST = NORTH + EAST\n        val SOUTH_WEST = SOUTH + WEST\n        val SOUTH_EAST = SOUTH + EAST\n    }\n}\n\nfun Array<CharArray>.isSafe(at: Point2D) =\n    at.y in this.indices && at.x in this[at.y].indices\n\noperator fun Array<CharArray>.set(at: Point2D, c: Char) {\n    this[at.y][at.x] = c\n}\n\noperator fun Array<CharArray>.get(at: Point2D): Char =\n    this[at.y][at.x]\n\nfun Array<CharArray>.swap(a: Point2D, b: Point2D) {\n    val tmp = this[a]\n    this[a] = this[b]\n    this[b] = tmp\n}\n\n\nclass Day23(input: List<String>) {\n\n    private val grid = input.map { it.toCharArray() }.toTypedArray()\n    private val start = Point2D(input.first().indexOfFirst { it == '.' }, 0)\n    private val goal = Point2D(input.last().indexOfFirst { it == '.' }, input.lastIndex)\n\n    fun solvePart1(): Int =\n        traverse { location ->\n            location.cardinalNeighbors()\n                .filter { grid.isSafe(it) }\n                .filter { newLocation -> grid[newLocation].matchesDirection(newLocation - location) }\n                .map { it to 1 }\n        }\n\n    fun solvePart2(): Int {\n        val reducedGrid = reduceGrid()\n        return traverse { location ->\n            reducedGrid\n                .getValue(location)\n                .map { it.key to it.value }\n        }\n    }\n\n    private fun Char.matchesDirection(direction: Point2D): Boolean =\n        when (this) {\n            '^' -> Point2D.NORTH == direction\n            '<' -> Point2D.WEST == direction\n            'v' -> Point2D.SOUTH == direction\n            '>' -> Point2D.EAST == direction\n            '.' -> true\n            else -> false\n        }\n\n    private fun traverse(nextLocations: (Point2D) -> List<Pair<Point2D, Int>>): Int {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    private fun reduceGrid(): Map<Point2D, Map<Point2D, Int>> =\n        grid.findDecisionPoints().let { decisionPoints ->\n            decisionPoints.associateWith { point ->\n                reduceGridFromPoint(point, decisionPoints)\n            }\n        }\n\n    private fun reduceGridFromPoint(from: Point2D, toAnyOther: Set<Point2D>): Map<Point2D, Int> {\n        val queue = ArrayDeque<Pair<Point2D, Int>>().apply {\n            add(from to 0)\n        }\n        val seen = mutableSetOf(from)\n        val answer = mutableMapOf<Point2D, Int>()\n        while (queue.isNotEmpty()) {\n            val (location, distance) = queue.removeFirst()\n            if (location != from && location in toAnyOther) {\n                answer[location] = distance\n            } else {\n                location.cardinalNeighbors()\n                    .filter { grid.isSafe(it) }\n                    .filter { grid[it] != '#' }\n                    .filter { it !in seen }\n                    .forEach {\n                        seen += it\n                        queue.add(it to distance + 1)\n                    }\n            }\n        }\n        return answer\n    }\n\n    private fun Array<CharArray>.findDecisionPoints() = buildSet {\n        add(start)\n        add(goal)\n        this@findDecisionPoints.forEachIndexed { y, row ->\n            row.forEachIndexed { x, c ->\n                if (c != '#') {\n                    Point2D(x, y).apply {\n                        if (cardinalNeighbors()\n                                .filter { grid.isSafe(it) }\n                                .filter { grid[it] != '#' }.size > 2\n                        ) {\n                            add(this)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "test": "fun main() {\n    val input = \"\"\"#.#####################\n#.......#########...###\n#######.#########.#.###\n###.....#.>.>.###.#.###\n###v#####.#v#.###.#.###\n###.>...#.#.#.....#...#\n###v###.#.#.#########.#\n###...#.#.#.......#...#\n#####.#.#.#######.#.###\n#.....#.#.#.......#...#\n#.#####.#.#.#########v#\n#.#...#...#...###...>.#\n#.#.#v#######v###.###v#\n#...#.>.#...>.>.#.###.#\n#####v#.#.###v#.#.###.#\n#.....#...#...#.#.#...#\n#.#########.###.#.#.###\n#...###...#...#...#.###\n###.###.#.###v#####v###\n#...#...#.#.>.>.#.>.###\n#.###.###.#.###.#.#v###\n#.....###...###...#...#\n#####################.#\n\"\"\".trimIndent().lines()\n\n    // Part 1 test\n    val answer1 = Day23(input).solvePart1()\n    if (answer1 != 94) {\n        throw IllegalStateException(\"Part 1 failed: expected 94, got $answer1\")\n    }\n\n    // Part 2 test\n    val answer2 = Day23(input).solvePart2()\n    if (answer2 != 154) {\n        throw IllegalStateException(\"Part 2 failed: expected 154, got $answer2\")\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Explore all possible paths from the starting point to the goal and return the maximum number of steps taken.\n *\n * This function performs a depth-first search, guided by a user-provided `nextLocations` function that defines\n * the movement rules of the traversal. It keeps track of visited points to prevent cycles, recursively explores\n * valid neighboring locations, and updates the longest path length whenever the goal is reached.\n *\n * @param nextLocations A function that, given a current location, returns a list of neighboring positions paired\n * with the step cost to reach them.\n * @return The maximum number of steps in any valid path from start to goal.\n */", "canonical_solution": "private fun traverse(nextLocations: (Point2D) -> List<Pair<Point2D, Int>>): Int {\n    var best = 0\n    val visited = mutableSetOf<Point2D>()\n\n    fun traverseWork(location: Point2D, steps: Int):Int {\n        if (location == goal) {\n            best = max(steps, best)\n            return best\n        }\n        visited += location\n        nextLocations(location)\n            .filter { (place, _) -> place !in visited }\n            .forEach { (place, distance) -> traverseWork(place, distance + steps) }\n        visited -= location\n        return best\n    }\n\n    return traverseWork(start, 0)\n}"}
{"task_id": "30", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "part2", "fn_name": "part2", "fn_signature": "fun part2(input: Input): Int {", "context": "import java.nio.file.Files\nimport java.nio.file.Paths\nimport kotlin.math.absoluteValue\nimport kotlin.math.sign\n\nfun part1(input: Input): Int {\n    val (xRange, yRange) = input.toList().map { it.first..it.second }\n    require(xRange.first > 0 && xRange.last >= xRange.first)\n    require(yRange.last < 0 && yRange.last >= yRange.first)\n    // assume we can find X such that X * (X + 1) / 2 in xRange and X <= Y * 2 + 1\n    // works for my test case, YMMW\n    val y = yRange.first.absoluteValue - 1\n    return y * (y + 1) / 2\n}\n\nfun part2(input: Input): Int {\n    /* GENERATE THIS FUNCTION */\n}\n\nprivate fun readInput(s: String): Input {\n    return s.let { line ->\n        val (xRange, yRange) = line.substring(\"target area: \".length).split(\", \")\n        val (xMin, xMax) = xRange.substring(\"x=\".length).split(\"..\").map { it.toInt() }\n        val (yMin, yMax) = yRange.substring(\"y=\".length).split(\"..\").map { it.toInt() }\n        Pair(xMin to xMax, yMin to yMax)\n    }\n}\n\nprivate typealias Input = Pair<Pair<Int, Int>, Pair<Int, Int>>", "test": "fun main() {\n    fun assertEquals(actual: Int, expected: Int) {\n        if (actual != expected) {\n            throw IllegalStateException(\"Test failed: expected $expected but got $actual\")\n        }\n    }\n\n    // Tests\n    assertEquals(part1(readInput(\"target area: x=20..30, y=-10..-5\")), 45)\n    assertEquals(part2(readInput(\"target area: x=20..30, y=-10..-5\")), 112)\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Counts the number of distinct initial velocity pairs that land within the target area.\n *\n * Simulates projectile trajectories for all possible integer velocity pairs where:\n * - The horizontal velocity (`xv`) ranges from 1 up to the maximum x-bound.\n * - The vertical velocity (`yv`) ranges from the minimum y-bound up to the absolute minimum y.\n * For each pair, it iteratively updates the projectile’s position:\n * - `cx` increases by the current x-velocity (`cxv`), which decreases by its sign (drag).\n * - `cy` increases by the current y-velocity (`cyv`), which decreases by 1 (gravity).\n * The loop continues until the projectile either hits the target area (increments `answer`)\n * or passes beyond it horizontally or vertically.\n *\n * @param input A pair of coordinate ranges, where the first range is the x-bound and the second range is the y-bound of the target area.\n * @return The number of initial velocity pairs that cause the projectile to land in the target area.\n */", "canonical_solution": "fun part2(input: Input): Int {\n    val (xRange, yRange) = input.toList().map { it.first..it.second }\n    require(xRange.first > 0 && xRange.last >= xRange.first)\n    require(yRange.last < 0 && yRange.last >= yRange.first)\n    var answer = 0\n    for (xv in 1..xRange.last) {\n        for (yv in yRange.first..yRange.first.absoluteValue) {\n            var (cx, cy) = 0 to 0\n            var (cxv, cyv) = xv to yv\n            while (true) {\n                cx += cxv.also { cxv -= cxv.sign }\n                cy += cyv--\n                if (cx in xRange && cy in yRange) {\n                    answer++\n                    break\n                }\n                if (cx > xRange.last || cy < yRange.first) break\n            }\n        }\n    }\n    return answer\n}"}
{"task_id": "96", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "part1", "fn_name": "part1", "fn_signature": "fun part1(): Int {", "context": "class RockPaperScissors(\n    private val input: String\n) {\n    private fun readRockPaperScissors(): List<Pair<Char, Char>> {\n        return input.lines().map { line ->\n            return@map (line.first()) to (line.last())\n        }\n    }\n\n    fun part1(): Int {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    fun part2(): Int {\n        val strategy = listOf(3, 1, 2, 3, 1)\n        return readRockPaperScissors()\n            .map { round ->\n                val shape = round.first - 'A' + 1\n                return@map when (round.second) {\n                    'X' -> 0 + strategy[shape - 1]\n                    'Y' -> 3 + shape\n                    else -> 6 + strategy[shape + 1]\n                }\n            }\n            .sum()\n    }\n}", "test": "fun main() {\n    val input = \"\"\"\n        A Y\n        B X\n        C Z\n    \"\"\".trimIndent()\n\n    val rps = RockPaperScissors(input)\n\n    // part1 test\n    val part1Result = rps.part1()\n    if (part1Result != 15) {\n        throw IllegalStateException(\"part1() failed: expected 15, got $part1Result\")\n    }\n\n    // part2 test\n    val part2Result = rps.part2()\n    if (part2Result != 12) {\n        throw IllegalStateException(\"part2() failed: expected 12, got $part2Result\")\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Calculates the total score for part 1 of the Rock-Paper-Scissors game.\n *\n * Reads the input into rounds, converts characters to numeric values representing shapes,\n * then computes the outcome of each round based on the difference between opponent's and\n * player's moves. Each round's score is the sum of the shape value and the outcome points\n * (win, draw, or loss), and all rounds are accumulated into a final score.\n *\n * @return The total score as an integer across all rounds.\n */", "canonical_solution": "fun part1(): Int {\n    return readRockPaperScissors()\n        .map { round ->\n            (round.first - 'A' + 1) to (round.second - 'X' + 1)\n        }\n        .fold(0) { score, round ->\n            val outcome = when (round.second - round.first) {\n                0 -> 3\n                1 -> 6\n                -2 -> 6\n                else -> 0\n            }\n            val shape = round.second\n            return@fold score + shape + outcome\n        }\n}"}
{"task_id": "77", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "executeRecursive", "fn_name": "executeRecursive", "fn_signature": "fun executeRecursive(input: TreeNode?, acc: TreeNode? = null): TreeNode? = when (input) {", "context": "import java.util.*\n\ndata class TreeNode(var `val`: Int, var left: TreeNode? = null, var right: TreeNode? = null)\n\ntypealias Node = TreeNode\n\n// https://leetcode.com/problems/increasing-order-search-tree/\nclass RearrangeTree {\n    fun executeRecursive(input: TreeNode?, acc: TreeNode? = null): TreeNode? = when (input) {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    fun executeIterative(input: TreeNode?): TreeNode? {\n        var root: TreeNode? = null\n        var current = input\n        var last: TreeNode? = null\n        val stack = LinkedList<TreeNode>()\n        while (current != null || stack.isNotEmpty()) {\n            while (current != null) {\n                stack.push(current)\n                current = current.left\n            }\n            if (stack.isNotEmpty()) {\n                val item = stack.pop()\n                TreeNode(item.`val`).let { newNode ->\n                    if (last == null) {\n                        root = newNode\n                        last = newNode\n                    } else {\n                        last!!.right = newNode\n                        last = newNode\n                    }\n                }\n                current = item?.right\n            }\n        }\n        return root\n    }\n}", "test": "fun main() {\n    fun treesEqual(a: TreeNode?, b: TreeNode?): Boolean {\n        if (a == null && b == null) return true\n        if (a == null || b == null) return false\n        return a.`val` == b.`val` && treesEqual(a.left, b.left) && treesEqual(a.right, b.right)\n    }\n\n    fun treeToString(node: TreeNode?): String {\n        if (node == null) return \"null\"\n        val rightStr = if (node.right != null) \" -> ${treeToString(node.right)}\" else \"\"\n        return \"${node.`val`}$rightStr\"\n    }\n\n    val tests = listOf(\n        Pair(\n            TreeNode(5,\n                left = TreeNode(3,\n                    left = TreeNode(2, left = TreeNode(1)),\n                    right = TreeNode(4)),\n                right = TreeNode(6,\n                    right = TreeNode(8,\n                        left = TreeNode(7),\n                        right = TreeNode(9)))),\n            TreeNode(1,\n                right = TreeNode(2,\n                    right = TreeNode(3,\n                        right = TreeNode(4,\n                            right = TreeNode(5,\n                                right = TreeNode(6,\n                                    right = TreeNode(7,\n                                        right = TreeNode(8,\n                                            right = TreeNode(9))))))))))\n    )\n\n    tests.forEachIndexed { index, (input, expected) ->\n        val recursiveOutput = RearrangeTree().executeRecursive(input)\n        if (!treesEqual(expected, recursiveOutput)) {\n            throw IllegalStateException(\n                \"Recursive test $index failed.\\nExpected: ${treeToString(expected)}\\nBut got: ${treeToString(recursiveOutput)}\"\n            )\n        } else {\n            println(\"Valid: recursive index $index output '${treeToString(recursiveOutput)}'\")\n        }\n\n        val iterativeOutput = RearrangeTree().executeIterative(input)\n        if (!treesEqual(expected, iterativeOutput)) {\n            throw IllegalStateException(\n                \"Iterative test $index failed.\\nExpected: ${treeToString(expected)}\\nBut got: ${treeToString(iterativeOutput)}\"\n            )\n        } else {\n            println(\"Valid: iterative index $index output '${treeToString(iterativeOutput)}'\")\n        }\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Rearranges a binary search tree into an increasing order right-skewed tree using recursion.\n *\n * Performs an in-order traversal: processes the left subtree, then the current node, then the right subtree.\n * At each step, appends the current node's value to the rightmost position of the accumulating tree,\n * effectively flattening the BST into a chain of nodes where each node has only a right child.\n *\n * @param input the current subtree root being traversed; null indicates the end of a branch.\n * @param acc the partially built right-skewed tree that accumulates results across recursive calls.\n * @return the root of the increasing order right-skewed tree containing all values of the original BST.\n */", "canonical_solution": "fun executeRecursive(input: TreeNode?, acc: TreeNode? = null): TreeNode? = when (input) {\n    null -> acc\n    else -> {\n        executeRecursive(input.right, executeRecursive(input.left, acc)?.also {\n            var current = it\n            while (current.right != null) current = current.right!!\n            current.right = TreeNode(input.`val`)\n        } ?: TreeNode(input.`val`))\n    }\n}"}
{"task_id": "70", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "solution", "fn_name": "solution", "fn_signature": "override fun solution(input: Day9PuzzleInput): Int {", "context": "import java.io.File\nimport kotlin.math.abs\n\nopen class PuzzleInput<T>(val expectedResult: T? = null)\nabstract class Puzzle<T, P : PuzzleInput<T>> {\n    fun solve(input: P) {\n        val solution = solution(input)\n        if(input.expectedResult != null) {\n            if(solution != input.expectedResult) {\n                println(\"$solution == ${input.expectedResult}\")\n            }\n            check(solution == input.expectedResult)\n        }\n        else {\n            println(solution)\n        }\n    }\n\n    abstract fun solution(input: P) : T\n}\n\nclass Day9PuzzleInput(val input: String, numKnots: Int, expectedResult: Int? = null) : PuzzleInput<Int>(expectedResult) {\n    val moves = input.lines()\n    val pointsVisited = HashMap<Pair<Int, Int>, Boolean>()\n    private val knots = Array(numKnots) {\n        Pair(0, 0)\n    }\n\n    private fun getKnot(head: Pair<Int, Int>, tail: Pair<Int, Int>): Pair<Int, Int> {\n        val x = head.first - tail.first\n        val y = head.second - tail.second\n        if(abs(x) > 1 || abs(y) > 1) {\n            return Pair(tail.first + x.coerceIn(-1, 1), tail.second + y.coerceIn(-1, 1))\n        }\n        return tail\n    }\n\n    private fun moveHead(newHead: Pair<Int, Int>) {\n        knots[0] = newHead\n        for(i in 1 until knots.size) {\n            knots[i] = getKnot(knots[i-1], knots[i])\n        }\n        pointsVisited[knots.last()] = true\n    }\n    fun moveHead(xOffset: Int, yOffset: Int, amount: Int) {\n        for(move in 1 .. amount) {\n            moveHead(Pair(knots[0].first + xOffset, knots[0].second + yOffset))\n        }\n    }\n}\n\nclass Day9PuzzleSolution : Puzzle<Int, Day9PuzzleInput>() {\n    override fun solution(input: Day9PuzzleInput): Int {\n        /* GENERATE THIS FUNCTION */\n    }\n}", "test": "val example = \"\"\"\nR 4\nU 4\nL 3\nD 1\nR 4\nD 1\nL 5\nR 2\n\"\"\".trimIndent()\n\nval example2 = \"\"\"\nR 5\nU 8\nL 8\nD 3\nR 17\nD 10\nL 25\nU 20\n\"\"\".trimIndent()\n\nval input = \"\"\"\nU 1\nL 1\nD 2\nU 2\nR 2\nD 1\nL 1\nD 2\nR 2\nD 2\nU 1\nL 1\nD 2\nU 1\nD 2\nL 2\nR 1\nU 1\nL 1\nR 1\nU 1\nR 2\nL 1\nD 2\nU 1\nR 1\nL 2\nR 2\nL 2\nR 2\nL 2\nU 1\nL 2\nU 1\nD 2\nL 2\nR 2\nD 2\nL 2\nU 2\nL 1\nU 1\nD 2\nL 1\nD 1\nR 1\nU 1\nL 2\nD 2\nU 2\nL 1\nD 1\nR 2\nD 1\nR 2\nD 1\nR 2\nU 2\nR 2\nL 2\nR 1\nD 1\nU 1\nR 2\nD 1\nU 1\nR 2\nL 2\nU 2\nR 2\nU 1\nD 1\nR 2\nL 1\nU 1\nL 2\nD 1\nR 1\nU 2\nL 1\nD 2\nL 1\nR 2\nD 2\nL 2\nR 2\nU 2\nR 2\nD 2\nL 1\nR 2\nU 1\nR 2\nU 1\nL 1\nR 1\nL 2\nU 2\nL 1\nD 2\nL 2\nU 2\nD 2\nR 2\nD 2\nR 1\nU 2\nL 1\nU 1\nL 2\nR 1\nD 1\nR 1\nL 1\nD 2\nL 2\nR 2\nD 3\nR 2\nD 2\nL 3\nR 1\nL 2\nU 3\nD 1\nU 1\nL 2\nD 2\nL 2\nR 2\nL 1\nU 2\nD 2\nU 2\nD 1\nL 1\nD 1\nR 2\nD 3\nU 3\nD 3\nL 2\nR 2\nU 1\nL 3\nR 2\nU 2\nD 2\nL 3\nD 2\nR 3\nD 3\nU 2\nR 2\nD 2\nU 1\nL 3\nR 3\nU 3\nL 3\nD 3\nL 3\nD 2\nL 1\nR 2\nL 1\nR 2\nD 1\nL 3\nR 2\nD 3\nL 1\nR 1\nL 2\nU 1\nL 2\nR 2\nU 2\nL 1\nD 1\nR 3\nL 1\nR 2\nU 2\nD 1\nR 2\nU 1\nR 3\nU 1\nD 3\nR 3\nL 1\nD 1\nU 1\nD 3\nR 2\nU 1\nR 1\nU 1\nL 3\nD 2\nU 3\nR 2\nD 1\nR 1\nU 2\nL 1\nU 1\nR 3\nU 2\nD 1\nR 2\nU 3\nD 2\nU 1\nR 2\nL 2\nU 3\nL 1\nR 1\nL 2\nD 2\nU 1\nD 2\nR 3\nD 3\nU 4\nR 3\nD 2\nU 4\nL 4\nU 3\nL 1\nU 2\nL 2\nR 3\nU 4\nD 1\nL 1\nD 2\nL 2\nR 1\nL 2\nU 1\nL 3\nD 1\nL 2\nD 3\nR 3\nD 4\nL 2\nU 4\nL 3\nR 4\nD 4\nR 2\nD 2\nL 2\nR 2\nU 4\nL 3\nD 1\nR 1\nL 2\nD 1\nU 1\nL 2\nU 1\nL 1\nU 2\nD 4\nL 4\nU 2\nR 2\nL 2\nR 3\nU 2\nD 3\nU 4\nD 3\nR 2\nL 4\nU 2\nR 2\nU 3\nD 4\nR 4\nL 2\nR 4\nD 4\nU 3\nL 3\nD 4\nL 4\nR 2\nL 1\nR 3\nD 2\nU 4\nR 3\nU 1\nR 2\nU 1\nD 1\nR 1\nL 4\nU 4\nR 1\nD 4\nL 3\nU 1\nD 2\nR 2\nL 2\nD 2\nU 4\nR 3\nL 4\nD 1\nR 1\nU 3\nR 4\nL 2\nR 2\nU 3\nL 4\nR 1\nL 3\nD 3\nR 2\nD 2\nL 2\nD 2\nU 4\nD 5\nL 4\nU 2\nD 3\nL 1\nU 4\nR 5\nD 5\nU 4\nR 5\nL 2\nD 4\nR 2\nL 2\nR 1\nU 1\nD 5\nU 1\nD 2\nR 5\nL 4\nD 4\nR 2\nL 3\nR 3\nL 1\nU 4\nR 2\nL 4\nU 5\nR 5\nD 3\nU 4\nL 2\nU 5\nR 3\nU 5\nL 4\nR 2\nU 2\nR 3\nL 5\nD 2\nR 5\nL 2\nR 5\nD 4\nU 4\nL 5\nU 1\nD 4\nU 5\nL 5\nD 2\nL 2\nD 4\nL 2\nD 2\nR 4\nU 4\nD 2\nL 1\nD 3\nU 3\nR 2\nD 2\nL 5\nD 3\nR 2\nL 2\nU 3\nD 5\nR 1\nL 4\nD 1\nL 5\nR 3\nL 3\nD 3\nL 2\nU 5\nL 5\nR 4\nD 5\nU 2\nR 2\nL 3\nU 1\nD 1\nU 2\nR 3\nU 2\nL 4\nU 4\nL 3\nU 3\nD 3\nR 2\nL 5\nR 5\nU 2\nD 2\nU 4\nD 3\nU 1\nL 1\nD 4\nR 3\nL 1\nD 5\nR 3\nU 1\nL 6\nU 5\nD 4\nR 4\nL 5\nU 2\nD 6\nL 4\nR 2\nU 4\nL 2\nR 1\nU 6\nD 6\nR 1\nL 2\nU 4\nL 2\nD 6\nL 6\nR 3\nL 3\nD 5\nU 6\nD 5\nU 5\nL 6\nR 6\nU 3\nR 6\nU 2\nD 1\nU 3\nR 6\nD 5\nL 3\nR 1\nD 6\nR 3\nD 2\nU 2\nD 3\nL 6\nU 3\nL 3\nU 1\nR 6\nU 2\nD 3\nR 1\nU 3\nR 6\nL 2\nR 4\nL 1\nR 5\nL 1\nR 4\nU 6\nD 3\nU 2\nL 4\nR 1\nL 2\nR 4\nU 5\nR 1\nL 2\nU 1\nR 2\nU 6\nR 1\nD 2\nL 1\nU 2\nD 2\nL 1\nU 1\nR 4\nD 5\nL 4\nD 6\nL 2\nU 3\nD 3\nL 1\nR 3\nD 1\nL 6\nD 1\nU 6\nL 1\nD 6\nU 3\nR 5\nL 2\nR 4\nD 5\nL 4\nD 6\nU 1\nD 6\nL 6\nU 3\nD 3\nU 2\nL 1\nR 5\nU 5\nL 6\nU 5\nR 5\nD 4\nU 7\nR 7\nL 2\nD 3\nR 3\nL 1\nD 6\nR 3\nL 2\nU 2\nD 2\nU 2\nL 7\nR 4\nU 3\nL 3\nR 2\nL 5\nU 3\nR 6\nU 5\nL 7\nU 7\nL 4\nU 5\nL 7\nD 1\nL 1\nD 2\nU 3\nR 5\nD 1\nR 6\nL 3\nU 5\nD 6\nL 4\nD 3\nU 3\nR 3\nU 1\nR 2\nL 7\nD 7\nR 4\nL 6\nD 7\nL 7\nD 2\nU 1\nR 2\nU 3\nL 2\nD 2\nL 5\nD 4\nR 5\nD 7\nU 5\nD 1\nL 4\nU 2\nR 5\nD 6\nL 4\nR 7\nU 6\nD 2\nL 4\nD 4\nL 1\nR 4\nL 1\nR 5\nU 5\nR 5\nL 1\nD 2\nR 1\nU 5\nL 4\nD 2\nU 3\nL 2\nR 5\nU 4\nL 1\nR 5\nL 1\nD 5\nR 7\nL 5\nU 5\nL 7\nU 3\nD 6\nU 2\nL 2\nR 5\nU 7\nD 1\nR 2\nU 4\nR 7\nU 6\nL 3\nU 5\nD 3\nU 5\nD 6\nR 2\nU 8\nR 7\nL 5\nU 1\nD 3\nL 3\nU 6\nL 6\nU 5\nD 7\nU 3\nL 6\nU 1\nD 3\nR 5\nL 2\nR 1\nD 6\nR 2\nL 1\nR 5\nD 3\nL 1\nR 3\nL 6\nD 5\nU 5\nL 5\nD 3\nL 4\nR 7\nD 6\nL 8\nR 6\nU 8\nD 6\nR 3\nU 4\nR 1\nU 6\nR 3\nL 6\nD 2\nU 5\nR 2\nD 5\nU 7\nD 2\nU 2\nR 3\nL 3\nU 4\nR 3\nU 7\nL 2\nD 3\nR 2\nD 4\nL 4\nD 8\nR 2\nU 2\nL 7\nR 8\nU 8\nL 4\nU 3\nR 3\nU 8\nD 2\nU 5\nD 8\nR 8\nL 8\nR 4\nD 8\nL 7\nU 6\nL 4\nD 6\nU 2\nL 4\nU 8\nR 8\nU 6\nD 1\nR 5\nU 5\nL 8\nU 2\nR 3\nU 7\nL 5\nU 5\nL 7\nD 8\nR 7\nU 4\nD 7\nU 4\nL 3\nR 3\nD 5\nU 1\nL 6\nD 3\nU 5\nD 3\nR 1\nU 2\nL 3\nR 8\nU 1\nD 6\nR 6\nU 9\nD 4\nU 4\nD 2\nL 1\nR 2\nL 6\nU 6\nL 1\nR 1\nU 9\nD 1\nR 4\nL 3\nD 8\nU 7\nD 1\nR 7\nL 6\nU 3\nR 2\nL 2\nD 6\nU 5\nD 6\nL 6\nU 8\nL 5\nR 4\nU 6\nL 1\nU 8\nL 4\nR 1\nD 7\nR 9\nU 2\nD 3\nR 6\nL 8\nU 6\nR 4\nD 1\nU 7\nR 1\nD 9\nL 8\nD 9\nR 1\nU 6\nR 7\nD 2\nU 7\nR 4\nD 9\nR 7\nD 2\nU 1\nR 3\nD 4\nL 5\nU 7\nR 7\nD 2\nU 8\nR 8\nL 4\nU 6\nL 3\nD 8\nL 8\nD 9\nR 7\nL 5\nU 5\nR 4\nU 9\nR 3\nU 9\nR 1\nU 2\nR 9\nU 8\nL 8\nU 7\nR 1\nD 9\nU 4\nL 7\nR 3\nU 5\nL 6\nD 1\nL 4\nD 4\nU 6\nR 7\nL 7\nU 3\nL 8\nD 8\nL 7\nU 3\nD 4\nR 8\nD 1\nR 8\nU 10\nL 1\nU 2\nD 4\nU 3\nR 8\nU 3\nD 5\nR 8\nD 10\nR 8\nD 4\nR 9\nD 1\nL 3\nU 7\nR 7\nL 1\nD 8\nR 6\nD 4\nU 5\nL 2\nU 3\nR 7\nU 10\nL 1\nU 7\nR 1\nU 7\nD 2\nL 10\nU 2\nL 4\nD 6\nR 10\nD 4\nU 7\nL 6\nR 4\nU 6\nD 1\nU 6\nD 5\nU 6\nL 4\nD 2\nL 2\nU 7\nR 2\nU 9\nL 9\nD 2\nU 9\nR 9\nU 9\nD 3\nR 5\nD 3\nL 10\nU 3\nD 10\nL 10\nD 1\nU 2\nD 3\nR 8\nL 1\nU 6\nL 2\nR 9\nU 3\nD 5\nL 8\nU 4\nR 8\nD 5\nL 6\nU 7\nD 8\nR 9\nU 9\nR 8\nD 4\nR 5\nU 6\nL 8\nR 2\nD 3\nL 8\nD 6\nR 7\nL 10\nU 9\nR 6\nL 7\nU 8\nR 5\nL 1\nD 1\nR 6\nD 1\nR 9\nL 1\nU 5\nR 3\nD 7\nU 8\nD 6\nL 6\nU 11\nD 8\nL 6\nD 6\nL 7\nR 10\nU 5\nD 7\nR 5\nD 3\nL 4\nR 3\nD 2\nL 6\nU 6\nD 3\nL 4\nD 9\nL 6\nU 9\nL 3\nU 10\nR 5\nU 8\nR 2\nD 3\nL 6\nR 2\nU 6\nR 8\nD 2\nU 2\nR 5\nU 9\nL 5\nD 8\nR 2\nU 1\nR 1\nD 6\nU 4\nR 7\nL 7\nD 7\nU 11\nR 6\nU 11\nD 11\nR 6\nL 2\nD 10\nR 6\nD 5\nR 7\nD 11\nR 2\nU 10\nL 6\nD 4\nR 1\nL 3\nD 9\nU 8\nL 6\nU 1\nL 7\nD 10\nU 1\nL 1\nD 2\nU 3\nL 4\nR 6\nU 11\nR 6\nU 3\nL 8\nD 3\nR 7\nL 3\nD 4\nL 5\nU 8\nL 11\nR 1\nU 1\nL 9\nD 5\nU 3\nR 1\nL 6\nU 1\nL 3\nD 1\nL 8\nU 1\nD 9\nR 7\nU 11\nR 10\nU 8\nR 5\nU 3\nL 7\nR 3\nL 4\nU 6\nD 3\nU 3\nR 3\nD 1\nL 7\nU 5\nD 1\nU 6\nL 8\nD 3\nR 6\nU 10\nR 6\nD 1\nU 7\nR 5\nL 6\nR 5\nD 3\nR 9\nU 11\nL 8\nR 9\nU 5\nR 5\nL 1\nU 7\nL 11\nU 5\nR 3\nU 7\nR 9\nL 11\nD 11\nL 3\nU 11\nL 2\nU 3\nR 5\nD 1\nL 10\nR 8\nL 11\nU 1\nD 11\nL 4\nR 8\nL 9\nD 6\nU 10\nL 1\nR 12\nU 2\nD 8\nL 8\nU 1\nL 12\nD 9\nR 3\nU 3\nD 10\nU 11\nD 9\nU 8\nL 7\nD 10\nL 3\nU 9\nD 5\nR 12\nD 3\nR 9\nL 8\nR 12\nU 11\nD 5\nR 10\nD 8\nL 12\nU 7\nL 1\nR 7\nD 1\nR 12\nL 3\nR 7\nL 1\nR 2\nD 4\nU 3\nL 8\nU 2\nR 8\nU 5\nL 5\nR 7\nL 7\nR 7\nU 8\nR 3\nD 4\nL 7\nU 5\nL 5\nU 1\nD 12\nR 11\nL 5\nD 10\nR 8\nU 12\nL 11\nU 2\nR 2\nD 1\nU 4\nD 1\nU 1\nR 11\nD 1\nL 8\nU 5\nL 11\nD 11\nR 12\nL 6\nR 8\nL 13\nU 7\nR 7\nD 1\nR 13\nD 6\nL 5\nR 10\nU 4\nR 11\nD 6\nU 1\nD 6\nR 1\nU 1\nL 12\nU 8\nR 4\nU 9\nR 12\nD 1\nR 8\nD 2\nU 5\nL 7\nU 12\nL 5\nD 10\nR 8\nD 6\nR 13\nD 7\nU 7\nL 9\nD 12\nU 5\nL 7\nD 4\nU 2\nR 13\nU 11\nL 3\nR 6\nD 5\nR 6\nL 11\nU 6\nD 5\nU 6\nL 2\nD 8\nR 4\nU 4\nL 12\nD 6\nU 8\nD 8\nL 5\nD 12\nR 8\nU 11\nD 8\nL 7\nU 13\nL 11\nR 6\nU 5\nD 9\nL 11\nU 10\nD 13\nR 5\nD 8\nR 7\nD 6\nR 7\nD 2\nL 13\nR 11\nU 1\nD 7\nU 13\nR 9\nU 12\nR 13\nL 2\nU 13\nD 2\nU 6\nL 6\nD 5\nR 5\nL 2\nU 1\nR 4\nU 6\nL 10\nR 12\nL 3\nD 3\nL 8\nD 10\nU 2\nL 11\nU 2\nL 11\nR 8\nU 12\nR 3\nU 5\nL 7\nD 6\nU 6\nL 10\nR 4\nL 1\nU 8\nD 4\nR 13\nL 7\nU 6\nL 9\nU 13\nD 13\nL 8\nU 3\nL 13\nD 14\nL 1\nU 9\nD 1\nU 9\nR 12\nD 7\nL 9\nR 13\nD 12\nU 10\nD 4\nL 13\nR 11\nL 2\nD 9\nR 4\nU 10\nL 2\nD 8\nU 11\nL 14\nR 1\nU 2\nD 9\nU 8\nL 4\nD 14\nU 10\nR 3\nD 12\nU 12\nL 1\nU 1\nD 7\nU 8\nR 9\nD 7\nR 11\nD 11\nR 13\nD 14\nL 5\nD 1\nU 12\nD 7\nU 13\nD 9\nU 6\nR 5\nU 13\nL 4\nD 8\nL 3\nU 8\nD 4\nR 4\nD 2\nL 1\nD 12\nR 11\nU 11\nD 6\nR 12\nU 3\nD 2\nR 6\nD 1\nU 11\nL 7\nD 9\nL 8\nR 1\nU 13\nD 7\nL 9\nU 4\nD 8\nL 12\nD 6\nR 4\nD 5\nU 13\nL 2\nD 11\nR 4\nD 5\nL 4\nU 9\nL 12\nU 10\nD 3\nR 15\nL 3\nD 10\nL 4\nR 2\nD 10\nR 1\nU 10\nL 9\nD 7\nL 5\nR 8\nU 3\nD 9\nR 5\nD 8\nU 5\nD 5\nL 8\nU 2\nR 5\nU 4\nD 6\nR 3\nL 1\nU 15\nR 12\nD 14\nR 12\nU 14\nD 8\nU 10\nR 9\nD 8\nL 10\nR 4\nU 5\nD 15\nU 6\nD 4\nR 7\nD 1\nR 15\nU 15\nD 4\nR 6\nL 1\nR 7\nL 12\nU 3\nR 1\nL 6\nD 6\nR 5\nD 15\nR 1\nU 10\nR 4\nD 13\nL 5\nD 10\nL 7\nR 5\nU 15\nL 11\nU 4\nD 9\nU 12\nR 12\nL 9\nD 10\nU 7\nR 3\nL 10\nR 12\nD 2\nU 8\nL 7\nR 3\nU 1\nD 10\nL 11\nR 12\nL 8\nU 1\nD 12\nL 4\nD 4\nL 6\nD 7\nR 3\nL 7\nU 1\nR 4\nL 1\nU 2\nL 6\nD 4\nL 7\nR 7\nL 15\nU 4\nR 7\nD 8\nU 9\nD 3\nL 5\nU 6\nR 2\nD 10\nL 9\nU 16\nL 15\nU 1\nR 15\nU 13\nL 12\nD 10\nR 1\nD 6\nR 3\nD 1\nL 14\nR 10\nD 2\nR 10\nU 12\nR 10\nL 13\nU 14\nD 11\nU 16\nR 6\nU 4\nR 6\nU 13\nR 5\nD 1\nL 12\nU 14\nD 11\nR 11\nD 7\nL 3\nR 7\nL 9\nU 11\nD 6\nU 14\nD 2\nL 1\nR 16\nL 14\nD 10\nU 4\nR 15\nU 11\nR 10\nD 5\nR 8\nU 13\nD 11\nU 9\nR 8\nD 4\nL 11\nU 8\nR 7\nD 14\nU 8\nD 6\nL 13\nR 2\nL 16\nR 10\nU 7\nL 10\nU 2\nL 13\nU 8\nD 5\nU 3\nR 14\nD 15\nR 10\nD 4\nU 10\nD 15\nR 6\nU 13\nR 1\nU 16\nL 2\nU 6\nL 8\nD 2\nL 11\nU 15\nD 5\nU 1\nR 3\nD 16\nL 3\nR 4\nD 8\nR 10\nL 8\nD 1\nU 2\nR 4\nU 3\nD 16\nU 10\nR 11\nL 11\nR 7\nL 3\nU 17\nD 1\nL 10\nD 6\nL 6\nD 6\nR 8\nU 16\nD 15\nU 12\nL 12\nD 17\nU 9\nR 7\nU 12\nL 6\nD 5\nR 2\nL 17\nU 6\nR 1\nD 13\nR 11\nD 17\nR 5\nL 3\nD 3\nU 4\nD 4\nU 4\nL 11\nR 4\nL 15\nD 7\nU 13\nD 12\nU 1\nL 16\nD 2\nL 12\nR 15\nU 11\nR 15\nD 12\nR 4\nL 3\nR 3\nU 3\nL 13\nU 4\nL 16\nU 7\nD 17\nR 14\nU 11\nD 4\nL 11\nU 9\nD 8\nU 3\nR 10\nU 16\nR 5\nL 10\nD 3\nL 7\nU 9\nR 2\nU 14\nL 8\nR 9\nL 6\nD 14\nL 14\nU 3\nD 9\nL 8\nD 14\nU 6\nL 4\nR 7\nD 4\nL 6\nU 11\nR 8\nD 8\nR 5\nU 17\nR 15\nU 1\nL 17\nD 14\nL 2\nD 3\nL 16\nD 7\nL 16\nR 10\nD 6\nR 11\nU 10\nL 14\nR 2\nU 3\nD 1\nR 16\nL 5\nR 2\nD 15\nU 6\nL 3\nD 9\nR 12\nD 13\nU 17\nR 16\nD 15\nU 3\nD 13\nL 7\nR 12\nU 18\nL 12\nU 7\nL 18\nD 12\nL 17\nD 6\nL 8\nD 16\nL 9\nR 8\nU 9\nD 9\nU 16\nL 10\nU 12\nL 9\nU 10\nR 13\nL 7\nU 17\nL 13\nD 18\nL 6\nR 14\nL 9\nU 1\nR 8\nU 3\nR 13\nD 3\nL 14\nD 8\nL 12\nR 3\nL 11\nR 2\nD 7\nR 14\nL 9\nU 1\nD 5\nU 10\nR 5\nD 8\nU 2\nD 17\nL 16\nD 3\nU 15\nR 17\nD 10\nR 16\nL 3\nU 2\nR 5\nL 7\nU 7\nD 12\nL 8\nR 4\nL 18\nR 13\nL 18\nR 11\nU 1\nD 1\nL 12\nU 15\nL 4\nD 12\nU 13\nL 14\nD 14\nL 12\nD 14\nU 14\nL 6\nR 5\nD 6\nL 13\nU 16\nL 11\nU 7\nR 10\nD 6\nU 17\nL 12\nR 11\nD 11\nU 7\nR 2\nU 9\nR 16\nL 5\nD 16\nR 7\nU 4\nD 19\nL 2\nD 18\nR 1\nU 15\nR 13\nD 5\nR 2\nU 2\nD 12\nL 17\nD 11\nU 8\nR 13\nU 11\nR 2\nU 13\nR 11\nU 19\nL 17\nR 17\nD 16\nR 18\nU 9\nL 13\nD 1\nR 16\nD 13\nR 6\nD 9\nR 7\nU 10\nD 10\nU 8\nR 8\nL 2\nR 17\nD 13\nL 9\nU 19\nD 6\nL 14\nR 9\nL 19\nD 17\nR 17\nD 10\nL 1\nU 15\nD 17\nL 12\nR 10\nL 14\nU 16\nL 17\nU 8\nR 8\nU 4\nR 11\nU 14\nR 2\nL 9\nU 11\nD 14\nU 14\nD 9\nL 10\nU 19\nD 10\nR 5\nD 1\nL 3\nU 14\nR 11\nL 17\nR 7\nD 8\nR 1\nU 2\nR 4\nL 2\nR 13\nU 16\nD 2\nL 2\nR 2\nU 16\nL 3\nD 7\nR 7\nU 2\nL 5\nU 7\nR 17\nU 6\nD 12\nU 17\nD 13\nL 19\nR 19\nL 9\nD 14\nR 15\nL 7\nU 11\nR 2\nD 16\nU 6\nL 12\n\"\"\".trimIndent()\n\n\nfun main() {\n    fun runTest(input: String, knots: Int, expected: Int) {\n        val puzzle = Day9PuzzleSolution()\n        val puzzleInput = Day9PuzzleInput(input, knots, expected)\n        val result = puzzle.solution(puzzleInput)\n        if (result != expected) {\n            throw Error(\"Test failed for knots=$knots. Expected $expected but got $result\")\n        }\n    }\n\n    runTest(example, 2, 13)\n    runTest(input, 2, 6271)\n    runTest(example, 10, 1)\n    runTest(example2, 10, 36)\n    runTest(input, 10, 2458)\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Simulates rope movements based on a sequence of directional instructions and counts unique positions visited.\n *\n * Initializes the starting point as visited, then iterates through all movement commands (U, D, L, R),\n * moving the rope's head by the specified offset and propagating movements to the rest of the knots.\n * Each new tail position is recorded as visited.\n *\n * @param input the puzzle input containing the movement instructions, knot positions, and visited points tracking.\n * @return the total number of unique positions visited by the rope's tail after processing all moves.\n */", "canonical_solution": "override fun solution(input: Day9PuzzleInput): Int {\n    input.pointsVisited[Pair(0, 0)] = true\n    input.moves.forEach { move ->\n        val moveParts = move.split(\" \")\n        val direction = moveParts[0]\n        val amount = moveParts[1].toInt()\n        when(direction) {\n            \"U\" -> input.moveHead(0, 1, amount)\n            \"D\" -> input.moveHead(0, -1, amount)\n            \"L\" -> input.moveHead(-1, 0, amount)\n            \"R\" -> input.moveHead(1, 0, amount)\n        }\n    }\n\n    return input.pointsVisited.size\n}"}
{"task_id": "3", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "doCalculation", "fn_name": "doCalculation", "fn_signature": "fun doCalculation(expression: String, prioritizeAddition: Boolean = false): Long {", "context": "import java.io.File\n\nvar hardcodedInput = \"\"\n\nobject InputReader {\n    fun getInputAsString(day: Int): String {\n        return hardcodedInput\n    }\n\n    fun getInputAsList(day: Int): List<String> {\n        return hardcodedInput.lines()\n    }\n}\n\nabstract class Day(dayNumber: Int) {\n\n    // lazy delegate ensures the property gets computed only on first access\n    protected val inputList: List<String> by lazy { InputReader.getInputAsList(dayNumber) }\n    protected val inputString: String by lazy { InputReader.getInputAsString(dayNumber) }\n\n    abstract fun partOne(): Any\n\n    abstract fun partTwo(): Any\n}\n\nclass Day18 : Day(18) {\n\n    // 21993583522852\n    override fun partOne(): Any {\n        return inputList.map { doCalculation(it) }.sum()\n    }\n\n    // 122438593522757\n    override fun partTwo(): Any {\n        return inputList.map { doCalculation(it, true) }.sum()\n    }\n\n    fun doCalculation(expression: String, prioritizeAddition: Boolean = false): Long {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    private fun doSingleCalculation(expression: String, prioritizeAddition: Boolean = false): Long {\n        val nextExpr = if (prioritizeAddition) singleExprAdd.find(expression) ?: singleExpr.find(expression)!!\n                       else singleExpr.find(expression)!!\n\n        val result = doSingleSum(nextExpr.groupValues.drop(1))\n        return if (expression == nextExpr.value) result else {\n            val newExpr = expression.replaceRange(nextExpr.range, result.toString())\n            return doSingleCalculation(newExpr, prioritizeAddition)\n        }\n    }\n\n    private fun doSingleSum(parts: List<String>): Long {\n        val (x, y) = parts[0].replace(\"(\", \"\").toLong() to parts[2].replace(\")\", \"\").toLong()\n        return when (parts[1]) {\n            \"*\" -> x * y\n            \"+\" -> x + y\n            else -> throw IllegalArgumentException()\n        }\n    }\n\n    companion object {\n        private val singleExpr = Regex(\"(\\\\d+) ([+\\\\-/*]) (\\\\d+)\")\n        private val singleExprAdd = Regex(\"(\\\\d+) (\\\\+) (\\\\d+)\")\n        private val parensNoNesting = Regex(\"(\\\\([\\\\d*+ ]+\\\\))\")\n    }\n}", "test": "fun main() {\n    hardcodedInput = \"\"\"\n        1 + 2 * 3 + 4 * 5 + 6\n        1 + (2 * 3) + (4 * (5 + 6))\n        2 * 3 + (4 * 5)\n        5 + (8 * 3 + 9 + 3 * 4 * 3)\n        5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4))\n        ((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2\n    \"\"\".trimIndent()\n\n    val dayEighteen = Day18()\n\n    // Part 1 check\n    val partOneResult = dayEighteen.partOne()\n    if (partOneResult != 26457L) {\n        throw AssertionError(\"partOne failed: expected=26457 but was=$partOneResult\")\n    }\n\n    // Part 2 check\n    val partTwoResult = dayEighteen.partTwo()\n    if (partTwoResult != 694173L) {\n        throw AssertionError(\"partTwo failed: expected=694173 but was=$partTwoResult\")\n    }\n\n    // Part 1 examples\n    val part1Examples = listOf(\n        \"1 + 2 * 3 + 4 * 5 + 6\" to 71L,\n        \"1 + (2 * 3) + (4 * (5 + 6))\" to 51L,\n        \"2 * 3 + (4 * 5)\" to 26L,\n        \"5 + (8 * 3 + 9 + 3 * 4 * 3)\" to 437L,\n        \"5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4))\" to 12240L,\n        \"((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2\" to 13632L\n    )\n\n    for ((expr, expected) in part1Examples) {\n        val actual = dayEighteen.doCalculation(expr)\n        if (actual != expected) {\n            throw AssertionError(\"Part 1 expression failed: '$expr' expected=$expected but was=$actual\")\n        }\n    }\n\n    // Part 2 examples\n    val part2Examples = listOf(\n        \"1 + 2 * 3 + 4 * 5 + 6\" to 231L,\n        \"1 + (2 * 3) + (4 * (5 + 6))\" to 51L,\n        \"2 * 3 + (4 * 5)\" to 46L,\n        \"5 + (8 * 3 + 9 + 3 * 4 * 3)\" to 1445L,\n        \"5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4))\" to 669060L,\n        \"((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2\" to 23340L\n    )\n\n    for ((expr, expected) in part2Examples) {\n        val actual = dayEighteen.doCalculation(expr, true)\n        if (actual != expected) {\n            throw AssertionError(\"Part 2 expression failed: '$expr' expected=$expected but was=$actual\")\n        }\n    }\n\n    // Extra test cases for Part 2\n    val extraExamples = listOf(\n        \"5 * 5 + 9 + (5 * 2 + 4 + 8 + 6 * 4) * 9 * 3\" to 55890L,\n        \"9 + 9 * 2 * 8 + ((7 * 7 * 8 * 3) + 7 + 2 * 3) * 4\" to 513072L,\n        \"4 * 8 + (2 * 5 * (3 * 7 + 3 * 6) * 9) * (2 + 4 * 6 * 2)\" to 4667904L\n    )\n\n    for ((expr, expected) in extraExamples) {\n        val actual = dayEighteen.doCalculation(expr, true)\n        if (actual != expected) {\n            throw AssertionError(\"Extra Part 2 expression failed: '$expr' expected=$expected but was=$actual\")\n        }\n    }\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Evaluates a mathematical expression string with optional precedence rules.\n *\n * Recursively resolves expressions by first identifying innermost parentheses (no nesting),\n * replacing them with their computed result, and re-evaluating until no parentheses remain.\n * Once flattened, the expression is reduced step by step using either normal left-to-right\n * evaluation or with addition prioritized over multiplication depending on the flag.\n *\n * @param expression the input string representing a mathematical expression containing digits,\n *                  operators (+, *), and optional parentheses.\n * @param prioritizeAddition if true, addition operations are evaluated before multiplication;\n *                  otherwise expressions are evaluated strictly left-to-right.\n * @return the computed result of the expression as a Long value.\n */", "canonical_solution": "fun doCalculation(expression: String, prioritizeAddition: Boolean = false): Long {\n    val maybeParens = parensNoNesting.find(expression)\n    return if (maybeParens == null)  doSingleCalculation(expression, prioritizeAddition) else {\n        val withoutSurroundingParens = maybeParens.value.drop(1).dropLast(1)\n        val replacedWithResult = expression.replaceRange(maybeParens.range, doCalculation(withoutSurroundingParens, prioritizeAddition).toString())\n        doCalculation(replacedWithResult, prioritizeAddition)\n    }\n}"}
{"task_id": "13", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "parsePacket", "fn_name": "parsePacket", "fn_signature": "private fun parsePacket(packetString: String, index: Int = 1): Pair<Packet, Int> {", "context": "interface Day<T> {\n    fun getInput(): T\n    fun part1(input: T): Any\n    fun part2(input: T): Any\n\n    fun run() {\n        val input = getInput()\n        warmup(input)\n        var start = System.nanoTime()\n        println(\"Part 1: ${part1(input)} (${(System.nanoTime() - start) / 1_000_000.0}ms)\")\n        start = System.nanoTime()\n        println(\"Part 2: ${part2(input)} (${(System.nanoTime() - start) / 1_000_000.0}ms)\")\n    }\n\n    fun readInputFile(day: String): String {\n        return this.javaClass.classLoader.getResource(\"$day/input.txt\")!!\n            .readText()\n    }\n\n    /**\n     * Run this code before performance testing. Use this to run code to trigger compiler optimization.\n     *\n     * The default is a no-op method. Override to provide Day specific optimization code.\n     *\n     * Any code executed in this method will not be timed during part 1 or part 2\n     */\n    fun warmup(input: T): Any {\n        //No-op\n        return 0\n    }\n}\n\n/**\n * Day 13: Distress Signal\n *\n * Packets are coming in out of order.\n * Packets come in pairs (one on each line of the input).\n *\n * A packet consists of a number or list of packets, ex:\n *      [[1],[2,3,4]] turns into Packet[Packet[Packet[1]], Packet[Packet[2],Packet[3],Packet[4]]]\n *      [[1],4] turns into Packet[Packet[Packet[1]], Packet[4]]\n *\n */\nclass Day13: Day<List<Pair<Packet, Packet>>> {\n    override fun getInput(): List<Pair<Packet, Packet>> {\n        return parseInput(readInputFile(\"day13\"))\n    }\n\n    /**\n     * Observe each pair of packets. Find the index (1 based) in the list of\n     * all the packets that are in the correct order.\n     * Return the sum of those indexes\n     */\n    override fun part1(input: List<Pair<Packet, Packet>>): Int {\n        return input.mapIndexed { index, (lhs, rhs) ->\n            if (lhs <= rhs) { index + 1 } else { 0 }\n        }.sum()\n    }\n\n    /**\n     * Take all packets and put them in a single list. Add two marker packets: [[2]] and [[6]]\n     * Put the packets in the correct order and find the (1 based) index of the marker packets.\n     * Return the product of both marker indexes\n     */\n    override fun part2(input: List<Pair<Packet, Packet>>): Any {\n        val (marker1, _) = parsePacket(\"[[2]]\")\n        val (marker2, _) = parsePacket(\"[[6]]\")\n        val allPackets = input.flatMap { listOf(it.first, it.second) } + listOf(marker1, marker2)\n        val sortedPackets = allPackets.sorted()\n        return (sortedPackets.indexOf(marker1) + 1) * (sortedPackets.indexOf(marker2) + 1)\n    }\n\n    fun parseInput(input: String): List<Pair<Packet, Packet>> {\n        return input.split(\"\\n\\n\").map { pairs ->\n            val (lhs, rhs) = pairs.lines().map { parsePacket(it).first }\n            Pair(lhs, rhs)\n        }\n    }\n\n    /**\n     * Recursive function to parse the packet out of the string.\n     * Nested [] get their own recursive call.\n     *\n     * @param packetString The entire packet string\n     * @param index the index to start the parsing at (defaults to 1 - all packets start with '[')\n     * @return A pair tuple consisting of the parsed packet\n     * and the index of the lasted visited location in the overall packetString\n     */\n    private fun parsePacket(packetString: String, index: Int = 1): Pair<Packet, Int> {\n        /* GENERATE THIS FUNCTION */\n    }\n}\n\nclass Packet (\n    private val value: Int?,\n    private val packets: List<Packet>?\n) : Comparable<Packet> {\n\n    /**\n     * To check order, look from left to right in each packet\n     *      If the value is a number on both, the left should be less than the right\n     *      If one of the two packets has a number, convert that number to a single value list\n     *      If both are lists, go from left to right comparing each value in the list (left-hand side should be smaller)\n     *      - if the left-hand side runs out of values first, they are in the correct order\n     *      - if the right-hand side runs out of values first, they are out of order\n     */\n    override fun compareTo(other: Packet): Int {\n        if (this.value != null && other.value != null) {\n            return this.value.compareTo(other.value)\n        }\n        val listA = this.packets ?: listOf(Packet(this.value!!, null))\n        val listB = other.packets ?: listOf(Packet(other.value!!, null))\n        for (i in listA.indices) {\n            if (i >= listB.size) { return 1 }\n            val cmp = listA[i].compareTo(listB[i])\n            if (cmp != 0) { return cmp }\n        }\n        if (listA.size < listB.size) {\n            return - 1\n        }\n        return 0\n    }\n\n    /**\n     * We could probably cheat and just do reference equivalence for this problem\n     * But here is a real equals method implementation\n     */\n    override fun equals(other: Any?): Boolean {\n        if (this === other) { return true }\n        if (other !is Packet) { return false }\n        if (other.value != null && this.value != null && this.value == other.value) {\n            return true\n        }\n        if (other.packets != null && this.packets != null){\n            if (other.packets.size != this.packets.size) { return false }\n            return other.packets == this.packets\n        }\n        return false\n    }\n\n    // The IDE generated this one (It's always recommended to have hashCode if you have equals)\n    override fun hashCode(): Int {\n        val result = value ?: 0\n        return 31 * result + (packets?.hashCode() ?: 0)\n    }\n\n}", "test": "fun main() {\n    val input = \"\"\"\n        [1,1,3,1,1]\n        [1,1,5,1,1]\n\n        [[1],[2,3,4]]\n        [[1],4]\n\n        [9]\n        [[8,7,6]]\n\n        [[4,4],4,4]\n        [[4,4],4,4,4]\n\n        [7,7,7,7]\n        [7,7,7]\n\n        []\n        [3]\n\n        [[[]]]\n        [[]]\n\n        [1,[2,[3,[4,[5,6,7]]]],8,9]\n        [1,[2,[3,[4,[5,6,0]]]],8,9]\n    \"\"\".trimIndent()\n\n    val day = Day13()\n    val packets = day.parseInput(input)\n\n    val result1 = day.part1(packets)\n    if (result1 != 13) {\n        throw IllegalStateException(\"part1 failed: expected 13, got $result1\")\n    }\n\n    val result2 = day.part2(packets)\n    if (result2 != 140) {\n        throw IllegalStateException(\"part2 failed: expected 140, got $result2\")\n    }\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Parses a string representation of a packet into a nested [Packet] structure.\n *\n * Iterates through the given packet string character by character, handling nested lists\n * via recursive calls when encountering `'['`. Digits are accumulated into a buffer to\n * allow multi-digit numbers, which are converted into `Packet` instances when a comma `','`\n * or closing bracket `']'` is reached. Each recursive call ends when a closing bracket is\n * found, returning the constructed `Packet` along with the next index position to continue from.\n *\n * @param packetString The string encoding of a packet, e.g. `[[1],[2,3,4]]`.\n * @param index The starting position for parsing within the string (defaults to 1 since\n *          packets always begin with `'['`).\n * @return A pair where the first element is the parsed [Packet] object, and the second\n *          element is the index of the next character after the closing bracket of the parsed segment.\n */", "canonical_solution": "private fun parsePacket(packetString: String, index: Int = 1): Pair<Packet, Int> {\n    var buffer = \"\"\n    var i = index\n    val packets = mutableListOf<Packet>()\n    // when we hit the close bracket, this parse function is done\n    while (packetString[i] != ']') {\n        if (packetString[i] == '[') {\n            // we are opening a new sub packet - recursively call this method\n            val (p, newIndex) = parsePacket(packetString, i+1)\n            packets.add(p)\n            i = newIndex\n            continue\n        }\n        if (packetString[i] == ',') {\n            // On a comma, move to the next item in the list (clear the buffer if necessary)\n            if (buffer.isNotEmpty()) {\n                packets.add(Packet(buffer.toInt(), null))\n                buffer = \"\"\n            }\n            i++\n            continue\n        }\n        // Numbers are stored in the buffer (as multi digit numbers are valid)\n        buffer += packetString[i]\n        i++\n    }\n    if (buffer.isNotEmpty()) {\n        packets.add(Packet(buffer.toInt(), null))\n    }\n    return Pair(Packet(null, packets), i + 1)\n}"}
{"task_id": "68", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "sumFiles", "fn_name": "sumFiles", "fn_signature": "tailrec fun sumFiles(filesystem: MutableList<Directory>, children: List<String>, sum: Long): Long {", "context": "tailrec fun sumFiles(filesystem: MutableList<Directory>, children: List<String>, sum: Long): Long {\n    /* GENERATE THIS FUNCTION */\n}\n\nfun part1(input: List<String>): Long {\n    val filesystem: MutableList<Directory> = mutableListOf()\n    var currentDirectory = \"\"\n    input.forEach {\n        when {\n            it.startsWith(\"$ ls\") -> return@forEach\n            it.startsWith(\"$ cd\") -> {\n                val dir = it.split(\" \").last()\n                if (dir == \"/\" && filesystem.firstOrNull() == null) filesystem.add(\n                    Directory(\n                        \"/\",\n                        parentDirectory = \"/\",\n                        isHomeDirectory = true\n                    )\n                )\n                val i = filesystem.indexOfFirst { it.name == currentDirectory }\n                currentDirectory = if (dir == \"..\") filesystem[i].parentDirectory else dir\n            }\n\n            it.startsWith(\"dir\") -> {\n                val directoryName = it.split(\" \").last()\n                val current = filesystem.first { it.name == currentDirectory }\n                current.childrenDirectories.add(directoryName)\n                val i = filesystem.indexOfFirst { it.name == directoryName }\n                if (i == -1) {\n                    filesystem.add(Directory(directoryName, parentDirectory = currentDirectory))\n                } else {\n                    filesystem[i]\n                }\n            }\n\n            else -> {\n                val i = filesystem.indexOfFirst { it.name == currentDirectory }\n                val dir = filesystem[i]\n                val (size, name) = it.split(\" \")\n                dir.files.add(File(name, size.toLong()))\n            }\n        }\n    }\n    filesystem.forEach { d ->\n        d.totalSize = sumFiles(\n            filesystem,\n            d.childrenDirectories,\n            d.files.sumOf { it.size })\n    }\n    println(filesystem)\n    return filesystem.filter { it.totalSize <= 100000 }.sumOf { it.totalSize }\n}\n\nfun part2(input: List<String>): Int {\n    return 0\n}\n\ndata class File(var name: String? = null, var size: Long = 0)\ndata class Directory(\n    var name: String = \"\",\n    var files: MutableList<File> = mutableListOf(),\n    var parentDirectory: String = \"\",\n    var childrenDirectories: MutableList<String> = mutableListOf(),\n    var isHomeDirectory: Boolean = false,\n    var totalSize: Long = 0L\n)", "test": "fun test() {\n    val testInputString = \"\"\"\n        $ cd /\n        $ ls\n        dir a\n        14848514 b.txt\n        8504156 c.dat\n        dir d\n        $ cd a\n        $ ls\n        dir e\n        29116 f\n        2557 g\n        62596 h.lst\n        $ cd e\n        $ ls\n        584 i\n        $ cd ..\n        $ cd ..\n        $ cd d\n        $ ls\n        4060174 j\n        8033020 d.log\n        5626152 d.ext\n        7214296 k\n    \"\"\".trimIndent()\n\n    val testInput = testInputString.lines()\n\n    fun assertEquals(expected: Any?, actual: Any?) {\n        if (expected != actual) {\n            throw IllegalStateException(\"Test failed: expected=$expected, actual=$actual\")\n        }\n    }\n\n    assertEquals(95437L, part1(testInput))\n    assertEquals(0, part2(testInput))\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Recursively computes the total size of files within the given directories and their descendants.\n *\n * Starting from the provided list of child directory names, the function looks up each directory\n * in the filesystem, adds the sum of its files' sizes to the running total, and then recurses\n * into its child directories until no more remain.\n *\n * @param filesystem the mutable list of all directories in the filesystem to search within\n * @param children the names of the child directories whose sizes (including nested) are to be summed\n * @param sum the accumulated size of files so far, carried through recursive calls\n * @return the total size of all files contained within the specified directories and their subdirectories\n */", "canonical_solution": "tailrec fun sumFiles(filesystem: MutableList<Directory>, children: List<String>, sum: Long): Long {\n    var total = sum\n    if (children.isEmpty()) return total\n    val dirs = children.map { child ->\n        filesystem.first { it.name == child }\n    }\n    dirs.forEach { dir ->\n        total += dir.files.sumOf { it.size }\n        sumFiles(filesystem, dir.childrenDirectories, total)\n    }\n    return total\n}"}
{"task_id": "2", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "sortArrayByParity", "fn_name": "sortArrayByParity", "fn_signature": "private fun IntArray.sortArrayByParity(): IntArray {", "context": "/*\n * Copyright 2020 <NAME>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport java.util.Arrays\n\n// import dev.shtanko.algorithms.extensions.isEven\n\nval Int.isEven: Boolean\n    get() = this % 2 == 0\n\nval Double.isEven: Boolean\n    get() = this % 2 == 0.0\n\n// import dev.shtanko.algorithms.extensions.swap\n\nfun <T> Array<T>.swap(i: Int, j: Int) {\n    val tmp = this[i]\n    this[i] = this[j]\n    this[j] = tmp\n}\n\nfun IntArray.swap(i: Int, j: Int) {\n    val tmp = this[i]\n    this[i] = this[j]\n    this[j] = tmp\n}\n\nfun CharArray.swap(i: Int, j: Int) {\n    val tmp = this[i]\n    this[i] = this[j]\n    this[j] = tmp\n}\n\n\n/**\n * 905. Sort Array By Parity\n * @see <a href=\"https://leetcode.com/problems/sort-array-by-parity\">Source</a>\n */\nfun interface SortArrayByParity {\n    operator fun invoke(nums: IntArray): IntArray\n}\n\n/**\n * Approach 1: Stream\n */\nclass SortArrayByParityStream : SortArrayByParity {\n    override operator fun invoke(nums: IntArray): IntArray {\n        return Arrays.stream(nums)\n            .boxed()\n            .sorted { a, b -> (a % 2).compareTo(b % 2) }\n            .mapToInt { i -> i }\n            .toArray()\n    }\n}\n\n/**\n * Approach 1: Kotlin\n */\nclass SortArrayByParityKotlin : SortArrayByParity {\n    override operator fun invoke(nums: IntArray): IntArray = nums\n        .sortedWith { a, b -> (a % 2).compareTo(b % 2) }\n        .toIntArray()\n}\n\nclass SortArrayByParityTwoPass : SortArrayByParity {\n    override operator fun invoke(nums: IntArray): IntArray {\n        val ans = IntArray(nums.size)\n        var t = 0\n\n        for (i in nums.indices) {\n            if (nums[i] % 2 == 0) ans[t++] = nums[i]\n        }\n\n        for (i in nums.indices) {\n            if (nums[i] % 2 == 1) ans[t++] = nums[i]\n        }\n\n        return ans\n    }\n}\n\nclass SortArrayByParityInPlace : SortArrayByParity {\n    override operator fun invoke(nums: IntArray): IntArray = nums.sortArrayByParity()\n\n    private fun IntArray.sortArrayByParity(): IntArray {\n        /* GENERATE THIS FUNCTION */\n    }\n}", "test": "fun main() {\n    val testCases = listOf(\n        Pair(intArrayOf(), intArrayOf()),\n        Pair(intArrayOf(3, 1, 2, 4), intArrayOf(4, 2, 1, 3)),\n        Pair(intArrayOf(0), intArrayOf(0)),\n        Pair(intArrayOf(1), intArrayOf(1)),\n        Pair(intArrayOf(2, 2), intArrayOf(2, 2)),\n        Pair(intArrayOf(3, 3), intArrayOf(3, 3)),\n        Pair(intArrayOf(2, 2, 3), intArrayOf(2, 2, 3)),\n    )\n\n    val strategies = listOf<SortArrayByParity>(\n        SortArrayByParityStream(),\n        SortArrayByParityKotlin(),\n        SortArrayByParityTwoPass(),\n        SortArrayByParityInPlace()\n    )\n\n    for (strategy in strategies) {\n        for ((input, expected) in testCases) {\n            val inputCopy = input.copyOf() // avoid mutation of original input\n            val actual = strategy.invoke(inputCopy)\n\n            if (!arraysContainSameElements(actual, expected)) {\n                throw AssertionError(\n                    \"Test failed for input=${input.joinToString()} using ${strategy::class.simpleName}.\\n\" +\n                    \"Expected=${expected.joinToString()}, Actual=${actual.joinToString()}\"\n                )\n            }\n        }\n    }\n\n    println(\"All tests passed.\")\n}\n\nfun arraysContainSameElements(a: IntArray, b: IntArray): Boolean {\n    if (a.size != b.size) return false\n    val freqA = a.groupBy { it }.mapValues { it.value.size }\n    val freqB = b.groupBy { it }.mapValues { it.value.size }\n    return freqA == freqB\n}", "description": "/**\n * Rearranges the array so that even numbers come before odd numbers in-place.\n *\n * Uses a two-pointer approach: one pointer starts from the beginning and the other from the end.\n * The left pointer moves forward when it points to an even number, while the right pointer\n * moves backward when it points to an odd number. If the left points to an odd and the right\n * points to an even, the two elements are swapped. This continues until the pointers meet.\n *\n * @receiver IntArray the input array to be reordered\n * @return IntArray the same array instance with elements reordered by parity\n */", "canonical_solution": "private fun IntArray.sortArrayByParity(): IntArray {\n    var i = 0\n    var j = size - 1\n    while (i < j) {\n        if (this[i].isEven) {\n            i++\n        } else {\n            if (!this[j].isEven) {\n                j--\n            }\n            if (this[j].isEven) {\n                swap(i, j)\n                i++\n                j--\n            }\n        }\n    }\n    return this\n}"}
{"task_id": "89", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "minCost", "fn_name": "minCost", "fn_signature": "fun minCost(basket1: IntArray, basket2: IntArray): Long {", "context": "// #Hard #Array #Hash_Table #Greedy #2023_07_07_Time_746_ms_(100.00%)_Space_60.5_MB_(100.00%)\n\nclass Solution {\n    fun minCost(basket1: IntArray, basket2: IntArray): Long {\n        /* GENERATE THIS FUNCTION */\n    }\n}", "test": "fun main() {\n    fun assertEqual(actual: Any?, expected: Any?) {\n        if (actual is Number && expected is Number) {\n            if (actual.toLong() != expected.toLong()) {\n                throw Error(\"Assertion failed: expected=$expected, actual=$actual\")\n            }\n        } else {\n            if (actual != expected) {\n                throw Error(\"Assertion failed: expected=$expected, actual=$actual\")\n            }\n        }\n    }\n\n    val s = Solution()\n\n    // Original test: minCost()\n    assertEqual(\n        s.minCost(intArrayOf(4, 2, 2, 2), intArrayOf(1, 4, 1, 2)),\n        1\n    )\n\n    // Original test: minCost2()\n    assertEqual(\n        s.minCost(intArrayOf(2, 3, 4, 1), intArrayOf(3, 2, 5, 1)),\n        -1\n    )\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Computes the minimum cost required to make two baskets identical by swapping items.\n *\n * The function compares the counts of each integer in both baskets, determines which items \n * need to be swapped to balance frequencies, and calculates the minimal swap cost. A swap \n * can be performed directly between two items or indirectly through the globally smallest \n * item to minimize cost.\n *\n * @param basket1 the first basket represented as an array of integers\n * @param basket2 the second basket represented as an array of integers\n * @return the minimum total cost to make both baskets identical, or -1 if impossible\n */", "canonical_solution": "fun minCost(basket1: IntArray, basket2: IntArray): Long {\n    val n = basket1.size\n    val map1: MutableMap<Int, Int> = HashMap()\n    val map2: MutableMap<Int, Int> = HashMap()\n    var minVal = Int.MAX_VALUE\n\n    for (i in 0 until n) {\n        map1[basket1[i]] = map1.getOrDefault(basket1[i], 0) + 1\n        map2[basket2[i]] = map2.getOrDefault(basket2[i], 0) + 1\n        minVal = minVal.coerceAtMost(basket1[i])\n        minVal = minVal.coerceAtMost(basket2[i])\n    }\n\n    val swapList1: MutableList<Int> = ArrayList()\n    for (key in map1.keys) {\n        val c1 = map1[key]!!\n        val c2 = map2.getOrDefault(key, 0)\n        if ((c1 + c2) % 2 == 1) return -1\n        if (c1 > c2) {\n            var addCnt = (c1 - c2) / 2\n            while (addCnt-- > 0) {\n                swapList1.add(key)\n            }\n        }\n    }\n    val swapList2: MutableList<Int> = ArrayList()\n    for (key in map2.keys) {\n        val c1 = map1.getOrDefault(key, 0)\n        val c2 = map2[key]!!\n        if ((c1 + c2) % 2 == 1) return -1\n        if (c2 > c1) {\n            var addCnt = (c2 - c1) / 2\n            while (addCnt-- > 0) {\n                swapList2.add(key)\n            }\n        }\n    }\n\n    swapList1.sort()\n    swapList2.sortWith { a: Int, b: Int -> b - a }\n\n    // visite swap list\n    var res: Long = 0\n    for (i in swapList1.indices) {\n        res += (2 * minVal).coerceAtMost(swapList1[i].coerceAtMost(swapList2[i])).toLong()\n    }\n    return res\n}"}
{"task_id": "44", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "parseStacks", "fn_name": "parseStacks", "fn_signature": "private fun List<String>.parseStacks(): Map<Int, MutableList<Char>> {", "context": "interface Challenge<Result> {\n    val name: String\n\n    fun inputName(): String = name.replace(\" \", \"\")\n\n    fun testInputName(): String = inputName() + \"_test\"\n\n    fun testInputName2(): String = inputName() + \"_test\"\n\n    fun testResult1(): Result\n\n    fun testResult2(): Result\n\n    fun part1(input: String): Result\n\n    fun part2(input: String): Result\n}\n\nclass Day05 : Challenge<String> {\n    override val name: String\n        get() = \"Day 05\"\n\n    override fun inputName(): String = \"Day05\"\n\n    override fun testInputName(): String = \"Day05_test\"\n\n    override fun testResult1(): String = \"CMZ\"\n\n    override fun testResult2(): String = \"MCD\"\n\n    override fun part1(input: String): String {\n        val challengeSetup = input.split(\"\\n\\n\")\n\n        val stacks = challengeSetup.first().split(\"\\n\").parseStacks()\n\n        challengeSetup[1]\n            .split(\"\\n\")\n            .filter { it.isNotBlank() }\n            .map { it.moves() }\n            .forEach { move -> stacks.applyMove9000(move) }\n\n        return stacks.evaluateChallenge()\n    }\n\n    override fun part2(input: String): String {\n        val challengeSetup = input.split(\"\\n\\n\")\n\n        val stacks = challengeSetup.first().split(\"\\n\").parseStacks()\n\n        challengeSetup[1]\n            .split(\"\\n\")\n            .filter { it.isNotBlank() }\n            .map { it.moves() }\n            .forEach { move -> stacks.applyMove9001(move) }\n\n        return stacks.evaluateChallenge()\n    }\n\n    private fun Map<Int, MutableList<Char>>.applyMove9001(move: Triple<Int, Int, Int>) {\n        val (amount, from, to) = move\n\n        this[to]?.addAll(\n            this[from]?.takeLast(amount)\n                ?: throw IndexOutOfBoundsException(\"Cannot move $amount crates from $from to $to of $this\")\n        )\n        repeat((1..amount).count()) { this[from]?.removeLastOrNull() }\n    }\n    private fun Map<Int, MutableList<Char>>.applyMove9000(move: Triple<Int, Int, Int>) {\n        val (amount, from, to) = move\n\n        this[to]?.addAll(\n            this[from]?.takeLast(amount)?.reversed()\n                ?: throw IndexOutOfBoundsException(\"Cannot move $amount crates from $from to $to of $this\")\n        )\n        repeat((1..amount).count()) { this[from]?.removeLastOrNull() }\n    }\n\n    private fun Map<Int, List<Char>>.evaluateChallenge(): String =\n        toSortedMap().mapNotNull { it.value.lastOrNull { c -> c.isLetter() } }.joinToString(\"\")\n\n\n    private fun String.moves(): Triple<Int, Int, Int> {\n        val parts = split(\" \")\n\n        return Triple(parts[1].toInt(), parts[3].toInt(), parts[5].toInt())\n    }\n\n    private fun List<String>.parseStacks(): Map<Int, MutableList<Char>> {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    private fun String.crates(numberOfStacks: Int): List<Char> {\n        return substring(1).mapIndexedNotNull { index, c ->\n            if (index % 4 == 0) {\n                c\n            } else {\n                null\n            }\n        }\n    }\n}", "test": "fun main() {\n    val it = Day05()\n\n    val testInput = \"\"\"\n            [D]    \n        [N] [C]    \n        [Z] [M] [P]\n        1   2   3\n\n        move 1 from 2 to 1\n        move 3 from 1 to 3\n        move 2 from 2 to 1\n        move 1 from 1 to 2\n    \"\"\".trimIndent()\n\n    // Run part1\n    val testResult1 = it.part1(testInput)\n    println(\"First test result: $testResult1\")\n    if (testResult1 != it.testResult1()) {\n        throw IllegalStateException(\"Expected ${it.testResult1()} but got $testResult1\")\n    }\n\n    // Run part2\n    val testResult2 = it.part2(testInput)\n    println(\"Second test result: $testResult2\")\n    if (testResult2 != it.testResult2()) {\n        throw IllegalStateException(\"Expected ${it.testResult2()} but got $testResult2\")\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Parses a textual stack representation into a map of stack indices and crate contents.\n *\n * The function interprets the list of strings where the last line specifies the number\n * of stacks, and the preceding lines represent rows of crates. It initializes a map\n * of stack indices to mutable lists of characters, then iterates through the crate rows\n * from bottom to top, distributing crate characters into their corresponding stacks.\n * Only alphabetical characters are added to stacks, preserving their vertical order.\n *\n * @receiver List of strings representing the stacks layout, with the last line containing stack numbers.\n * @return A map where each key is a stack index and each value is a mutable list of crate characters.\n */", "canonical_solution": "private fun List<String>.parseStacks(): Map<Int, MutableList<Char>> {\n    val numberOfStacks = last().split(regex = Regex(\"\\\\s\")).last { it.isNotBlank() }.toInt()\n    val result = (1..numberOfStacks).associateWith { mutableListOf<Char>() }\n\n    reversed().drop(1).forEach {\n        it.crates(numberOfStacks).forEachIndexed { index, c ->\n            if (c.isLetter()) {\n                result[index + 1]?.add(c)\n                    ?: throw IndexOutOfBoundsException(\"Failed to insert $c at index $index into $result\")\n\n            }\n        }\n    }\n\n    return result\n}"}
{"task_id": "81", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "react", "fn_name": "react", "fn_signature": "fun react(polymerInput: String = input): Int {", "context": "class Day05(val input: String) {\n    fun react(polymerInput: String = input): Int {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    fun fullyReact(): Int{\n        val units = input.toCharArray().distinctBy { it.lowercaseChar() }\n\n        return units.map { testUnit ->  input.filterNot { testUnit.lowercaseChar() == it || testUnit.uppercaseChar() == it } }\n            .map { react(it) }\n            .min()!!\n    }\n\n\n    private infix fun Char.same(other: Char) : Boolean {\n        return when {\n            this.isLowerCase() -> this.uppercaseChar() == other\n            this.isUpperCase() -> this.lowercaseChar() == other\n            else -> false\n        }\n    }\n\n}", "test": "val input = \"iIJjQNnMDdmqiIwWxaALlsnqwWOuSsUoQNbpCcPNnBSXQqqBbQzQqZHPphPpOoHohcCHOzEeMmMgSsTtEeVvSrRJjyYsGkKkoOKmPpMmDzZDddzZAaaAYeEyrgGHcChwWwWXTtxaARZTDdiIFfthlAaLxJjXwJjWmfcCFZzMFfJgGjQqSswYyoOmMWMmnuUnkKWwNLEeaAluKkIGgiUyLLzZllpPoOoOeEbBYpPANnaUuKNtTOonHRqZzQrgGiZzyYIhkWwNjXxBbJpPSHhIkKyYHhiuUkKRrBqQbCcjJOoBlLbZnNzDuUdppjCwWcvVlLJoOEeVvPgGGCcgjSsJZzrVvGgrkKpPRRkmMKhHNnPpPzZRrQjJDWwUudVvSsqNvoOVqQaAsSAacCnpPPcCJIijIenNmMoOEipDhlLDzZGgrRDdeuUEDwlLUuWzFfZLlimMIjJBgGWWwwuUzJjnNZmMnNbQqgGhgfzZFGHPpdgGXxckKCVvWIiwqWwQsbBPYkjJqQhHbBGgzZpPZEezyYjJrRXxMCcmiYyIKypnvyYVJjcGguUvVidDICNcSstTCmAaMqEeQqQFSOMmorRsZzFfNnKkuULfTtFfCcFaAlqQnQqaLlAnNjJrRyYVvNDdrRQqoOAaFfxXBgGEebHjrRJhwWUbBukKfibuRrUHhiGgwWLxXlIPpBMKkmOowWDduUKkMsxXDdUutTRrSYymzZDCcVvgGrgGCRrchHmMRIiPpvVGoODdgdcpNwWqQEeSsnPszyYFfZScCaAQqziIZAaCgGvVpPSsPpmYrRJIirPpRsLaTtWwAldDSNnOwWojdrRDHhfFIiTsStLltTyCyDdYrgGYyRAacqxXIiuoOUtvVXxmMFfTEvVSsewGgJjWPpXYyxqQemWtfFTmMwMoOEQwWAWwvVdDEeLlUunNaIikKsyYYyKMmkJjSjZIizpPkQUJjnyYNEpPeXPpwjzZJWuTtyYeuUXqQqDdxEUxSFfsubHhBqSoOsFrmMRuUrmMaAUuUuEeOoRsaPpAKkPpFfTtSLUuAaJjHhlyYDjJkKZQuqQUOKkoNCcnDmMLlYyzZNyYnpPlVvzZLgGdoRrOqrRVvkKmMJjzZDlkKLCcdDdhHqQUoOEemMuVDdvzcqQCPpjJZUaAwWuZjJBbzuGgTjJtXxZzUzGgApPaMmYyaAMmrjJJjRfDdFaAdTneBbZoOhHBbzhHEMmrRbhHBeyeEUuGjJOogYEMmNGgPpKkJAaUuqUuTviwWIgGziIZpMdDhAaEeHmPBbHhBEehDdQqAsSaHGoLlsSOfFOogHhxXRrLlMmfFJgnkuUMmQqlLjJKLlRrIbBwZzHhuPnNpDdUUuWiNnNGcCjwWweLlRrRrIitTRrEeYySseEBbuUEAAaaXxxSnNhHmNnFfkKMswWUuUDduyYgGOTtoXNbBJjMmwWnLMmsSlulLUZzeEoOPYBbyHheTtETtYygGGmMgpoGdoLlqQOYyDTtpiIsSrRDRrdwWPIqQwWxiBbIezZEgxJjuUXaALlGkKBbzZHhEeyYXXQSsqxkdDRrJbBjXxHAaMkKEepmMyOgAaGoYlaPpALPmTvoOwWVVnNlLvMmvViItNzZWwkKzZnyzLlZlLImMkuUYyKIiOoHhEeRIitTkkKKyYtTdVRrvqQiIQqNLlQFfqtTQqbBCiIQqcnbBDczZzZfFCcCocCOafFAdqQhHDwEeWcCoOlLHSswuUJjySzZsiIyYwWBbOoYVvIivVWqQMNnmUEevVhHYykjJKcvgGVCSsuyYuUKknjJNMmBbuUYyCcdDpPimsSBPpbVviIsjJMmccCjGgJQqNnjfFJTXxtKkVvfFfFxlLhHXMmEexXqJjTtLlKbBkARgAaMmuUlLGgGvVWHhwPBozZObpPppPxXrRVvoyHDdhXxHhYatTApPAaOzZrCaApZzoVvOtTPHCcBbrHzZVvhBHhbAMmaQqxXSsRaABbIoOitoOEeTbDdyYzZBuUqcXxCiPpIOoCcQtDKkdmMMBbmiBbFwWsSzZfZzHdGlLCcgctTynKXxkNYHhGgpPAanZcCgZzBbcbBOoCGaAWFfDdPNYynyzpPZojJOVzZvssdDPkNnqcCbBBpPbOlLhHWHWwhwokxnNXKIiuUmjJMwWNnRrwEejJWUuQzzZFOoZzfXcDdCxrLlhHUuUxWwyYXubBGAcYyUuCPoOjJorRWwbBgGPgGpbBtrfFsDdVvXxlcMmAoOVvaOoCKkoOrRDdHhjJFfqQPoOphCcXxHZzpiICcHhqhHNRrnSbBeEsDLldQPXxELleUumUuXxMtTdPZHGghxXzkKZzkrRKfFNHhnpioOjJuUmMbBSPpQqAaDdmhHMEesIrRaAWwTNnYyfFDdrRNnSYBWwhHWwhHWXCcHxPpXhDBbdxyYWwKkHtThUulLWLllLgGNnwTmXxMttThHAuUqQaDfFYydpOoPkKwSsQqsUutTiiKkIQqSIikEeaAroORpPcpiIPCKcCsxXAydDYjpPJIidDrRNJjHNaAnhpfFgGPnSsTGgtOSsuRrUPOopyYzZKWUuEiIeKkFfFfsSCcwMmBDdbKGzZISsivVLEeNoOiInlxPpdDXWwYypPgGBbiIzjJCcTtjJZzZgAaPlLreERpDdanfFNQqOoAdDUfFuPOJjoydDeEQqYeBboqQgGOpPENnGgMmVvSsoOlLeiIEFfEbvtTwWVEmBbYyDdBLGglbCcNnarRAVvEePyYFfpBbGgWwOodDiLlcCiIIXoOxmCoDiIdcCbBimMIOopdHhrvVYyRrWwkeGNngrREKDduZzUqHhQzZRIXxJkKaAGdXxDIiIipxXPrRaaZzATtABbwlLWgqtTdDQxXwOoPpVvSsNnOojJUuWlLdDKkdnNDZzFFPpfIiWwfnIiNiIwStTsHhFfSsMmEeSiIVFfvzZVvgvHhVCneaAEqQNcGRWkKwrhmMfFrKkPpmMhHRPKNnkpGgEuwWtPpuUAaTEegqXUuxkKQGHhUepPsGgSrRZzoOAjJahHraAbdWwDxbBPpXbrXxXxFfsSYylLLhHLCcoYyAadFfWopPOwufFgroORgGSLlswWxaAXGTtOoEIielLUhHzcCXcCxOokxXuUnNKUKkvVEcCeuBwGgGgXxgGNnuBbJNnjyDdkKYNnUWlDdyYRrbBLIiCclLOeEQqysSYoVvaJjIiAZFfvVzsVvSbTUNnuTtTpOozZPLltMmGgSCcsJjpPSsYyxXtdGgDOoZlLsSsmMSkKXxktTXGgxBFfKkbunNZzLldDVQqvURriIWwcCvgGgGgGVylkAaLEeSslKdDnNLvVjJrRqQGgRkGgKrLlwWGgcUukaAyYtmMLWKkuYyUwTyYtStTZjJMmzigGIHhzZLoIiOlslKkmMOoKSfFnNiInYNnyNmqQkGgKElLWwCchpPHNnnNeHQqhVvlvVCcrTIiiIOoCDdcqfFQYyFfmMBbcCMmEMTtqSsQmBrRbJtTjDQqdwLlWlSsLBZzeLjxXENnQqbBeEemMJQuAalSsLWZzUazZAdDgGZsSzEeuHpiIOyYZMmDdrRzXxoOyEMxXmeBbYeFvVfvVgGkKvVTtoOEeEhaARrCcVvzZHoTtOFfZzfRrmMJPpjqQFnNSsFJjrCKkUqvVQvVmMuVvUuZzDPhHTuUtoOFcCuUGVvgfzZMbBgGSxJTtrhHMmbXxPplLLlRNNnnrVvQhHqBpuUPrRdurRUDrbKNnhTPMmpZXgGxgMmzuUZxXGfvVFztHuUNnquUoOUVvuvwWrRmCcMVXxuBgGiTtTtcZFfloORrjJuUCcXxzjJZjZzaeEArRnCcncwWXxXxUueEWldDdZztTDBbLIiYBbohHOzjJGgMdDmSgyYGWYcChHrZuUGgzRNkKQqTzZtqQqVvQvOoYTQqZDdzZaAzBbsSKkWqaAQwAakZzXNngtTNnGKkcrRCmMSKksiIZzXGgxHhSszXTbBtZzrRIiIiIijrRJMmIixxwuUWYyVvimMuUuUYLzZHhlBKEekgGGIigjUuYqRrbBLEepYycChHItTkKZzTtjJMmMmWwHSsgeEHhGWwRxXPpGWwQqgKhlLHkRmMrvdDVPrRegGNnEwqQXCTtMWwmpYyPciINnxefFEWOtTUuLlSsamMZgGzKkASoXWwxeEOsvVrRsEJjeEejIiJSqWwcCfpPAaFfyYhHFeqQOuUorklVePCcQHhzZhefFETtNstTSnUzZUEDdeuwWQTtquuUDdHEeRVEevkKXxKxrRkwWKXGLljzZGCcgHhWcCwJgEeNnkwKTtXxkWfFCoZvVzqamMAQcCXxEeQqiARraBbCAalLWwcIOSsoOkpUtmMTuPAapBGKkwWgbPCcLlpghRrHGPiIKkHhEesSFOgGGgozRrZFfFyrRYwbBwWoGgRrrVvaRrARdzZDOWFpQZVviIzqefFKgGkoOErRUliILcYyYKkKkIrjJPRMmjOoXxJQLlJjwwWWkPpqnlLEeNQzZmHbBcCjJZOFfjJnWwTtNogGEefFVvsgGYjbBJdDOoPNnUuKkxEevVWuUwcCjjiIJQqJufFUmMOosxXRrbYYcCymTcQqEerRJjTtSsCKkeEbYyaAOoqdDsSVHhvIeECciWVAaxXHhlLvmMRYyrvVpYyvVPpRpFQqkKfPqQzZSsmYGmMgWwyTthHPpChHcxXmeExkKtctTCTmMmMMrmXGgNhHsSoOadDNPpFfTtnAWcSjJsSyhHYlLskKtTbBFmMrRcCbBpPfpPJizZyYKkjJLBblsHFnNxXfEPpazZARresSBbIihMmbYyVvaPtTfZzeENGamMBGiIgbCqQffFEeVSsgbSJjYvmOPpoBbMXxRQqRrusSsNnZzSvpPHhQqBbVvuUoOvVjJaACcinNAaIlLOoQqBApPVveEaODFvPnvDdVhoOHYSpPsfFEJFfjeLlLfFnXxuUNxfSswWPpFsSDJjdCcUSBbBbfFfEeFCcCcQbBXVvxqPwjPBbpopeEUhzVvhRrHZHaAlLcEeCnInNAaARrlLstTStTxpPXmMmlLMmMaKkRrQqHZzZkKzbBKkhVvnNzZMmbrRWwBLkKlLlULloOoOuHXxhQEIiesgTyYVQqIhfFRjJuqQUKAaIikeEKkLlELledAQqYyaHlLhDvwBbWTgGpPyYtxXtsNBbnNDdSEVZzesSyibBIYirbBRvVnNGgfpPLlFgNVvnEPuiAaIJrRjYGgPKEedDSssSvaAnNlLOoVPpdkKvVkKFflLDZzGgkKSUomMOustjQqeiIETtUBbjJUuNnqTIityYQVOYyoYymVdDjJAaxRrYnXRrxOoHrRhDdpfFPAaLNnPplwSnNpPzOlLowFfWBbZIjnNdJjiIDVCcUuHRVvrXnNHRrhyYUXxujLAallLRAaTtuHhdPJjsSpsScCjJMVvmlLowWOKkbJjBYyhHhiuMmUjPkKpnNJWCVVvLlvsSXxOocUPbBtTpeEuwxBbXzqQOoZZzKkxXMmznDPpiIRrdNgGYIyhHYoOMGSskXxKMvVmZzdDgDdVcxXNnDWXVvPpxeEDdDOoVnNvvSsOogGxeEDdsBbSWwxXVvXmMspPStTBlLbaAgOhRBhHbLnNlDdrrRHxXAjnNJZzaSOoszZAajnNLcsSCiIlTrRtpPGUrOoAaMzZmRhlLrRrbBEGhHQquUNngGFkjJqQKINnipqQPWwoObtTtTZznNIifFcLPpIDdBNyudPpDUYsKkSdBXxYJjyDdSsIibPpULwWAaOnqXLHhlfFaAVvDwWdxXQYQqyqBDdlLgiIGbdWwEeUgGbBJjuDBPpbYyCWwHhxhbzZCcSsuUChHlrRLRviITtCfUuTtjJFGgcVQqDnujmJeEbTteHhHtThEPwWpSnNXxnNDSYyeEsTvbBVtdWZzwcxXbjOEeozZyUueXxrRmWUjJuVvwhyYiZzmMILlmIiMwWHtThEezEeZNnIirEcCejJnNTtOoNSsZznuUKxXkjJGgZzUGguAtTaQXxoDdBeEjJgGWwbgGrRrRZyghHGeEQzRrDdxaaACcLlAnNQuXxKkRrQqDoOoeEOdDdPpUQqqCSscvJjQqiINnVoOXxhHoPlLxXplTtWqQTtNnwAaDryPpYRsSdDdDKkZzjJYjJMmKkkKyBrRuUBbAxXNfZRrGAaftMmQZztTpPHhSYyhHAauUdDkKTttQqirRIWwVvThHsPphHVvQyYqbLlBvVRrxDIEMCceEHwWyYbzuUZdDVbBvjJDiIUudhqAaQxyYQnndFfDJjTfFjJIUuitpPIANiISZzDdZzscCHhdDiyYHhISLlLPpVdDoOvgGliIiInUuNMARgGraJjmgpPGPEUuYMmfIixVeUuENqQYxXmMXxoaCcOoADJjdLdDCWSSwWbIifFtjJTBWwPrRpsdoODiNrRnzZwWoOmmMMFfIaaLlmMQNnOowHhWwpPnyYfFHhNWqPpGdfFaCcyYpPLNnvVlPWnvNgGnAarsIiFfPpYyqQpsSPJYhHyjCcWMmZzSswZZTSskKEeDdFfvIYyiVtvVASEEeekKCcsXxKhtTjJHpPfFkaASpZzPAlkKLdDaNnIiAvVnyYFxJsSjWwdDXfIgGQMmeEWrdDYydDSRrJjgIrRxXiMmmwWMLloOGTtBbQqnNtOoTLlTkIiBUuWwbKqSskkKKGCOxXyyYvVzZXxhQqCcTBbRQqrLKkltFfANUuBbLlUunpcQqtTsSYaARZzaAwrEaAfFVvsGgFfXxHZzOoGAaViIxXGekKzZEgYyNFfLlnAXbmpPMDdeEVTmlLMpIAaieQJjjgcvVOoCcCQNxXniKkcCiNnIqQGBbgeErRDdshSsHSUAaFJjfjnNJukKAaIwWOnmiknNxXKIMfUWwuPpuVvpdDPIidFuUfFfMNvVgiIGzZzZnfFmkKXxuUBbBbbBjRritXxToFfWwudDUwPZzwWpWDfFdPCdDXxYypiIdDeEmiIejJhXxqQlzxXZLIiHYmMqQkqQrmMRlLDXxFUufFaQqAgGuUJzZVJKkjfFAntTsOvxXdDVoSsSNoOjeEdDRrlSYhHRsnNHuhsSHjPpJUAahKMmuUwxMekKXxGXJjbBHhzZcCpPGOnDdNOqQEerRgGYyoomGgMDdgSsTVvtZrRyxXTtTKkpPtsSIijJsSFXxfKkXxJjJjKkYylLYzYyTyhHYuUDgGdDWAaSoehwGgugJjzZJMmWwkKrRLlZftTFfJMmfLzAalnNbBvbBiINcAbBaAobPfFIiptTBfFKNniIkKakIQYykKKpqQLleEPkFnZzNrRJiIpWwlLQPpEeRmMQqrdWaACcUuwcCNnWmMDdYJDdxcCXUuOoLCccmMpPzZQfxafkKmMOdlBbVvkKOokMfFAalOoLkKAbHcChBaFSwBMmbmOPjfwWFJSsdkKAWwIiwWuGiIgUoOSsacJjrwWqqCcQVvMmPpcCcCWbcCRrkNZzuUnlLPpdDGgxXnDdEeCcNKzZnNVvOAHhiIatuUtTtenNEKkJtGgTQEnNWwkKuXvVTtxvVtrRFfCbrRBVGgqQvLGgwWUuDdqVvQMPpwUuWmlPSsdGgPgGiwWIOouUCyGseEDdyZzYSgAklLKyoOZrRzQxXcCWHjJrMzZmRIiPNnpPuUuUSspoCcOjJUzZuFfHNpRzZrcVqXMmxiEevVqcCQzZOoIYywWYykKFgGdUuqQTmMtsDdSPpzZPvVpIkKiIzDYydoOCtqQKkTtPpqQTcduUsSkKDuJjUJXHDdNnhxaWMmwLYsSyIiFpPfvFfJiIqQvgtTqQGgGJjMOUQqlkNYynKwWOYyNGhHgxXlLnrOoEGgfFeRcSHhstYZRrpXkKxPomgIilxXLzqBbrRxUlLeEuZzNnPeDduUuJjUXxEeEHJjMmdDhEwWepsSXRvVLOoJjoONcCNFfumMUnNnnnKkdhHmMDheEntyYezZlLefFfFPpEvVftTgGFeEAzZYLLlKFIifCgfFGRrtLlTzZKkqQNnpnNtTAaynNCdKroORkwPpEeWfMmaUuAnNFqQflLKGwSsWgQqXxEaAeewkKnNCiIcWaocCOAKkcUrRLTtaAYyYylAabhHfFNnZzZzUddDlLUmUuMurmiIMBbRrRUUuctTgvVrRGcPpetTzFfYWwBOobHrRvbtLlTBbBgaAqQbdCcXWDUWwIiAIifFHSsLhHnEsSsSaaABUuIwWlVvLGgwWQeEqdDztTZzhUtTuidnXiayYAIJjvVxaAWpPTgGtUuPpaSsAweseESHhpPEPqQOobBpiISBtsqIghtTwWQqzZumMhjFfJHfwWQqTtfjJwWFoSGgsORJjUurMCcRqQrxXGpuHhUoxXNnuUdbBDOJMbBXDdxKtTJjEekYyetaAyYTEmtzZTNpGghHndDvVNAaYOdDJCcjUujoOJwWKkNnKkSsaAoKBQnNsOoSQzTFftWMSsmWVuUfFQaQqFOofAmzZwWsSMLldDzZQqfPOEjAoOFfsSEmcCkKUuwsSWjJSsLGhHvnvnRQqrsSERroQwWJbGgLlDdRrbBaABVUuvxXKkqQzZDdLlHhzZjtUuxtjJTBFfbCdfAVviMmIuelEeLVamGgMmyKkochHSsPpgzhHSMCoDvVeyYErcCRGgsSdQqzdIiKkQqYyDZFeEyYRrvrRVJjfLlWsSwiaAIpKkPpfpPoOFGgPqQpSSoOssvxXVMjNnLlJuUpxSspPXPweZILlmMkKuNnFfZztTeECdDdoVnsSLlJjlLRrNTtsYyKktThHnNeuUuteENnTdDQqoOGaAxytdDzZTmuUPhFfHkpZzaAVvPYyzGgYyAuUmMJjiImMMKkmKkacCHrgGDxXzZWQtVvThHqDSfFskKWtTfFdcCDzHhIfFrRGgoXxOrZzRoSmMZkKzYynZztBbhWwHTiwWIyYtTFfBofFgTtrWwbBRMmJjKFxXSsTtTNQqnFfIiDdIiTtCtlLNYyjJnTgbBuUBsiISRrEerRMjvVJkKzCzLlrFfwWRZEeTtdDkKSsxXmYUHhYyuNnyFTlAaLLGgGgUuHQqhUNvnNMmTPfFptPpVBmvVuBbvVAaoOgGQgMmWwFYykKfBRHgGIihrbAabBBzZWZzwcCvmCcRrqQKkCkKSsPZfHhFyYNnqQnNBdDbGVTeYynNnNSsxHhHhMmXzfFkSYywdDWaAFTtfVvsGgkKvwqpPsSqmMWwBbQoFfOGxXTiItAwZzBIJjiMXwWuUWwlLxVaAvmlLPpYybnAmdDNfFBbeEnHhifeTnBeScCrmlLQqZzSLlsgGqQpPMJjhHRrqQsSaAgGIrRixXyPvAYyaVgJFIifjFpPfcClLmtTGNnUCcaAusSgMnNRDdjsvVSJOogGClLzZDdIifafnMlmmMkKCSsiILluxXUJPjJpzZzqNjDdxDNnGgdrsSABkmMAscCuUrRKkwWsSDdItRrTchHSswQqjJqWwQDNHhaAnpHwWwWHhXxhbcCQjJqBbDdbkgGEeKXxBfFHhQeEqZzCIiuBzdDVfFvwWZesSGBqQdDboOlLEeysSYJxXuUjgLlGgGgJjVHhvMLlmEETIikKteBaYyAqQnNoOBPJCcEYyrRTcqUubBQCcWwCiIRrsRdOiIoLlGvOoVgaaAADezGUkPQroORTGxXgaAhWwHAaSswdDWKzBbQtTqPpUhVvDLFvVAaLRDdgGrqIiQgGlKPpkZJjzWwJIJiDdhHDTZzaKeleELrREjexFfXOtTtfFTMIepPESYoOVvysCMVvrwWcCYOSIVvAbBtTaheAaziIZEHIirRirRswWvaiLRrCuBYDdaZBpPbFuUfQqLGkKkFfRrUEelZzhHfdNnDFvVLiFfhHnNIeEiIOouZzkKzZWMmwFeExdDXbBSszuiEWDBbSFfcpSzZWYywBHXxBlLbNDsCcrRtTSwQgGrRCcqDdXAaWrRwQqpmoagHUZGgXxzbBRrSCIicsElLeTwWIimMcCGgtPpuhYeEiAakKIOoRrlPpLLlBSsyVvPKOVvfFfcCcFkKpcnXKkEqvVQnBJjtTWVvEeKEeEMQCYyrRmVvCcMuUMmJrukVvKKkfyYFMWwmGHOoxqQXGDaAOLmMsSMAatTmlaWwAbLlKQUuUuqIzZvVviFfIQgZcCrYyNnRhEeXMmlLxHiIyEeMmADBbjJhHznNZYppPqQTgGuUDHNnhSsoOdRrYkKycwWhHXAaqpGgPHZWwzhjJRrKkLtxXTjJlQOoOoXyYxjSCcqQseeiIUucCSsfeaAcrmNnqIGguUiYyUubBpEhyYHKksSfPpzZFWDdkwlmMLdcYymMhHfsSuUFuvVqQWwcCUjPuUOoHhesSEpNnrFTtfxwEewWbBVvmMkrRKRrlLbaeEaABbpPdDcREernuULCcybkKFfBLYylsbBTnNtPpJjYGTtmMLCFTatTAkKjqqpbBWdDwdAaAarRXVvxDpPLlkKpPRrjWnkKNnHhiIPucCcLlFhlLHfNngGBbLhHeELlXxEeqQFiIeEHhUuqJzZjUuoOQBJjkKbVvthnNGgWwcrXACcjpPJDdMmicCIVvaoOFOyVtIxXQqibVXtTmMrRxoONAanvgGAagRrLlUujKzZkkstoOOfFrRDdAabBoThwxusEeSUfBbraAUuWQqwOoAaJAXXGgDnNzZYytUuywheEPpxXGWwJtTOsSoATzCdDKkVEhHevlLNNNKymMYQEeDBPuUHhrrRRhkKljvnNvjZDdzYygpzZeEPOvwWYyjJVRQqbwbBKkgGnXYgGyJurYyRULWhBVvbNnHopKGgCfdrRDkKFxXieENnjWmjJMwJxXIvuUKUtTKnNCDSxXsdnXvVoOJjxfFiqFufStOpPosSTpHhCBbFNnkKfwdDBPpcAUuaCaAiICXRrHoTtSHhKNRCcrmMnNniIyJjCrcDdEHheQqCxwTDJjQqPpPpKGgCcglhHhHUgYgyYqYwFiIfKkFEMmxJKhDdypPFfYrxXDfFqcCrRsiIStTNOiOTtoSsIVoOpoXxlrxXGzZRrlHhLgCQJjqqQlLcAvbBVAaVvUNnujJcrRNCcimMIRrSsjJnDdzOoIiCcHjSsQeaAMIZzimECcduUcClUuLiwLaADdwWVMmgGvlclLCoyzVxXvOolLoVJjYWwFfPLlpZEJRrjFfzguUGdwdDAaWdWVSsYuyYUySpPslLXyFFLKkWqjJwKkwOWEBnNkKLlpPyYyaOHTtTtHhJjDYCjAYyaLlNpPSGTtitwnNlLghHJjqgyulLULqQOosSlklnbTLUcFfuHRrhKkeZzkKEUCcRkKQqSArRDdaAlcCwnkKCaAcEegGmMGcCFDePpEpaRrcxkKofPDdJCcgGBsIiJAlfFRrdwWOoDSxXdRrsAaSnyYNNnjmMJuPXxpUDNWyYwnpAaZzMsDdGgYySmUCcaATtzYSsOoUuRrvyLlLgGvVAgDdHWwhGvVzPUuppPZTOotaZIieuUEUuZzoMmFdDkKBbkxXKPAadDTvBpBbkUztkMmyYKoOkGYyCgGBbXIiqQxFfjbBGWTYyhHuUqnSEeCzZNnwWcDpPXedDETtxIipPdXNkKPvUuvVQCnJjNexqBbpzZYUuyfjJixLlnNXIQqGghJDTlGgLgPpGavVQqmVvMdDpaAPISrlzZLRJonNOkKoOjsdmMPpbBDjJqQNnrfNnHwBqYytnfWwFNhHGnEMyqQIisVtTclLJjGCcMYypPmzZwXLEelihjIiTSswIiWTfFtTtUuOiIvzZVltTfFFfiUOoDdPpCKkfFczAEyCcYtTYxXLllrLcYyNnMmzZVvwTtcCWBpoOrDdOmMAahUuKkbBHZFyYfLlKkClcMkKJUuBnzPaFhNnHfAtTpwdqvVgGgGQKhHkjXeQxcCXpPTtmIiZzJjKYykdbBiwWBCbBccaAmvVOzgEePCcpGfFBbEeZHlLhyYQcWTrTVvPcLJjZufFUtNiIMmnlGgkLMNnmTHhKktIidDEGgBbyTtLOGzbBOBbFXxYEeyfGsFfSaAImmhycxXTHhFftZKJbncyYEedDMmKkJsSYMJwWXIiCrzRrZEeEeBpwWDeEPimwWSYzEJCDOrcSsMrlLxYyXLlvyYAfUuAaFkKtTfFvIiLlcsGKkgaYthLkKeYyEfVriJjIYssOoJJjpkKPdMreCcXWMPpWwQTgdDGeERMmjJhHXxpraZzFfAGgqQxepPrRLlEpeEPrRectTCcCESYyJjdguKQfXUIiHihlLUufjJFHsZyMZzOoZHOGgbxKkXgfFGQqYAqQUukoOSZhgjJvFGgUufZzMWwgyYUexQsKghwYyXEEeexEeKkuUkZzYKkqQybFMmNyYGgrBbJgOsXAaKhHskdcCgjkNlLnAsSRWwrzZypjJHYMmyvnNlorRXgDyYGtMmoiIRrJjGiIgEcCXaAxKkAadDGMjJNnXoOxFcQrwWRqaJjeCcECcjvNnVJPppPZzWnNwJzZKkRrqAuhJAaWwcwWbBCyndDNdDXxkfKkmhkKHLxOoBbUuXVDDddvVulCcLZZzVbnNbqtTuzfYXUSsuSwWpdvVDRrYyPjJmMMmhmCKkerREcCcPpWwqQtTMDdHsPpHxXgEerRYWhHwJyPpCcOoYFfEXUuxjJepZzQhJSJdCchHpPkKwIQGiPVuUvTtVvpIjJLlzFfZfwWxXJYjeELlSsJjwWdDJGFfgsxViTtTTDdzZPpeCDdRrRrobtLPpFiaAGcCaAWyYuTXuUxtEpPPdDxXpFSmMsfNhTmJjiIMXjJAaxmMCcojCcJHseuGfOdDrRygLyYdcaAavVKkDQeEAaqNEemDsHhfPkUBbuhhHDwGgGYyhFJFNfFhqQqdQsScMKLvViHhusSlKTtbHgGmsSlLsStZFDdFBrRfFbfPNnlGxkEeDdjXxJOQqdDtTIIiKkimcbBCZzsSFfrPpicCbLSVzFmMDdXiIxfecgGfFLRxQqkKXWEJjnnZzEgGXxMmWtamMncDrMmRMmaAYFfFfxXyFfAtTaVvbBFsSlLntTtpJwWwWAaGgDduUasSAPgxXcynnEFfeaMmIaAiANumTtHKAaNgGqzZMcsdDmNSLoDKIEevkjJKRraAFfPpVPpZxXzxDrVHMYXxIimcIVviaAylLYHhCGgtjGDdgNnEeRAazZblLbKvVcCfiRrfqdxnBAaZzeRrHNnheVDhLuURrDEeuUdliINWaTyEeYtsLTtpPuUPpjJlrPpRIXYHhyAMRmMrZzhzvVUuZVvXaAGjJJqUDmMdUppWwLlyqQrkWAalwRAMUumttoUkKuFfOoQiPRrpDNGgrRncVvCMfrWHfzSCcAtTXkKJjxsfFrqQRSDWwjyuOoUnFwWtTYJjcsnezmCzIaWwAiIzZZYYytwWDhHzxXLltTyYnNErRdtTvdDsdDFfRradDgjJNiPcoOKuUAzZXZkKzHZxXWbPMOXbKWcCNMmnyLxqQrqhqQaAXxCrdDpYFfufFUJjqQZZzJjWwURrFLTtWwEelfseESfwWiIJjMmFPjpPYyIiCcvpPVYkKJjQqyiIiIhELKOoEPnNMmpiIeznZzNCrROYIbBiyRrbBJhHLqMIzohjaAJfCcxKeEkBbrRCiIoeyLlcCYmHQqVIiYrRlLyWwpPADdafFmMmMlLEeEelZVvzAaePxNiUYwyYWvHUcKkDdDkKLlkzZKqfFccnFfNzZAaofaAPpFYxeEXshHSymMqdxXYyDVmMNCRunEegGZzEegOoCSscMBdDLfFCjRrFfnriPTYytTtkKpcCfFTDdcPpqYyjJyYQfFYjJAajdDJKlyzoODdchVvrJjknBbWHhwmRHPvVpdDHvSsIWwiPpbWwjoOkHhHhFfjJnNcoOjSbyDeyYIDdAaiEhHBMVvKdDZsyoNmMtKkTtIixXJjKKkKkknNKlQPpqLjLlJkAPpTtEeyOoDIzaZzfGUpbiiICxsJkShjYyJxzgGdgzkKAajJrRZGeEPojJuUySZtTdNnsLlDEktTdDKZzBbeiPrCQhBiIfWvCczczbBqUuQTtYyRaAzZgGetDdTugGpPQHhcJqQIiiILlGJtTggOoWbzAmMvAgTtXoOHxGjqQJwWNEenAaCcAnWzSsnQqQukKUyzZcnNkhuzYydYyDHhrRIipaKkeCcpgGPyFJjfYBAEvOEiHhYyPpLERrrKkYyQqIiqQzxXIJNneTecCaoaADdmyeEndBblLDaADntTasqTmMtkKFVvfpbBgfjcCujJkMoOyYyhHTtYoOAaAPpaNdAaDlLxpIiSsPYyevVDfMFfevJjSsMzZUCceKvQqbBfFtjBYyHfqKktMmTAiVSsGguUjoJBbNnoemJXxpPjMLxXrRlmVXTUjJtRZzMmLlRrXxwWrvHhPpdHABbIfxVvuUoxORPptLlTuUqQCcAaQmwWSOrRYyPhxXHrRhhHmlIUuBsSbcOoxbBurZzGAapqAaUJmaAdDomxXCMjnVvlsuUSEeLAaHhXxGgMMjZzcgIiiIiOovnKeEsHhsSSeDdfAaRQqrFhhDdHlFgTtrRQqiIqKkwWYzZyszDMmfKFfkFeEYGXxWbZBbyYrTrRtEzoORuUrgGVpPaPpAVCSqQjJytToZiIYXxyhOpGgGgqWwGghHxXsSjWBbHSELWryYGgAlNvVnmfhsbBSQbfFjJCckKSsRSsrqlLIiGfFQTtNmMgIiylLGtKkTPvVpnNhHGqQdIdeEDaEeNhGcOowotKkSseEpPRrkKTnkbBsEeWwScpAbUVbBpzBWwnNbZPYyCceEpPBcCbADqhTCQFfqcoKkQqCXZnNFfzsadSsBbFfBGFfgFypPjBbJjJJjdbaXxPGnNkVvjJKgmMldzSLlnNsZrRBQPpKkIjJPpDAaTtvVRrtPnULlKVvtipPlLLCcsSDvVdxiIIlkKLLHZQqGzVvwWZHYXxkKDdPRiIbBrRSwWSsGgsYzZhHXxGWweETNMmvjmMJViIvujJKksSEuUTtFfFfEKaXNWwXxsVvgaAIiGSpZzPgGQbBqIpBieEGAjJJyYZzyYPptTMmahHADdWwuQqbWGVNnsuUyYaAfFhNnTiHhItTtIISyLFfltuPpAalcCLmMjEWwJjSslBQqpPutVCHhgnBwfFGNnhBwWPplLgGbDMDdOomUuvVDyYrRdjtaAfgvWwfBYdCQRrNtTnqZriIdgGsylLYyBbYCcFgdzZjKmnrRHZVvHhzsSdDBTtbBvVVvygGDdVvHQjJHrEeVRyYrNnubBUOovpdoOXxUuNNNwWIisShgHhGrRvgnNBWwAaGgGmVPGgpdDdDuUSmyYMxXaMmnNHhtTzertQCSDdeTtJGQqjJWUiIAGybSiIzZpBztToYsPppJbmMBjIiPSvVKHKzZvWwVJjkxXPpkeEOoUuRFxvqnUCceEuDGzZTtgnNdcCLlFIoOcVXxXxGghHcCvGgWudMWwTtyoOoKkkMSsKkcCfFnqrptTPNZzPBbzZYyhHUCcudnNhHnzMmZZpKLPsSpMIimfVnlLNvWaAhHSFbszRraeXxEnmjJMNyMmafFYdTtDmMZFDdQdDPpBbuvVDdjJUZmsuUlVWwBcEeTRtGgmmyzeSstheycDAaxXdxgYyYyGXxHmEewcrarRAiITtBbDBnNxXJjbZGEoOraAxAaHDxXuBbLlTSstpDFfBEztofeqtTnFeRUurMmlLjJMoOXxBVGDdlwXyPplLlDdPpbKkTWwuGIizZgvVyYiUuoOImrTtQqRrRRrOBdDVZsSzJdDzZzUuAnNwWHDdhewWwnNbBAaWzRrOoOmMpPBowuEbtuvVlLAlTtLaLlOooOxXfnNmMHhFdDonNpPOSLlnXQbGgNIrRCrRcFrZlkhvpPVUuHRrMUuWwjJtvrCcRkKiOAOoHhHzduJMVvmWmAvViILQidDInrRNqPOusSYyLvxxXXAgWfFQCJhHVvVIiiGgCcKVmzZUuZaEexGgXtinmGgmrtvVUuTYyttTnzLlQqDdOWflLwTZzDdtusSvVuUdITgGUlJoOkKCGzZaoIBbisSiIOFpPPpYyhHscCMIimaOohHmMWwTlLtMmNjJKkKJfLlFjIUoORQqSrRCceQgTtwCtTcWBMApPaGhzLlDBUZiDdmMIzVtGgTvBtTLlbaAuGoOgfXxFOCcIjQqJpuUkYrRdUajGXflBbLcdnZroQqqVvFfHMiIpPZyDdxMmDEeAzyYrLxCVvRrUGgqQkmMlLuGbYoOmiIpcBbtTCbBqQEegGqlLTuSsluULloOLYWjJsEeFfNnGgjJZAekCGgyYLAhXHhxWaAZBxXikKnNZzTtXxrRIbuHhKincmlLMCoOHVvOCcgGoTCvtxGlLBbylLuJfNnHhPTCcDGgZKYMkaSPpAayDQcCqdXZRrsUXxiIwVvIgWlGgHQqgIiGKkXikYyuQtToiIrcXxZYUBQqbRBbrcjJCFfqXxdhEeHnrnEMGAagnNLWwAaqQqQlikKVjJauiIUrRuJOlLojnNilLfFvoZzOKkVJjRrXxfFnNSqtVTtGgwWlZzhHAYOoyKkQqwWUgimhHMSsXXWwCchHxZtYwAopkKntcCDdIzZiSYdDwWpxXPnNoJjkKOqWwgGGUuAatuvUCcqQhHBfiIFPpAOrMmYyEecrRTIiOouUEeGgvGgVTWwtvlLbwWRrBsLlFfHXEerDQqTNVdDSZZzRAgnNGaAQVvgGwiIWlLfjJhHjEQqIivfmDnNDdSzSsZszZtrTtRoLEHyJdDjGZtmiIXeEycdDfoOXxFvcKkarRjcfSNnvVVpPvJjwWVvJXyaPnNpYCwWKkZHSdDsBTINWeEOoxQrHhTjJtgBtbOooOOohrgGnSsNRHWqaAvVAOooOmjWgeQqfFPDEevVAJHDVmrRMlLhzZHYSWwKkGgOyYKuEaAYyeNJjnpPUpJGcCgLhHAEekwaZcCzItQUGHuUaAiPpqxKQqpPaAkfbBwRrkVvpPKeExQDoCkKUbUuBzmMiIDuPpIlLLlTOotixXxRRrtTLlrPpSsAaTtJjUuPizRrZIYfFyJjJKkSmMuUnLRjHJhHjzlLCBUBVvSssSbKkoOQtTnLbBTiINntbnNDuqAsUuoaYUuKkzlLkKWnlLYIiGrCUNnAjAPpaAaiIoYvJkKuaMmKkqXkKIidTMRYyZsSoOnZzfLlhYyvWAVvdDaXfvVkGgKhaAiVuUcCoOYyRpqQXxXxYcXxCGtMYitAadtxgfCcmMFOzkKaiDdIAKVvkbmxXdfQVpbTZbWswWwJyYYyEeZOoshFffDdnNWKuHiFfaAwBbQDrLpcCPWmisSdaADgevmdDDxNnXsSZzwWutFbcBBKcgqQpmMmtkpKHKkHGPpNlLnCcDumMUsAacCFgGtTfIMmSHhAaoOsiCXaeEYVtTKNNXxZzQqNhBfFKkbOoaAIrdDuSsYfNnFgbBHhqKkSsHPpKkbdIRwODBteDIiUjdJKTtEZzaYIiduUsoNrRnBeEJgGZzZzMmoOjwDNEYeMmTtELSVjJVvrvetHqQDuoWpPWAXGgfhxwWIEePpIiENDrSsRRElbCcBcCLAmuUUuAqZwxCcXrRPMmvVdDanmxXMmyYlnxMZWPpmMWdCcDwaAkPBbzzNnZvsBbVIixkKICvVsINniSeAkJmyYCMaAfEeMgGmuaAUbBvVyGzZdUuDxLejJwWElPpyYhVDIAHhSuHhESskPpKzjMeEKkbaPpPJoOjpxbsGJEetHMgDdBbGJbpiSxXgyYmPpMGmMtThHhoOHWAeELMxXmaPrKkWwciIVvLGKkHurisPKkkMbAnUxLsScpbBnNXDMmdgXIiYixXkKSroOPMVJyYjFOcmsYySszhHeCPpcxXgVWrRojNxthQqQvPmMoOppMgGmRrOoAaoQReEzBvCcUuggWjHRrhqaURzforvLlDFGaFfNYynHTthhEejJHAgfHFYybtTDtBYMNcCnIAdEgGQkKqeFuYbByZtqQmMgettoOfnWJKwqvHhjcpVvVTMmtvPOoYyBbqRrQcfyDdYvVyZzwWtNlLnlLxXseDdEhbFNOoDohvVjJnbJgGGuUBWGlLgweEjfLFSBJsMmwWxUMmuXSoGedeYPpyvVCcoOyYlFfzZAaLNnlMmrRGgUuKwtGeEtPptTTGgTtTtwKiIMmxhGgxXCcMTuDnsSNTDdNnWBXohfgScHxyVvZzgzZmpPjUwuKaWwAmUxXiIuGgVwWdqBBGmHHnfFWKkZfFzgUulLGgvXTttAErRebMmjJdDlLRUuNTxVMmyXkBIiIiYRRqDWauUzsSZAanrWwIifJjFRdDNeEjJrpPzZOoMLlmaJFTNntSsKkQtTqWwfFfTysXOuuUUkuVWAKfxkOokKZxXXxObpqQCEeFVoOSNUvzSMWwuIibEWIiVAqQaFfvbBzZPIuuTOobzZvVcbkFfBkKIbBmMiBKkMmDNnNYcsypPZImMipVEKkjGgrELsMmSpPlcmdtqoMmhyYCgGcLlJaAVvfkAaMSzZvPHWgjXhyYaAnNHBqksSxXPpYLlyeAarREqkZzCcKPsPpAaIjJiEeRfKqTBbDEOFBhHpPvVtcCeESrEKsSirRyIiXxxoAaOyOgVtQSKksXxSvVFfIqVIcaAVotTsaAkKbziIEieaAEGPpTeehcBbZlLzxAMfFsSHhsfFfsrRSibBpPyYmrCcCcxPpprMIKfwGHhQLlxAMMmmycNrdgPphgGxXsSKbByxDyYPpmZzLAdDmMdGskkNCcnqQyGgNyWEqQeMTtfFTSodvVPppPRrTlLTtHhptTPtTpsSqeEsZnNpJoFwWfEaWoxoYFyrRhHRrmMVvHhKkAzqQAblDAayYbXhHMaNnhgGIisQuUyKThYnvYzTtIUumLlcCOKkovVZNnVrRvZzFrjJQaAfZzFVVFQhIiyYTYlmFfMLOBbJMjttTuUTHOkKuUVvYcUuCyRTtnUxfcCFXuNZUuIicgGGgSsCzrzbBEetcYFALjsSZhoTtassUjNbBKgoOfLwQfXTgGgFTtmMeEAuobZOsRsSVCcvBbAahHZzAUjJuIPvfNbWwymvVlLpdiiKkKRWFGoXUuxOYJAaTWImudyhHcUXDfBwXnSsNsJsCcgGGmJnNTtvAAajhMmdDlDxXiSwWYysghHEenYyYLqfVcDHhEeusSGniQqIgZUMJtVvWwdSsHhqQDCEzCVVvbJjdDtMmufFWBbeihHIJjINAGNnghyYDdHpEVMsOmhHqWIioaZSszAODdwQdArObBoBTMwWmEeaAAawWuKuzZnNdPukDXxGtdDTiIeUuBTLetLZzlSpUlbBLuBXHhwWWLwSHhsMtOeKrxXysnNCaAJjYELPzRJQqKkPuUTwtTURreSsEjJuEeqQeCcpMFfHcATeKwWwSSmmRrMMFfsuxydDAQqlQVogaeDlDdVmfNxjJXilLNEfFtKkWMYyPpEeUWwInbDyYhRzYPhCBbcHYymMBbxXPPprRiZzdYpFjlaiIAsHsvVUqEeRpPrInMtpPVsoVSxsSkHjJvbxwNnucCtcaqQAvPpIiUsSOskKSHhmMwujuWwByXeCcOweeEuRghQjQPwklpPVYyiIREUYeEGgcVvCMUbBsSerRYQjpUmlKkGRIoyYAGcILsyGUuhmMzTtacoojrUSCcZfGgHhPpQHheOVnNWwMwWDUurRrRtTgVvREerGuUmoOkKMYnUSGglLoOhjaDeEJAaVPVCcvqQkAayYIioOFBbgGYBKueEUmMiLlAaELljEeoaWGPoOBThHavCcsSaAlazoKkXMmDSLcCleQqJHrROKGjtTbomMBXvccyYCJtNVvVvBbnNWSNUSOojKkVhHzZdDsgGjJSiVAfsFfMcDWRaAYbcCLHMEemrFfRhBbcClHeEefeEPpFrRFAlLiAaCcVVTRKyXRrmGlLKksmMYyBNCcnnxXXmMFAwWUuaOiItvDexXtBPppXgGDdBYOoynYjSsvNoqmMKCuxVvXoOfZlLufoOUuFCjJJvWphbByJRGgoObBHhrhQtxXLXByYvuUSsuUTZziCcHhTtjMmOoJeEzZWwtTKvBbHXdDaeEgGALUkKCPIjNnMncBbPpAWuUURAQkVvFDdCEMGWmeFpQXxqPAFfaGgnRZzrhgtGgTEetRRkcCoOlhHARrCvGgVGZAiNnkKDLiIJQqTtCMUusSycefzRcOoCcrRCDdfFHhTnNWwWgGkmMgGJSbGZipnNLlLlOoslBbHFcbCcBtlLoqsMmFcoOCuUTMDOyYvVoTMyeEiLlcjWAsCqZfJLlgKtTnNgVMWUAwxXlLWRrtSnIFRsScJjwBsPpxIiFmMFlrlLKNnkYuUFhHfNnOXfsCcFcCfSSsfZyYMmXgBLHhlrQrRrDRZzrKkHWgcCcAJjasOHNeEnhqQoGSHIJScrkbrRBSfQFfsSJKVvsCmRrRrGghhnNGgXwwJjGHVBbMtTmvPQKkrRVvgwTtWsSwWYyGqetJjTEtvOKhmMSqQKYyEuQjJqBeEYRtTrlcGqslaAuUoJjutWkoOTtgiXUlCcdFXxVvdpRXCcxfFhuQudSaAsDSEBmKdJjcCDrtTfFCnydoODdtsSmMxhHwWhihNHLltmMrRkorRclAwuUWVvrRzBCGgcDlLduUmtTrLqQOoNnfAMmMtmfuNntqQwrRWeuUQqEwywFTtkKfCcTPbkKYLtTnYySsFfXukbBRYYyXWaArLuxXsKkDdFxXSsRJvgfpPFtTgGjJWVDdwVjHoOfMBpQqPpqjOdhsSTtGeEgWPLlzxCeNeCaAIiclLHSMpYCSdDBEebhHeJQPqQtTxXABbLHhlYyDOqKxXgFDKcCApPOGgoCcawGggvVaGgAGYyWNnkpPRpPrgxfFzGbKsUnJFSRgGydlLWUuaCciLbBjFfIqQvViDdHpqevDdRrVZIiVVvVKkvoPpvSOojKnOoXxNlLgMTOXshHxiIrglWwqgGMmyYuUcIVvaXoOLbdDuVKTiIVvPEQPaAaFTsStgGONczZVvufWwyraoRrOAYeEHhSfCcFsYybwbfFfrwWfWoHhjysHhHttnrAVvNnrSsHhpUPbAkbLkLlKQqlBKpPKflwelLEieEyBhftTFwWHhvVSkJFfOFfcFWwJMLlmBbpKkkqQxXKRxlWwcwEEeCyUuHlLSsZgTtYRFfpPyEebRvNQBnSFdpOuaJjTCctmQtzakKhigQWwqEeUtrRxXWvbAuUeIcBbSwizTvZmGDdJjzwUuYyFfBpPJkFfKqQjbHYyhlLEfFDdeFyYYxXtgGTpOqQzZTROTtJrRaAPhZsncyXPOoiPKczZutuRRrrcCkWzZGRBbEeFfXffGfmUMeHhKVUuvnekTWDQWCchAqMOjJxJjSrRAahHsPNBbjEyjJioDdcoOCRNGmMgnLlZzmrRMoSdDIiXjxFjpPwNSsDaOfDdGgFOooSazErFURrujHhUuHIxXlAaLDnJjFfpPGDixXIjJVYyPpGqcCbrRdqQdVMSncCBbNQqQEVWwvpPGgRfHjSobEQqXSTzvXxuZXyYTtNvVRMnvEKCcwglLGpYyySsahTyKYyxNqQbjfFiAbyYgkKvVRiyYvVoGgdDelLiuUyYpcGAZzyYMUHhuzZhizwblLrJVWwbBkdtgGeElQJjqsDBjuNmMnZJgOhJmMGgkJjIKurRsSyYUkdLPpJwwhSsANngGKOLlowTKjJkFIzFfEpchHJkvdXxhRjJjLwWlNNnIKNCcjXFNnAalGwKtTkobfFyEOLeyqqJACmjJWwcNarxnNEeZdbKIiWnQZkKamMAFfEegPNPpZzZzhUQqTnFIESsIfFIgWZbBaAnIeraFfEeYwZzEMYlBbLCWmoOMSeZzErRKEmMpEAgGCcmgGMrrfoIADGgeExBGYnWlDVvIiAYyaPpnNtRxqmrJjcNEpCyYLltCNqBbeDbBoRrIiHheEwMOLlomjxXJfFUDUeRruUigGDdqBGgCxLlXYyAGgNmRrfTZALMRreclsNTtcZOEkwWVuoPKUuHhJJjyYxZMDfFWbwVvmEPpkJMucCvVhhKUKVvSsWwwWhHwWkaALNRrugGgImMtTHhEzZLlRZquheEHUmuuNXPTcbBcYszrRZwChVvHylLoeEPnNjaQOoXxeYlHDdxXxrizvWfNMmnFeNrGgRfGgFnEvYyzZnzZNWlLRrkrRJwWWNnJjgVkeiZyGgYyNFOPEDTtAyBAoJHGOiITQqXScCnbwyYsBSwzXwWbQpJjbMKvrRMxrRhHoOHtTaVvFfdKHaALGpWwxhTsUmoyHgBaAoFzZMTGgXEZaAOUudJfFRrxqsSGgAWlLlJeEeniAbJqAWwVMdwCcsvjJVZQjmenrRHhuMSsdDDUgtcCrRTbAaBURrFkeEoOPvduUfxmXxMEeFfXFDOoULdzZIAkjZUNnOMSxTKyjHfWbTnLhZzKFxwWVxUUMmDHqQhdkGgIIhgGtTHvewZYLZYjUDeEHTFftqXiKHMCHLQznaAfGzcrPpaAvBPWBkdedvTnNKkKdDjkYyKXxJRrxxFfnSsNiRrULwRrjJgCJxXimDfFSyQcKGYwWKCPGeGgawJjstTXlLofFdSGOLWwlbBXbpThHtNnfQqQqxeEnauqkLRcYyCGvSPWnpafchcpGxQqXkPjLlCbsYytzZTFsSQRSsvEzHhrhHkaAIiavdSqYyGgmMVTVtTdzZDoOcEsSjJkaPLTAAuEeDtGglglLFAPhHKkIiimcaAtTMBbhqkKQYXPUyYusSZzatTiIAcCHwWBElZsXxyiheEbCRTAadVpCMmcbBdpGgRaVfVvTtIGYoSKtxYcUsRyncCIvrRZNMMmmeWoJJEeNnDdsSKLXqYxnflLFNXthHzhtqwbaDPpWwOiIikofFFZzQqyYfiInNNmZzMmMnBbhHYMmygGEeMmDdvoTtcqCcQMYIjJJtuybKtgvUuGccUKkhaAMSIKkPFsSFlrRLwcAhJjZMmzIitHhgkhxpYyEfDiEeIdFePbcidIRMmriIgyXxocBXyNZiAtKkSspPLlBbmeEUBEUyYomtGgJJJLeuUSsCcwWIYigMXxGzZgsSmvQjyWZRyVvYvVrVDdKkxXxhAsIiSlasSZGtYaYFgVCcvGHvVnVvoOdIihHyYWZHAgaCdDcIimvySpStpSsJRYyrKNnIineENRQVfRrjJUHhaXqMmwOatHhGdcLenNEHjOoIkHhZzOoSsWVyVhdVRLlHoOFZzhzaAcppLjITtexcCvuCXxuUCcyITStRJOIarRAwCBJaNnNpntTbMmrfRrbBFRxXrmMQZzqQQbZzBfFDOodjJpGgInsSxEEeeIrRifMHhYyMkfFiOAafpPZIiNnmvVLlJrRgGoOqIGZTHhpOxXdDysngdfFrsSRtlmAQHFBbnkeyLsUVqQBNMvdDnNaWoOwTtNQqcfJZdSsIieEDzjIiFuHhXMBuwNMmoOAfuCcHhGbHhBgoUveyOoZziIMmWykKlKjJwWRrktTLlLzbFfclzZiCWBtdpbBPDTeAJuDGoAVvqQHhVvaTkNRrCqQnsStlqnEeDavrURKiSwROoiIrGkziMJjPgGpuMvbnPDKkJjdpNBRpqaquGgJIlbBYgdYypPtvAYyKyiaMmbsSSaBbAHgmMtfKNldENFeqiXVwIiLlElNnLexyuAHhilnVePymMaAvvNnVYlqAacMYytwWiIVRREenkKioOmUuMHlVKkvLeNbBoOizZkKbBzlBLQuaPpAoJVdoAyBQivVItTZDVKkmPiTJjOvKKkSIisMZLiIFflKfptXxTaDdcwuUzZXxOWJlawolLFfOcilBRYuAafFnNKPebBeZmiGjLlzPpxVHrRrWVnnxGWXNFDdQeDpPdElLGUuxIiIiXqkYxdDcCnNUsSuyYXkYxZanCCyvVcCvsSpqQYHhgdHuUQJrGAaABKtgnEeLlhdiECupbBPUEmZPsiImaAOgfNnzkAAaaRkJyCcykMmlhSuLCmbBZpPGtNnpTtPVvFiATaAtvxXkwVvvbLJtvvVVKDdnNdbSsAaSsEeyVCceHpwWrRPHhfdDFfuNnBbNnniTnNtIsdLFrRIfFcCxrRXmMilmXcIMYymzJZzdsSLdsnyaKrarRAAkwWVOaSlLDbBvTttTppbsSBPXxeRtltjJnNQgWIpeuUorhHTxWwXjJXAdGgDiCRXHOdDyJDdAxXRrJjeEIEkohzXxZWvVkKhZzHfAPPXUubBXAaxbBxvVpFvrRVGgHhfEgOMmaAjJIdUiIpPeOjCcJuUiZzqQtlalpxDIjJiRrdBPpuXbBiIakTtEeDdEYJIAJjpPsLgGfxyoOYyYQqtUaoIfbKrRYhKkHvRvsHPpNjdZHEcCTXAeTKNmNtNaGgAOodDnnlrpPJXnwtXxUURrqgkKyOYIiyBmFaZMmEYDIZHgGhzZYNnZzcwWEblLwWrRrdiCXRCTLGgIqQOoiKezJGZxbBMzZmXiJYygYmpmUgpPpPGAeEWwqQxzZMmIiBOobzZaAVvJCmrRMPkKjwLloOGLQGNnBvViVvaakACVXkYFfuIGutVxqcCrRQXpdMCcmuVvjwtapHhPjJzzZgkEQJjPpekGJHkKlgpPGiIgGegGOIUSlZEirHQkzIrRQqDdIYTCntTNzZgGMQqXxhjhHJlxqQXLHCWRtRkKwWrvpqVmMTYvVJLlIBlmMTcCtNnDkKJTtkEaAXxkMmEmMBoFfOwWRreEjcvNnKdeEZzqwWluMFDbAiIPIivVLGmOoVgllLuHhUEeZKfapPqYHhynNgdKGkKgAaGTwVUaWYFfKTObBPpRrnsXWKpmCcBKyXxxCOtRrKkTeZzqQplZGBbxXvHhVGwQqHEeZOoOoJjookHwkebmHKkyCliGiIgItTqQmMLcXxYyYhgLlGMBEKWhKOOzNnhWggzLPEocHhXYkbMPkwxSNotZzkJjywMmAuvDdWtNtTnHhkKzZyYRrgkDGkHyYhKQAFkzzZLGvRrhHMglpeELlqXxLlQaBLlWwZzdfmULQDkIiVCJQgIiGqbwWOoeKeKiIdDjdqpPQSvVsLbiaOoAjytvQPVTkjJjJKmMPprwcTbsSVvBtnNmaAjJcvVaAygGFfxXxXYtyyYiyYiZKkKqpPYyxXhRIezLsuioEkKhHgGLhCcjrRgKEYIiyMmqbBRkKrmMeKGZAVDdvTWJSsoOAaUDdDPvgGTUgiUyKxvtTcazZphHPKAAIbgqmMlgkKzPpZQqWJpcjXaMmuMvVPtTMyRrGjIZzzgaAjZEkltcrxcIDRBNneCyziJjdVvyIiezAfMboXxYvoOVGQuucCTWNxVvjTCwYyWctRLNeENzZnTTtnMPpuXxUoOnktrREaxtehlLzDJnhPpSVrVdDhHwWyZzkBFiOAuTmixXIMcCfFXFqCcQlSEIieaijyeKAvUuVDdxhHLlbBUJjbXIiknVvNKPLAEebBZzLTIipPNnjAvVaJIoEuDioGeNlLcCnpGgWwaFcCwHOKecCieGgEaSsipPIqQjnNYyYIioOohgGxdDrrRjvVBbJcIrRaxjJtROXxVvEPiwGqrRTbBMeUuEmLTrEPVdsAoOovKaRkAYNCcSDlDjZiUuyYCrRxMLflDSNUFEehEpPqQnNYSlLsAaywWvrRYnFfNOHyYCchAaBboBDkTjlBlLVWKSsrRVaIfKkTgzyYMclUayYAqQsHLKYYipPIqQwWjKrLlKZiIQqFGoMSpzMecCcxyYXeIDHNGTwLdDlWBbkbNpPLlnagRjqhRrDUuGyYHwAqQaWhyPndDNVWwYccNAzLlXyKxsSXyKQPpGggeZxXkKNngGzEqCcNnfnxwgXNNvdDwRFSPpsfhvhhYyHHXZJgIbBMzEuUEpkcCLlzvVZUyracCAjdDzZJbLIClLIWwiWAWwLjwoKkzZMcCmWCArRPFRNhHnrkzmIikVoTttDdjJIpECPpceYyMiIKkvSsfFdzqbYawWODRrpjpPqQJPvjOUqlbLZIPhHzMmZpJjsSZkKznEhbwWBlLIZzNZlLeEhHzrrvrRIiTaADssIiSyAapPYSdmZzCAJOojCcxXnNaQLFfnNyVRrTttTYpEvlLNlLLIaUYXZzmMWJjoOxIQmMEfnJjeDLnkFTYhHyGhsBAIYMwWKkmkaqQWwVtTCcTyYDGgGvVyLiltTLjUQASsQPrVjhHJmUJjmIZKgRrKHhkFfWsIkruRVYyAsSdNXxvVjJAaPpQLTbBNvVGgcnKeEyYtEeCcOgdUjayYEbwcVvILlLCBZOoSsMmWwSiIsYwYEVuOUFanWJjjJUbmxUfFCAaNnnTtgGQqAVjoOJmnbMmvuSlYEKNTtfhqkKaMLPpTOoYyOoOOooDGNSYpPoqQPgGrRtzwWgiQjMMrRmzFoIKmmFEeXNGgiPcCbBWwjJqcCqRwWBNuUPnAjbcWGgiojrTBCcbstiYcUVhCcHXEWwQqMmpPCciieEIJlPPlLCZHoOfFfpOoPhWwHhRrrvDHvYvwwWKiJhlZzCDgFfTZTtzeEAoWVvQxADduZzFvaAqtTrKktTyYbBkjPTsPrRsqQpPkKYVhHMCdDcABnNbGahzwDoOVjJXxvNeFfEhszZSfyAyTgzALanNHXxXvzwYpPsSJBbqVMmGIyiqQcCxXElhgGHjjjvVTbBMOukKeNnbiIuGgMTaIHhzoOnYxbCODdYGhkmMKHiDICBGgEeDdXKkHKGTSsHzZIwWfFwWCcFfiaCwWWlKkLffpieEsLllxWwOoXLMmhHmGgOoHuqQCXxCwWgVfFGQqTkNnBYUTjDdiymdDHhdDCOVhHdDRrlLOKIoHhdABWQTHZTyQxlkrRCKkcCcdjJDZzjjOyYwEpPncCzeEViNYrSuCyXTNnkQqsOygitTFVvvAIirGgPDPJjyYvMmDuUtrcHMmHhhBHIYSzLeTtbhpxLlyHxXmCMgkKGIKkyYpalDdLfcCGLTeEGgdcCUaXxatlpAKeCvtvVmMvQsDVAtTKzZRZVvwWefFdDVSsrqstTuUShHfrdDzsSZRSBcJpKcCgPCHCFAqQPNwrRpjJsSsVJjolLOgrlKQUANXFPBxmMmMoMmgsDfFOxSWBNnbADdEgpccCkKYyqQkygkCqiIYsQqdMwWhHdDIjcGUuWKkkKluIiIxXXPpCcXknbBNPptaAZzPpVLlDECcDKbwpbyYmMVSspPxXRCZgFNZqvqQfFVGglhcUumRmMrzZUuRrHhhiIkIsSxbYyOoBQAahdNnuJyzyYloOyzJbaABjWEViisSKZzuuXvXLldDfkVvHlNtBwFhJYkeEtXsmoIiuzJKaNnizZDluXxVpKfuGudadDAdDmUNRrEiIMzZJqzSGgOoWbwWBUuDmvaOoQvVjBOoKsSIioOkaINdEeDEzZjrRLwaQZzXjDJjoOozeZEezHhAaxtgQqgGGmfObGhYTtOMtSgGsTuSgGtHXPpPglIAaihkDAxXhXDdezZdTBbqQtDEhHgGmVkUuorQqROSsmBPqBsRrSKkCcxZWsbSWBNJUujPvVpsxtRrikKIogbBhjVMmvOvVabaAQqrCcRYadyYeXxpofnBbfFuUYzIEiIKaAhHvZzGwjxXRqQrkKKwnNwWiIfBbwkKWFVWqQwwVZqQBbIRXhLdDyfFEkKoOqAJqQpOAaYmMlLgGcgGWSyCCtpxnUUJjTtMgGQiIzrJjjJeYyfFErReiGUnlukHHUQqmjKeMsSWRrBwAfFadmbaABzXjkpOUvgGKeBbmMozgGCWwnSTtLCUeEuEmlazpPGAaIiggGtFZzMqQnaYNnycbQuUIQqEudRrGgufJjFvBbHhVSsWHhOdKkElLztjJTbbBBZSsQnPUupcTSsNncPlLJjenCUuRMQSsXrTaGgTtAHhdYZzyTtLwNykKgbXnNdaiUuOFsSRmMRapPePmMSsekdBbDEeshKkHVvpPwclLEeKRrkeEymeWPpyAREiXxNqQzwQhxoaAOXHqUWuUwuGwQqlCcLWiihHeifNtuHnpcfFCGXxzoOqNwkaWmMwABfFDzgGXRXxvVAnCMrRcajQvfFHhVAaQRrDdYBbElxhHXoeYBBOobOrRWTBusSUbtgCcLfxJnkinJrLlHvVDVKjCySsYLlPeZifpPtWkavVAWSWwswaHBbxGgXxXiIWWIdDyYikyYKFflLjlDiKkKjHoGjzdDUJOobdyYSLTrRDBbKvjRBxRrXWbBZIHmtTrRaAagCNnPIglLGEwWOIjJrtTGJjBaCcEeIJBmMnXkYtHAYPWkeVNMmmrSsnxiIzUVZtgrRGsxeRrBOsJaAhXxFrmMMmeEeqnNsmiIvDFfIiDTHhtBQUuHsShgvdgNdiPpUuhfFJWWwwfCcReZAsAdnWJRrfXJxRrsOreEOIYcCeJnpXqQomQaATtJjVvaHwqDxXddehHEHhwtKENkEmuoMmOSsjJMFgFLldDFMmxXxoOrRrgpPwKUTUCkpIvKkVCcpxBbYCNBoObSzHMmHhFrRfpjGGggvVortoPxXqQRrmMyfaApPEjJeWmIiZzMWCcCcOowcCZgMgGzVtZIWsCizZEeEaBVWweEwNnTzZuGIHAIiZTqMFfsShHAKkvVUoPDfsNiIuUbqnVGgrBYAWwarySsGzhYcxJjXeWqQCLvVXriMmIPjfCorRrRgGjrRKzZsHbQDwWdqUuYUuIWLnNFkGgcjXxJPHhpIiCaBpuIiPiIUuRvVaOovVRNmMTYyKkevViIETzZhWwqbhHtTtkKTByYQSYJOwFFfRqQFBWlLDmMdBhRrHyUXxTtucCTtOoRYFUCnLNcCnleEoaAfowWOApqezZptXxkzZvUBlxoOAicCuUEeCQWJjhHwLGRPpXSxotmtTEeGkJWwsVOTwWtuUDRrdvcCzxHhXEQKkPhJoOlIsSABbEewlLDYrsKkfjNuSkBgZXGkKKwVvcChHKkWkqQzZdfAaGkQodyFfYaSspqjEyYscyPmqVvQDdsgGhrREnESsmMcuUXjJZLhHlpwHDozZJdDQmMPbNnmFcChRrJveEWvwbBGVvnNmGgMyYVmRrMjrTtfDdSUlRwxyrbBKUxNTtaAlyBptWuUYWSsTUFMTmfFXxXxaFdDlnNRMbtTzZZzDdihHIZOoWOWwoAajJwaLCMPqQpmeEOKThniIHIHhHXTDsCcSlOoLYNcRdDkMbesLlUuzZtTeEUqcCUnNHYrRyrPDfOoTtaADLuxtTIGsSKwTUOLDiIvVdXxSQgVYKkyCXxcoiFfIOvCuUzZLybCcUeEehwWcCHksLlTtHqQkoVTWwphgWwWOoWxHHMcSkSsjqFsKtTDgGdyYDpPdRCsMmjihsgRBbrSCGwhqQNndMmDdRMmdDqRUuIibGxzTtFFscCSxoiIyRBbLffzZXUuaAuUSbWbBCXxrfoOPaApnNNniNsTQqXxPpauZzvVwmvSsdDGkGkKjFzJlLjyYQcSaJbBjwJCIYmmMCctPpdmXxtvVzZzZhHfwWSsSQOpPTbverREKkVvVWwoOBCvVfqeEQKkSshLSBbzZPIzgBsjKPpLjsSJlNnPpraARwUutGpPglLrZFECYmjJDdukKJjJjUDdcjaCcAldwWcOoCIazgcahHFfLEeKrvVrTHhGHtTBbwWjJoONgGFfXZzyYxbkKHhBfEMzZMgwWGmwgmmMqQeciIqQoOfKBbqaIiruWwuURrwaEePpIitTCNmJvuUVipcdDSwWgDdGiIsulxhVkQqItaPQOpPoqctTCpAVSsJJjjbxlCcSyYsTUuqHgGjYPpHPwXOowWxgGiIiIVjkKcUkKlLzFUqBbQcAakUuKkQLlOnOoVJZzyNbkKlWwpPLxTtPbBbTQqEdsSbBVTofxbBnNuUNGnNgLQqlbSgMxYkrTttvvIiIakxXKfimMhHXxIuUEhTJjtLlByUurIifFwdCUumMzZYymSFavIvKkbBmjJOEwWeoMJsEeunskKlLYyaYyAwnTjCVxLZzlbOBqQZziIJgknNnNokHwpPWheEKMmhjEMmsdxOspPqhHSsQcCSZkKCcjJYDdyPpAVvLVhHcpPPpCvVAtEPpebEeWwoOoOpqCMgGmSscQgwYyAOJcCqQeIZHRDUudrhzkbyfjJWwKOopvjUudoOAJHQqfFsuNcCvVYyyrRgGdBbSsZzmnNvoiIcCEXxqGgFzJyYjsuSsRcCJCceEyYOuUOCAsSjJZHgxXrRYSVvlDdrRicCCgaxXOIiiEergYuUyLMuPJqyEUgYycCGuXxumIiEeyMmlLfFucCeZzrvjJLKWpqJqsSHGrUKPpkEWosSyGgYExWwYbnNUJSsGgJjUWouPpYyVCTUWmMXbBrVvRKkxQAaMkKmqGgjJXBVhKXsvOdDVvSvTmNiQuUuSCchSaAHhLJeEfPzZEeyAKkahUuHDSLMmgGlsIdDppyZrCcHDddBNiuVvZnNdnNDzFSsfmwToOeXxfFnTtInZzWwWwuHhUFBGaAgpPbMvLduUEqQeWwEADsSdGOvqLawBbWYXgGUsxjJXWkpPElLtaChsSmPfFETtTttkKTwWWcCtpmMjrZpkKZMlkKLMdDmgGckKCmYyzJjlexXvNnLlVypPQyYRpPrJjqcSYRkEoTOWmoOZsxXuwWWwWuUbwWBwUSzMwopPmQEeqJjWlwbkpPRrKyYBxRrbsSPsVvLlOoTsSEltbEhiPpiIIHzZVvhHgdKUpYyXhHuUxDsSxXkKLlUkUtbaARaDMoSmvePvVatTLlniQqOjJoOoEwUTBvcZhHecPphMGgmdDLluUHKkTRrjmuUuzLlxXaANnGNgtTUdCxARraLlXvmMmMKkFQZNnzQKkqlGgyNGIXxxRrXdLhHHJaZzxXVTtjJjMgKkTtSjnZuURrzNSnWwLlzZlQqLPpNxWbFvVdxCcuCYDUMTbBtwWihHZzwtjDdygfjJwrkIgaAGTtIDKkPMYBnFVpWDdYywiasSRdDrrtTSobBugGUzBOvOoVUlGgLaGgfGtxFqWlFGknJuSSAOUGgfoOXxjJeEFgGuEeHoOzJlafyCTZvVzRyYrZohJKkmjoyXxtFfHqfRJjrvvqZzRSsSsDdfzDdMmDdMkKhHiZyVNyHtkKkDdYuUqVvmjRrJMSsSHAyYwWmGgxBdLeFaAdDfHhEBaeRrPpEAaMmDdZaqqQQYfyOXSsOwAnNaAeOjPzZKkpPrRrvVRrRzqQbBSQPtLlSsbBLlDOsthHnNmgGeEACXxcaGaAgwYrRVvnYgGVKkvuUIiKlLKSgeEDRraloOMyHhYkKdXYkQqFfgGBbHGcCDRnRrCVvIidDYaXCcqgWFkieEeJeqQLYyOvVolEjEPpmRpPPpPXRLhHlMXODdgGoxIRrtTDdSsFqjFogGOfJTHRrhxsScChHVvxXXHjJhtQpPSgGHhmaiIXCHGgzZEEtgANnaIeZwnNWNnBGgSOvCivQiRvVjJrsqTlLSshHvGoYXKkMmBboOYIqQkeRsbNnZzBTbfoeSsdOoQYyoewWEOUuqscCxpPXStjJQMmkFrSjJVvyjJYpQKtTQwWbxJGaAdDZzwhscCSWwpVsmrRdDOpeEPoFftnNQqTKFjSsNnqQTtJjHiBbIFfOQFfTLlDxEeXMCeRJevPzQqYzZLlSCyOondUubkeEfKdDIivVkdDFeEwWJjwWJjKDdbKBCBTtFftUUipOoOoCcwNKkfFnesoOaASBtTUPpzZKXxkNnmsZSlLsPpiIRrVunedDEPpsvfUuZzzZcoOPBozKyYdDXFkawmMBbvuUUKuGsSgUoxXuUxJjZhHzeETHhFftSYeEtjhHGuUgJjAcCNnPpRAwFfdQrrybsSKszZLlqLlQSkYygGqQKOoxYZzvYyXtnrBLlaDdTxVJBbjGwNhhMgbbQDvMkUWuJGgSsMmMGMdDmJjYXhCsGKkFHOxbwNntdUtmHXKiIEekKkaAkkKWkKtTgTNwWnWkoOGAagbLuUlkKWwiyYIBLEDEgOXxjtTbsflBbFJbsSaAgjJjByYgGcCNHOUudnqbBQfBHSaATYTtHhFCuHhyYUAaKkLleEuUaACJVQWSsVvWwSskCCccjwFMmhHfNgGFhHvVTTJjEpPGTzpPUVlLvfDaimwWwWybTdBfhdVROxXFdYyHhxXDZrBbuAQIitTJLlwGGVbZremMSsRrdDEhrRHqHhuUhHObxXBoAaTtOWwPEqQeVmMZzsSqHiEeITXHhnJOwvAauUGCfFTtcJPpjEZSMDdCenNEoYyfFfvmfFpRsIXxyxpRBbrPKkGcwWmMCxDdPBbCCcTtCcQoOqaAlXuNaBmKpSIlLRUhKUukglCcCQqFfvVURruQqRpoOAEeQqXoOPpcCxPphHlawdhHDsIpPyYPBjOogGxXmhTgGjgSBXABeEmBbBbJCcjJbBKkUuZuUekKntTNVvUsttTTaAxXaihHdvHXDdXdDxdiIiIeEDxXgYajJAFmeEcMjPpGoOgXxKaErRjJcitGgJjOoTlxXGgiILWwXEiIevSFhHmMfVZpKwzmXNLMNABlgJjGLbpGQqgLlZzWeIiENnpPzQEeaMaHhLlerdnejJOogGinNXHiIBbFxawwOUdPphTEwWvVVbBRvslyegGndWnNatToOAbOkKSDydpPEeDAaVvyYXxAekjDJudETUuEetTbgGdoWriDTtBAahJjSsxXQVuaAzZUtTvjxXJVvGyXWmMwxxXmMsSURmMiHnnnkhfEyYeFHAhHavGggGysSrRAxckKKtTkSdghhkdYyGgDPpPKkHhKTKkHhMPGCnNKkBbtTkbbCBfeEdDTUdMVEGIJjBFfbBbMwzZlRJuUSsODTtdojdqTtWIhUcCkwZzFHSzjWtToCNniISKksSscOSwHhBzhfFHtBPvqSsFDMBVvvVBbZoaAJjGGgXfFTDJjTIymTgyPIeETtUZzuiAarWwWwvIHFnNxOokKwVHMmFNRpPrzrmtbBDxQAUnNjVxXyOaAJauWwPGgpcRWwgywrRWWwNnkKNQqwZuUDdyAOSaQUdBlNquYUuybcZeEaAiIGghJVvVbBvAarqQlNsjcnNCBRrbpiIqQXZzIifFPpUdxXJjxXkKZucOaAdsSzZnNvtTOoVuUqcjsSJEeUuCXkKSsSOCcosWFlLXxDdpPXwWLiIlFfQIDdRrhgurRqTiVvAXJjxWKaljPkoCcuUsyZzZxMqQWwmXztTfFvdaAtTBmMbhjadZMmzpEGwJMamMKkQHhnNZzrSsiIRUuwBTSkKsCcbGRqXOowoOnVvTtiBbtbhzwWcyCcNnAYxwWjGgTtqQrRfFkKsYyFCaRrATtJACVvWwVDQdCfFYyYnNxMTwWEoOezgCwAaWcDdYheyYLldDlxXOGgTdMFVeXctsSTCxJsSFqarlLzTtsqQNQqATtanvPpntlLyYTtPpwWTtdRxUYyuhttTvVTSVfFtdDTtCRomMabCcuVUqQTyKRrkYOogoOdDQJGfFOogjysTNfhHFVvgGiIDdUuPOTtLlaWyfFNnjbYycCJjBQqmMJgGJjTzLlxISsSsGumMxXsSGgDdaLvUuTQYsSysIqQiIUMmwWLuUlAvIXxmQqeNRNqsSQaADuUQjJuyzCRONnHMmhuURrqUKIxpPzZyYAzZamMdDhmMLwGqQCcOoiXxWuSzxYdDhHGgibBGgIsAKmjJnNykjJzTtdjUuJtpFjJjUZzYgXTyZzYVLlcwWEevVZuUzKOokthNnNvVIkHRrhMmUzXxtTweEHapPlyDdYcKIikKTtjALlaJeEEazSwyJCbBcEejUsStQvVVvipkKPJJjjItTPJjgVvaAEeGrRzZMyBgKkBbUcCHhdOoDKucXbByYkKkaAKxXlRaAZNnadXLlYzmjJhQsSOSsRzNDdVTtJjvDUuCJlLfFjFBbxhHsSLlwWgJwXxWnNDdAuDyKEePVvwWiUeEuzZobdLVvlZJjHgmbrRGFZzfqCcDdEsruihHkaAnmcjJCOoMAzZzrRvxXRrVZSsFfSfAgcTtjWKkwLutIOoiiDSsqQdDeOheEAaHoEUWFecAaCEwTtoVvZnNNnNVvMKkZzmuKpPkUkKThHRMMzZNIRxXrhHTPpqQKkxXAztxXTHhlLMVvvAaqQtTkDdIDdyYvjcACcaUvVuoOqwGaVlUfFnNopyYlwWaMqQwjUssgZmMzGSEbBeYDdySDZVvhiIaoILlMmrRUuVTvVlLmKHhDdLzRpPgGfinBqxOohHkKITtiWwNslLKJjNnkUXxTBuuUUeUoOWRrOJjboZuUEaZjvbQPpqolLMiIhHxXUtBTtLYxmMmMJcCXxjGgWtTLgviIbrRgUurRGoOzZNnmgGmMOonNKkqQwIiHhXxWLRVvrlEQqIiiIjJYywyYWfNQEiIeElLFOTZMmWwebdPBCcbUHhdDQqdeEhLljJXAaRrRegGgzdRCWFfMhXDdDdCYECcCcHiIzZsSTQqEZYMKeEkMTSsrtVvCbvJjxXLSvFfVMzRrjjJKkJqdDfRsdDSTtrzydDAKkrRYanNARrABekKKkEgGbUuZSBbaABfswFlbXxjJbUQquBTtDdzZBklLPoOOozNDYIiypxXWAaZzwGgniHhIRQNNnmhHEeIiKOYmDVvtTdXxDUwCpmMPNnYnNyiTolLOLlXxtnNVvfNzZeEQlLVyYEeXfrKXxhkyPwWpPFfKkuUpOWGgwSZisSYyIZzqQlcCLhHzSsnNXxAEeasdDotpPTpFTtfPlLOYyZbPsOOoKkQqqQoBlLYgTtatTuwWwgrRjElLscqQqTWwBpPbREVvZkVvKAsvMgbGVHxeEXtYyXxOjJoTzZnnnhHwNnWVvUuDqQPRhjJbBqhmiIRrMYLlmMMmxXbhNMkJIoOiDWwgdDGGfcCSxXDIMxXmiRzcIAaiDybFHhAaKkVGFVvkQqQqKTEeEeJIizAaZdHhHfBbKkFgWbEeNGcpPTtvEeTUuUiIbuULZzexHhXJUuUhHyYFNnrRaAfTcKkCYeEsAWFfwaiimxXMJjVvHSvZzgwBUjagIbPinJtTjTtxASswWkiIkyYKeeEewWnNZzUVZKkoOpHhruqQIiURQqzqTtQZMbBmVvPzUuntZoOzkKTtCceEfFBRrbgyrpRrMmyhgzhhHliXlFfkiIbBKsSITWwWwDdkGFfguNpTdiqbrBeEbRWYywFfDLlLCcVZzvpAgGJtTjBDYuUfDdbDASxcOeGpPcUWwuCgEXxtHQVvdauUWdDUuiIwCcvuBNnaPCCYycKNtTOwWWQqCgOhdDHoXxpPHnAzZiSsRrBbDgKknNEeqQgJjYSsGnqgQBbBDinNaArRbByYILlGgdlLnSlLsWwNqgGHFJjMmMLYyamMRwlebBshsSwPDdpJIigoOGQPWwHhoSsHtTzOYuiIbBLlUscvvZohHMmOelLRzBRrvVPpEewgaKkAyfFjJnZZOozvVoOVlLEedDvzPpNdZhJXiIxjXxHSQGfLHjJEkNVIGCJGgwWmtTEemqQNgqQHhGJAamcMOMjuQPxXQqgXxRUgGXCIiiLMHpqRrQiIoYUucCycCsAJjBbaMqrRDlLZzdrRrgGoxXgGvVXOXKkyYFQqiahDVTutxcLldDCvMtTEWwWuUwlLFkKfOjOJvNhHxXnIvVTtJjnNoODdaQFhgGbJTzZVkwWEMgGhHmMmumBbVaAGgnNEKkNnmFdAaEXiIyYnNnNnmskKSKRrsSUJFGPbhaAHBhHgGFfQMmSrRJjANUlYyLudNMmLlUuleELdDYMOsSAEgGIoOitJjEjiZlLJjyYNnRVvkKVvMviIWwoOmelIeyKkYolJjLpPVeaaABbpiIPbEdDxXvhHuUVovVONrRjJzZnkKzZAJjPZUSstTGgnvVNHKCqQsSRrtTSsHhYqNIisSZwNagerREXhxVvIklLKilLGEeaVDdaZBjqQJwGGHhdFfDCKkcjuNnQqdBbDUOoTtgvZzVZzsSWHhwwSsWtTjDqQdxXCqUELKCMkKmcklbBrqQMmZcCRrCIiZjJbBVwFbhrRHHqEecRKkXRrxpIdSDdDGgzyYsVFfVDwWdvvYaAmMOpDZXQqfNnFlLPpHrRNjJWwnsYEeTiIQIiqtyKjSXqQcIeEBJjYyPuglLSsFJjmMpPAZidzZYaOoNnpPTnOYSJjgGwyYWzdDkmnNUuZzbqQdYBsoOJCnNKqQJoTtUkKcCujJOHAahGTtgBCcKkpPaYymMAVhhrMrROoNWwxXKRHCohiIHTtVvAaQqOIioFfOjJZYLZzkPpoOymyYMVeEvnNCttTIRNNnHhJoOcYynXxWzZwNRrXxlbmNnGNHhUrcnvVWwvQGgIioOOdDCCQAhHazcCZLlQjJyYqHhdRbBrnNCuCczZhtTVHhyuInXfFsSpECcHhLvjJCoOchmMwWmIiMKkRrSsMsSEODdcXuaAUSsFvVLlHOYkfFKSqQtUCcuvVTsmMyZQqJjkKiKgGkEeKfTtFkmPpQlWlLwIVviUujQqHhxXxXocbBVvZkZzHhleHbsSBmZAaxXUuzuJjMmQqUsSMhHDdZzpPavYLlHhbuUJjByRrRrVAJLlpNnVvFjzPpZJiIiIxXGgfuzyPQqRcYyvhjJHwWVvVZzHQRdDUuAaXlnNYLlvHhuUzZhHVwkBZzHXyYxhxoqQuUFfRrmpBwzJjQqhxakJjCpOoIgGPpnGAiIeeEESVQqDeaEeIiAZzenNEsSbBZdTyzhHaAiYyXOomMxZcMZENAaIKoOpPkUuiLMmOolSMmCtTyfaANMmYJdhHKkcCVvaskGgKZbBFhqpPQwCcRgdUuDuuUGgUwWGFhHmdIkKqkKOTTGgafFnNrWLwKRYiIPLlOoPuGguQjtTgxuURrHmTWwtaxitTLjJlSAwjFfJPpnjVvJeOuWwUoEHdvDkKdEEcCbNmMXCcDQFYyPpIFkBBNnrhZxXzHJAaTNnEeTtMJjyTtmhvRCDdcdXPpipPyEeVvaALlYjJkdOnNlmMsnMiISCqQKkmQnSIisyNnAaYzZkheEMUfFNQqOoYjFfHhJrRCyYlLGFfsSRcCrpxmMXaAjcgGCpPPTCcNfEeJjSsEebBAdDSsadCcsSJjCNVvATwebBAaNNeNnwrlCEZMmuzZUAzZaGgqQtTpjJPwWKkvUuVvslBxXIsSRDdMoiIwdDWPXxpKXgMmLpgGUuuUfntRrTNzTyYMhBhHkLUbBIlkRiIrmCaAvVzZXkKkKxiIkBbiIGgOQIiqoaAVvuUDdfoOFKDdqQGgHhqDmMJjHKkhQWQqwvVHpPnMmfjJKkjXxmMfHBbgWdAaHKpFrRCWwcSdMnTtdvVAYyCDYAatTylfFONnJjoxXGYoYyRriIaAWRrwFgwTtWOoZzUEzwWPpZVvShjJOtvVHPpneUyYwOogiIIUZzGgIFffFYyiuflzZTBNOoHhnOgGcEtjJtIHhvXSnSsHhNZzyjoOFgGiIHhgGlLgqiWqbBQDjsjwvVWaAHYylLZzqcCPjyEeGhrRxyFZUSsOodDQBBJMmjvzUvxEecCXaAlHjUuJhDdqQnFfNVvCwWcsSaQiIqCcAqAaQLlMFKSsYjHUJlLjakKQzMmZjTTtnDdNtApPCVvfmuuUdDjJmoOMSaAsUjJgJyYjeHhOThHgxXJQqjdDeEdGxmMDdOLVkKXvMmuCcUVxhYyPYaKJGgGurRSsUtxXTJjDKIiVvSkJjjJQqxSoGjRnfQqkKHhHhUutTgGALlamoOMBHhoNnOKrdjJkKDRvVUuqQCcSsWaAdDbBdDHGkSKkqkkYyKWNnpPwWwKrRNWwnolzWxXNlLnwZBLlMtTmboOLOBbNnyYOoXUuOoLeEliIWwhHdzfFEeZDEFXxfQquGLoObBUpPuWwrRoOlmVGHhHznNsKcCaylLBnNoBbPDdNuUnphLlyYuSsLlrRUzmBAabAaYzSbBIhKfFkucCxvVFaTfFtiIAqkwWUGDbBPplhHLJjsXiIVvvVEeRLKklPrZztqmdDFfvVwxExXRmGHhZzHhXxgTtDjSSyWnNwVvvVfcWwCFRvWwFrRTtlHaATlLtmMLoOloyYEeOayYAcCSZzsMmkKTCcaAyGgASpPPpCYyaEcCeABbVaVIVviRmjSsJSsRrCfJYyjGgFJjRgGfFodcjepPZzZyOosMZzCcLlITNnFfmeEMtEepdPpPkKhwWHWwHhYybwWzEeZRcyYxjmYUuyysZVvzuUSjCMmLlNBcuUCFSsfjBbkzCYHjJMMiZSszYyRRrxXrgPpqigGIQzZoyBbYZgfFonNlYeGzZglKGgTdDtLOoTPpzVvlCOopHhtRDdtwxVvXeDdXxEuUCqbBRrTtoMBgGbCbIDGgMoOqEAaxJDWmjJdRaAXxnAaPpNrjJfXxFAaDIiSsDdMUuZNaAbjUumCLczGZzgIilLAeTrRtEaoRPHwWhNCcvVnSyYsbHMmhIioOCHhnNQqlRLbByFfexXaHhZVvGguIdDLotuUJBbHtTIxWgCvSMmEexXYmDdbBvMmVEkKeeNgBbpPTRrgGQbWhFcCAfFauURjnNJeEkKEZzeinNISsiPpAtdDwkKBbWvVEebBdjLlHhHiUuPCcYypIFPvVQXEdbBdDWwERreDsSgYyGjJcqVpeEnOoJjXxyYbmMBOaAorwWRxfFsNQtkKwgJfFcmZzyYMggGKTcClLZEeupPqQKPuBbTQqtUKkMmxXeEoOPpbVtMmphHfOaAIizPpvVqQlGgYVyZOoeEqQuPDdsLajSOobzZCURruFRruUsSfctTmMfPpFEeOojPppmMFOXbBbBCVXhPpHxLlvdDkKAhvVHPWwdfCcgETtexzqQCyYcgAaTtGKkZXNJjWyYCcLXxasjPpJBbjJrVvTtCuBbJjlaAtKWwjRrYyjmMJJzZVvQqrRkOoBkdYyyYDaotQqTOAKNLKYyYdDuUaAGzZQGWTxXIwwWWgsSsqQHhTtCctTndDJcyDddcCsSDdJjhoqQVvATtfFYbxXKkzZdDewoLlPpWWQwlffYxEegGlLWCcAaLJjcCYyXxlwcTtPpdJvhQqHVDwWogGBbOVvEeuUdjDCcTsStdDGgAmvVzZMDdVxXvaVvCiIvwDDsSVvZeuUGgzwWyvOZaAYOWIMmdQqDDbBqlrRNnLJhhHwWHhtTZyYCaRLOPvoMmnQdRBbHkSsjYgGAaHhdDQQqqHhyXeEyYLlDsSVvddDqQeZzTQqtfWyBgGbbBQGHBhHUUuubhrRPpZzqQmMzZZzyFfGuFfLGVvrRSsBQWwqbjJzZkPpdWwtIikKhHWXPphHUOouczJjZCrRYyUujJRsCchHSOocAnNYylLaRrYwEeMMmmRrWkWwAasOXXGgxmMLlxvVAaqQhxcbTMmCctgGiPpzZIKgGpPkXxWgGoOhJfFjUuHqQcCcPthHlTtLTwWcCsFURrfRVvvVxXrQAmMavVcCxXKkiIeEWwIIiNkKDdhQqHTtctKkTAakSsufCcFkVPpcRrxXkKkxXkKPiIXcCxByYbaxXANnbBOWwwWFfwQqmMljxKkNWjJBroGDdtTfFxXZrHhjrRiIJRzyYJVRhHrBbUudDPpVSsiIJJjzZyYLWwgGHpbdEGgeqQquUkhHiIoOJjoXxOlLncCnQQqqbBcCYyEeQfFqJjoIeXxEiORrBuUjjJJmMbFfBbnaJjAcZtajwWgHbBpBbBbYyZzmMPWhrRuUWwHCEezZcNcCnBsSbmsSMYrnNRzZToHhOzZdAaCcxmPpMxahHjRJjnNFLlXWHSmMFfIiXKkxhHKgOoGwbBWJGVvdDBTeAwWPpaEMmvYofxRCHxXTfnNeElCUvVpNwJnXxNRnNKkrPQQJaAtCWwcfAcCoOaYyAaclFfgruURySvVCcYOoCclLlNCAuHnNhUBSsWXeEFoBbOfwWzZDdVvWwLlRTtTtUuJChHDWKDwWdweGzZgNjJbBRrnPHhQMlLJjRCUuEFEeEEJjJxCtPfFQuUtTqywYyWRrdPpCcaMmJCcjaAGnNgzZuUJjYpPzgbBGBbGCcVvgGNnqViOowWCLlckBoUudghpPgfFUOIiLlHhoRjNaAyYnFfcyYTtqaAmekwbBbHFfhgGYRryNTteLlqQZzxDdNAaCwWGXxEegVvWwIihHRrPCcfkKRrgGCFoHhkploOgGLCcYhHbywvVlLWgGPpGxXAOMpgGaAHhPPgGGguUAaxWDddnBblcCLvVhbstTLlPClLdDsdwOoejJIwzxlLXZTDdEetPpqQDdlLWUQqZlLfqvVhHHhQqwWVvQKPpgTtxXlzUuCcAFfBbKkfFyrRZyYznNbBUubUclIAVozuUrRZgriIRGybBzZCmMcrRgYyCciIGuUgGRrNnRDdyiIYQqmcimoEJkAtdAaIsSnNdFfDjRrtTdDYriIRtTIieEqlLcCQyEeiEjJKkeVvqQjFgGfqQfmMMSsPpmIihHlHhLleEYVvygGuUjJdHLlKkuZpXDdvVVGgxhHVvXbBuUiIvxPUsRrSuTtktqdDpQqKugZbBpEekKPOOooEeEjJrSQqsPpDdVvSnNCXxcOodDtejpblLisrRSIbbxOoXEeEeFXxZzEefDdUcBPyYNnUUKwWkuudTtWtTCVvyGKkgYQquUiDdRroOSyYaKbaRgtTEeGXwjJCkrRKYychHWJDdhaAHpPnoAyYEeaFfiIOeEtMmTjJKkQHhyYZlLWwjMmwWcPpMLlLmNGGtTtTSqQJjsSsdMYxIiXymDjJAaggFYyJjJjwMmWAcCEqQIieFdDAacAPpqsSQqNnQaArgXxGRHharZzGpYbyYxXZmMzBGgrpPVvRjJRmMaAJjsMmEJjqQuUYfFybsSNfWwFkKnLfkKFPplNdDtrREFJjZzbCcBUuIMaAaPpdDpPfnNFNxSTtbBGgsXiAaDdIXRrUuxvvVVWaJTtCcjgQoOWOoiIJjFRrfVmMSoFfrRPpOVvKksKrKkRZEtYyTtvgaAzzZpcdDIiMVPpbFfAaRrMmGqnNUMcCNQKkSAawWslLrfFRqIWwinZCczjxXDdJPpZzbtTrRnulnNEeiItZzfbBMoODdCFfccZmuUOVvoCceEbeQqzaAZaAsSEBbOoOoGpPZzciIqQtjJwKkWBxcOoCXyYblJjxXLAafkGOABbyYVcCvWwaDdMmLlLlFHhfnNhbBHmMbinNIGgHhMmJPNnpjsSpQqXqxXQxPFKkfBbgGrRNsSTtlIiLglLGlLsOlLiZwOFfodrRWSswwzzZZtTwWdRhyYqQnOoNZvLQqlVKyCcYDdfFpMPiIpPQqpnNrRGgPeWwEQqodDOwWbBdDmMpYXPpFoOUufeEgWwUEeEUumMmMrRMmcVvCfFSeEqQvSsfFfFFeEfnNODcUiziIMmMmElLKVvHhkGKkgZzUuryYnNRTtQqWRrmDGgWRrbsSBrRwXxdrjJRDJjdEePPptTFfHhOJjcmsgGuUsSiIuUZTtGXxiJjIfFkKBbCEeOYMLlAcsSwWhHxXGzZgCgGvEUmbBJjMysSYpPatpPTFHhDvVUuWwwWnNqsSHhQcXeEpPTcHhCqOeOoAaNVlBbLNsSVglwWpPMbBFfxXZLlzvVetTekKlLkKEIivUCcgGuVBbNnIiaIiJeoUMmuwWGgHCbBchpFOoqQhHPpzZfFlLgGDdqZzSsvwQuUqVvAawZMGgmoOHNnhqRrqfFCMbBeEmcbkOocwWkKCZuuUUzccCCrRCKkOQqoLlcyAaAaQzZYyabBzZIiAnNqNZznPlyiIYLnFrRfMmjPgmYUuyLFflbuUWwDddDtTHhBOoTtCcKkFUkiIKwWMmUuHUuGiQuUxXSpPnNTbsNVvDvFfVIHZyYCcOqQoTtCcMmjNJjtTKkvVnvfFVJigGZzoObAqQeNlhQqauFIiftTlLdHAahwAaxfFDdDBGboOUuqAaaAwWHhRdDqQruUwbBuUWTtQbDTXxtdBBAaVoOhyZUuEOorAaRPpuUQqCCsSiIGgYyoODduDeEuFfBkKunNmMUlLudDQqUuFCcfOzZnNgGoCbBXxEYykUGfGlLgFeSsXxkKEguFCcDcFfYDVvLldPZKkzcklLlyqkbBKhHcoOuUsaUufFVvASzZCmVvQqMPpgIitTGQCdDbBcaETLQqlqQOoNASsarRHDUudkKPpNlrPvZzVAapQPpwGgTtWuUxXZenNEEsSeqQGoOMwWOzynNTUuUuQqCoLTtuwWomVjfFMQqmrRyYVCclLiOOooJjIlUSebWwBERIiroOsWKkpPwupPxuUXWdDpPsSwAKAyYanNWwZzkTtjJXxEejDAadXxaAAaQKkqZDVWwuiIeEUvdNnyYohHHhKkrRbBrnNubBUiIZzROiVTtWwTtLpPlpPvDfQNnsXxSvCPniIhfFoOKkhQqFfwqXTtxJjcNnnLlsSNCYawWYcNnpDIiCcrRphHiIOovsSVcQqTjDdJNzZnyYUeqXxhHLljlLNnTTtTtTJnNjonpPfFtEeTNBBbBbVvwQsvVSnNRCTtUuBbDpoIiMWsjJfmRrRrAaKAaoXxOtTpPhHdDxXRrLDPpPpfFoFAKsSkaArkKRgGXEeiIwVvMmZzFDIiTtNndfWFQVvqxkKXKwWqQILlimMkqJeEjkwWCcJbnNBjKyYHXxhCmMUpPuIiTtlBbjvVKkywaQqWwADqZzPjOKFlLfkoyYfAJjGgaqIijlLJiKASsakKAjJbBkKGgIikkKOcCqQZzeEwyZqrRnNaAqQiIQzYWvXxVjJSsLlpUXxSsunNEePkKeElLcCaRrCSsnWhHbBwVLSsEeZkPpKlFcRrZzCfFOjJowWMmAatnNvHhVPpzZsSTOoGyYzZgmmMnVvNMBbjFzjWwGUBSsbKJjkWHYmMeEyEKDdTtxXllLPBbpLZzUuXxPpkWwcDhHdCONnACcakKsEeOoLlbNnBSdDsnqQoONafFmMyYnNoOLlQqASsYIiywdsSyYoOtyYQSsqBbYyDdxuUgEmXWLlgyYxXGkvVvVMtTZVvzsSLloOmSOomMrEemMyrRaAtGgTPpFBbnfFWFfSsPpPpwJjNfoDdVvOQqsNnLJavTtRrjOoHSshcCOofdKQqyfRrAaFEDdVNnfFvNhHnnJjNMwWNnZzyYkAaKPVvcQqteETBpPbpwWOpPIDdOoJDUFNoOrRQqoFfyYFahHAfEeFtTfqtTbwWpPBkhHoOdDKNkKNnTtngGGJfFjJwWyBkRrKbYiIvPpmnNMhHOoVxXoOqFfeTtQtTqEAalLEmMyYPtvWwlLHhkKknNBbsSKBxMFfvRsSrPpVVvmavaAmMgFfOozZerRSHhsEIicCuUcCkKcCqQVveEhSexXmMAajJRZzzZfFmMWJGWwgeEjroqUuQIipPRrOxXYuUycCyCDdPaWoOdDiIYywWwUuSsHYocDdTttTYyXxbBtTZaAzSsgQtsuUuaAlLUYyRwuUDuUiIddDsSTtCcYyNMmnKkxXKjJEekNnPpFEefRoOrqipPIlNnsSyYLiWwuPpyYXxUNYywWaEHheihHIqQeqQLlwAaoOWyYwWqQxFfDdXEEeyYgGmMtTGgcCHNnhsJjaDdvVLlWwrRAaVvvVUuOokCcKBbafPpBvVBbRrboOuUZlDdLzfFBbrRvVFaAAzHhIiSsyYzSDdeKnNyDdYkOaAoERVNwGgprssSSRLiIOoCjJoOcoOlhHAVjJLHhlZzzZvDvLUuXxlVraARQqgcCkKAHhVvwVIiJjKaWwUvVuvzZVAkVrfFGgRFffTEetFQLcClqmMvtTzZvWADdsIcCINniiwWwcToOtVvVvlazZLlGgmMNnAOycCnvUuXaAqQyYKUukFiPpIHhyFRrfepDsSdQqsFffFUuqQVvxXPpJjTtsSUunLlUeEXNnxuaifFFbBaAfqQIizZGgNTtoONGxXLlRrjvVJgpPqrRVvXHaABsSuUhmbBjmMUuJeiwWdXqcCOoTZxTtXzFgzFtTCWwcnqwWQdDaBbxXbNndSHhGgwDdVvUuWwWdDsLRrOvOoqQiIVmMXJluULjZqYzYyxXOQqqQqiDdESseiIyYkzOZzoYnGgNyZKpPItTOoEeFGgfJjZzJjlLbBFfRsoOxkKXSSsUuHOouUYyMLynNYlyYIiSsETXxtHeEhYYyRroYyOFwWfGgnNAaJBZKkzCVJjvYyLlsBBblLZPpzIijWnNADdZBbUlLuzXxawJjWxXwIiAqQaMJChHubBgGFfUcGgOFfonNlLUNtAaTeuUEIiLldVvvVrbYylLTfFtBydDYWwcFfQxLEelbBSsXqBHXcxtTTUSswWAautNeEnQNqQoAaSddDDEeslhHuZHTthVvzDmMnWwlLbcCiIigAaCclLGlNndDCBfFRrfbBgeeEFfrRlbBLiwJsSjWIoODdROoYwWynNrvRrIiRrVoOQlLqBOobAcCaRHrRugJSRrgGseEoGVdwdCAIiaQqIivRmHhOXxtriIRTGKkgfFoiTtFfJjpPWwtTRryZXspPrRSxLlmMOoIyYaFfAZyYzHzTsStZoODUrPpIiJxmMoOojJOzrRZhsSMmrRNnvJsSisWwnNCcWocCOpPdDNyrRYyvAaVafFGgAXqQUyYukKTZPpztvwWeEpPDdMvcVvCsSNnxzZUuQqSSssjJXNnuJTMmZzrWwJzZjRkpNnyUrRpeEeGIyYEzZveVvqpPZTtsSzNnQsnWwvdDVSTvmSsUuMKkVDJjWOoBPpGgKkzeEvVZBbGVvDdkKhHPpgfFJjkKbfpPFwTtfFLjJlDdcCdxfFXTtVJCccCjQlLqrpPHivtqvVLlQGSqbBuUIQqiBblLilLncTtCiINyYNuPbBOJGgWwGgzZlLWpAamiIMsuXlcCiIAPUuiIbWFfqQwBeEFZzfDdpaOorZzRwBbFfHneELlHhlLDdBjhHBbPpJEeQqbLlQxSsXqNvMmnNVhWyCcnNBpPbNpzZkKsDhHdSVfVvdoAaCcjJbLLlHhNnleEVhHUpPrVyxbBCcVvbBbzZBXsbBBFfoOGvHhfFxXErReFcAVvgtTnVtTdDvFwWjJYypAIvVnNmMbBtTFfiBHqQLGgleEsxXShEfFeSIxIiXkKjMkKmdZzKNnkWwDtAaTfsOoSVvFCwngSshHLlvViIGMMbBbBVvrxXfFBgGbPwfSTtsFXxKeEkSXxsGHhgQxXpPBsSjNnJFISsinNftKklLwWuoOdDUMXxyXkKVczZCvxBLldDSXurvVRUpyDfFFUufdSOojJnNMmzhMZzKqEerzZpRtTfFlLugGIiZzIpPiUWwWzXxZwiAasSMmOgfFmUuWwMkBbKGyYoEhHwWefRrFfFLlMmrRQaAqChKkgGHHhcfFyBbCxeEXxxxXXXCcuDdPfIiKkhYyUXxuFffFHtThWwHDdOofCcfOSeEsoetTOodDEKcrzHhZeEKWwEPpuUecCvVBbowWOoPpZzRnNQqrOkMaAmnjJXxcCNvPpVeEeEQRcCJjtTrBbRrUuEepoOPmqQyYMMmmgGMNnGghKkOoHsSgzZqQIiGgGFfqvVkvOoVEeZzKqpEhHaCcMmAthNnHPpwWTBbVvZzvLRrVXxvKRcCExXQFfZUuzHhrRoBbpWESNnseEeSUuslLGgftTFwrPpoOhUkVvKPpvVGzZgBbuiBpPbplLTVvtPdDPRoqxSsXQOXxrjJlgGsSCcQyJZzqQEeoObpPyqQIXVvmFfMZTtxsSYSsRrWwykPmMuUxXpKJkKMmjIiKkKtBvVbyUuhHwWvaAVygNnGcCklLlLKXxYYIiyVVvtTkKUmhHmMMunVVvvkKIiJkKXxjMKDdFfkmUpPucCTtpPpAaYyUuPyIifDdFwzuUZlLOonNdDsZDdnNhHAaSsIiPzZpEeywPpRrCMELlebBmNAKkaKCcsuUSuUtNnTKEeaAyYkUuqQkNVvoOJLRrRrzNnmMCaDdnxXhHNAYyuSsUIUPpubbaABeiIzZtTcCfFcCTOotaAEUaIjxXJZzWwGgSsiKkOjsSJogPXxpVpPvqgGQGgGAQfFfFkPpBBbNBbnREeUpPbdaADBTtuRJRrjjXfFGgskFjJfKuUKkqiIyYQmbEeBjJoOcCGgpdCcElLYyecCKktTYycJvVGgitTIjLlRxxXXaAfxXzZgGFfJjodDAYyeiIEXxaAGYygpOoVGgvPaFfjcevVECJyYUuXxdDLlCKkcqQPhsVvSzxNRrgGTtnWwXAaZwWPpMmpPzYysSZeRrEeEUuqQNnEewhuUHnNqQUNngGWKdDIidDPpkwqBpPbmMTSGgNnsmMQqAatEeDdjJlMmKkzZCpPcZJjEeWwzcCGgEpPyjuUwWJYimMkKfFLwWlGgIDIIiidbZzeUQquMmIiZzfFWwEQqettTIidDcCRWvVwrquUQxpPsBbSXRfUusSFLZmMQqAmMFfazrRrRrReErRdwWDXYyxAhbBjJfFgVvIixXGQhHQqoOqHEeNnDbXxBdjRrJaxXMskTQhHqOhHoKlImMiLjJaAjJClFfLYrduTtUhHDRyYIoOcCiJjjSsJzZgGkKTZzSsqQtKsSvseEEeSVxTdIiLOcColDXxtXEeMmbBUQpPSsNnquVvdlLDGgaAyYLQDdbshHScyYCBqhJPpjHlGVvgDOlFfogGOoXxdoODOCcAalKkLjJlHhqLlaAQLljJGLlgWyYwmMNnPpRBBbBZzbMmBwWKkoORelLEHrRwRrWJjYkKyoOrRsDJjpPddDeEWMmhHPPpzZpjkFfCINnicCtTVvHhcVvTtgTtDNCBbcVvVvndAaGYBbydDQqfnNFKMJjmitEPpuUeThaaAOoGgkKAGgwWlLLlHDuUiIgGPuUpPOSscOoCchakKiJjIAfFHHOofFhCIiWpPiIwckKMvVHAabvVvVgGBKkaAPaApPprRCcBbhxCcXVvBbSxXsyYMJTtjXxNngeEUuKkAaPpgmMgGGrRwWTtBbZsSzGjJWJjPpwtTXpPxjJhHevVofFOBgIiQLltTqGkKeaApkQqiIpPkqQJjXFfxRYyIigGPpryYhlLHhHqQCcqQzZnjJNOoGgYvVuUNnLlQqyrpPRPZNiInzpXFftTxKkZzQWwtTuQLYyRrmoODdmMWwMloOgGVpPvqUNfFdDcCYjJxLlnNXDdPpiIwWCcynqaeEhHEeAkKoHhNnaTtQqILlbBrRcCFfDdmMIRrYyvZzjJVWwXiIxqbBSshHQyYiSyYYvVhHybuUBbPpuUxXpaAKkPcCwQqqQWFmMfyQqPqQWwvWwVWwQqbWwBpEeqQPpZzWiIwPpRrEeiIZzNNnAasSfFnIiiUkKuIqQVvViINnYGgycCvtVvTsBbpPuUtZBbzFfHhHzrRZQqhzZDLzZSTnKkNtRrCzZcMAamRUuJjwzEeZWTEemDcCdUunNJkKjMElLJjVvCceOXxpagRPpyYfAaFEeZXRrxJjDqfFQeEtkKTyYdKfFpEoYwWyOeBbQqDdSaAnNNKknQmMqsSSKkKyYyYkCcUuyYxXfFZzYpGgwdDTnPpKkNLlEeeEjJaAtKkzjJhHpWwPNKkpPXxnFVvfNjrKyYkoORJWkKbiIBrRwCKlLknrRNDeEJjhInNiqQHOoSsyYbBfFfyYkKVvFhIDxXQqdQqAanNTtTUKkuOZyYzoEeYyDeQqENVvnLldmBbeEMbUuBUjJuhGgDdkKklLtTeEPpnNKqQpPfFizZIxXCdDuUzffFFZcNMmTtyYAaAannDMmdORroNwlLWCqQrRYyWwpPfFEesScGPQqjJGFfgdHAahgGDhHpPsSpCcjJkKvVgRraVvwMmWdDGgrRAstTSXxkKxrRJjnNkFDdfKXcWzZwaoAaMFfmONneEeEqQQqWNnoBbOtTwHhweEQqWQoOZzfiXVvxIpPFUOorRPJjpIirRsCcTmMtSbBZzoOSFgGfsSKkVvsZzOowWyYCcMmKgwUuWGkhmMhHBbFfYYyyrRDdXOoxlHjJWwWSsBbwVvhpMmPwWLHyBbUuYSyYsfFuWiIMmuUgGMmMLRrlmaAAAeEamnNMsqQaASxUuXxJjZwWzDdXZzakvVkKlLKNPpnDdkKRVvRrfKkKkUuFrCcclLWwpKkPCDdzAaZFCcfxXXOXxohHxwxXYyeEZzcKkEeYyFfDQqMmducCUcKkgCctTKkCctTGCLlooOOjJkKonNOCLltTcCVvPpCTtSRDsSRrdAyYarcCPpRHhGcCoOmMKJjkgraAsSRrVvlLpPQqGgayYbBVvuUPoOpPpaAZzNHhLlnDZzdADBHhbdPpaASsxXMePpMhHmryszZSYRTAagGlLtdDERrItOoTXdaADxhkGgoEeOAiIaslLSKPJjRrwWZzNnreERHhAhHqTEetVvQerZzmMRBbESsaFffBbfFVkKvAayYDdEEehAaHMWwSsuUmemLlMIiFvVgfFGEeFfCcIUuioOxjJXEuUeaVvFfAdEeaMeECcmADcVvCcXRraAFfEeFaYyAfxZzAaYyCTsSuDdUtBbxXprifFpPAadBbDYSnCcNrRAashDdlLKyYnCcvVBbNsSaAilLIxQquYyUXimMNndDtJjTkKBHAahbzZIksNnSmMKieEIisSwjNnUuZiICczJXxrTtRpPkKWgtzZTGQJjCcqgNQqnKGiNnIEegkvVxXLXasSAxdSsDYylXxOWKzZmMWwkPpGzZWCqQcmvVMFgGfOPpouUWwlLUuCjBbJcwIJjiaAgCfEoOmMeFIiWwwcCOoWyYDtTWwdpPcblLbBXxxXJjVsxXStoOVgGvfFnNbBQtaANnJjInNeNEenEiZzkKjJTWvVCcwIiShHsbBhHbxXBDlLgGdGgPpxuUXKkAaUmZzZzMufFjkKnpPUuNYyDdUuwWtNtxXTnwUumAaMdDDdkKlLtTXxoOYyWPpuUFoVvOwWfUuZzfjJLHhlWwsSKOoUuOoGgJSPpuUZzsWwVvEXxvOoVqQDdIYEsSerRTtyiNUuToOtnzZeXxpWwFfPpOnNJSsjRZzrvVogSiIsGmMiWwIPMVTtviGgXrRxqQBHetTEUuhPqQpjzZYyJbIbBUuYRdDbBrCcwWyQjJBbqocRrCOCczOoEeCcNbBxXgiIEezZGUuNnvTXxZzbBtQqOocCxzZgtIiTdDDRrdGktTKjJVvXvVZzVnJjwWuIifFOoUZKkKFNnfQqksgZkKzfFzuUHhZGRiIEerdOHhoSFfsDwWAaSXxeEQqIbFpPfKkcWwdDsSTFfSstCHhBDdvVTgyiIkKUuYgGGWwfFmwWHhXRrxWWomMRrnNOwaWwAnNwnOhHoiINMDkKdZztRrqaAQmMVvSaAhZzHWIiEebwWWwBbBUMmuWwwMmWwVJjxXvSpGwFfWUugPdDoODdstTjZJjzJMFfoOmDuUdVvbBjJdvkKCcdDVafFeEiIgGCcCfFcULlVvCukKUccsSCeZzMmNxzZLlXiIIiCDdcwWnRGgrEqQHhpPYyNnaASPuUuUpJjsYywWwWHhuAHjJYyfZFfzFfYyYyDdFfbBpPPpcCFZLlGmMFLlgGfgGgnNKSskQIiqzpPqQdTtFLuUlyYoXxLxXlTtEeAfFAaaqQtTcCoVvOtwWzZpPZzTQqQqOXxAatHhTRvDdsSOooOiIkvVKVvVrRxXggNnZzxXGnNkKSKkCGdDgwWcVgGPpvRdqwWQLlDriIjIiJjeHhvVUuEcCXxJsJjJjckMAaqQmuUKGgIYAsSaXRrxyiEeClVvLmzjJZyoOLlYfFMJjGqQrbLljZzJwWOoWwBPpjJiIzgpPGZfMXxbBms\"\n\nfun main() {\n    run {\n        val sample = \"dabAcCaCBAcCcaDA\"\n        val expected = \"dabCBAcaDA\".length\n        val actual = Day05(sample).react()\n        if (expected != actual) {\n            throw Error(\"react() test failed: expected $expected, got $actual\")\n        }\n\n        val expected2 = 10774\n        val actual2 = Day05(input).react()\n        if (expected2 != actual2) {\n            throw Error(\"react() test failed: expected $expected2, got $actual2\")\n        }\n    }\n\n    run {\n        val sample = \"dabAcCaCBAcCcaDA\"\n        val expected = \"daDA\".length\n        val actual = Day05(sample).fullyReact()\n        if (expected != actual) {\n            throw Error(\"fullyReact() test failed: expected $expected, got $actual\")\n        }\n        \n        val expected2 = 5122\n        val actual2 = Day05(input).fullyReact()\n        if (expected2 != actual2) {\n            throw Error(\"fullyReact() test failed: expected $expected2, got $actual2\")\n        }\n    }\n\n    println(\"All tests passed!\")\n}", "description": "/**\n * Reacts a polymer string by repeatedly removing adjacent units of the same type but opposite polarity.\n *\n * Iterates through the polymer string and checks consecutive characters. If two adjacent units are the same\n * letter with opposite cases (e.g., 'a' and 'A'), both are removed from the string. After a removal, the index\n * steps back one position (if possible) to re-check for new reactions. This process continues until no more\n * reactions are possible.\n *\n * @param polymerInput the polymer string to process; defaults to the class's input if not provided\n * @return the length of the polymer after all possible reactions have occurred\n */", "canonical_solution": "fun react(polymerInput: String = input): Int {\n    var polymer = polymerInput\n    var index = 0\n\n    while (true) {\n        if (index >= polymer.length - 1) break\n        if (polymer[index] same polymer[index + 1]) {\n            polymer = polymer.removeRange(index..index + 1)\n            if (index != 0) index--\n        } else {\n            index++\n        }\n    }\n\n    return polymer.length\n}"}
{"task_id": "27", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "getGroupedCalories", "fn_name": "getGroupedCalories", "fn_signature": "fun getGroupedCalories(input: List<String>): MutableMap<Int, List<String>> {", "context": "fun addToGroup(\n    groupedCalories: MutableMap<Int, List<String>>,\n    group: MutableList<String>\n) {\n    groupedCalories[group.sumOf { it.toInt() }] = group\n}\n\nfun getGroupedCalories(input: List<String>): MutableMap<Int, List<String>> {\n    /* GENERATE THIS FUNCTION */\n}\n\nfun part1(input: List<String>): Int {\n    val groupedCalories: MutableMap<Int, List<String>> = getGroupedCalories(input)\n\n    return groupedCalories.keys.max()\n}\n\nfun part2(input: List<String>): Int {\n    val groupedCalories: MutableMap<Int, List<String>> = getGroupedCalories(input)\n    val sortedCalories = groupedCalories.keys.sorted().reversed()\n\n    return sortedCalories.take(3).sum()\n}", "test": "// Self-contained test function\nfun main() {\n    val testInput = \"\"\"\n        1000\n        2000\n        3000\n\n        4000\n\n        5000\n        6000\n\n        7000\n        8000\n        9000\n\n        10000\n    \"\"\".trimIndent().lines()\n\n    val result1 = part1(testInput)\n    val expected1 = 24000\n    if (result1 != expected1) {\n        throw RuntimeException(\"part1 failed: expected $expected1 but got $result1\")\n    }\n\n    val result2 = part2(testInput)\n    val expected2 = 45000\n    if (result2 != expected2) {\n        throw RuntimeException(\"part2 failed: expected $expected2 but got $result2\")\n    }\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Groups calorie values by contiguous non-empty lines and maps each group to its total sum.\n *\n * Iterates over the input list of calorie values represented as strings. Consecutive non-empty\n * values are collected into a group until an empty string is encountered, which marks the end\n * of that group. Each group is then added to the result map with the sum of its integer values\n * as the key and the original string values as the list. The last group is also added if it\n * ends without a trailing empty string.\n *\n * @param input list of strings where each string is either a calorie value or an empty separator.\n * @return a mutable map where keys are the integer sum of each group's calorie values, and\n *         values are the corresponding list of calorie strings.\n */", "canonical_solution": "fun getGroupedCalories(input: List<String>): MutableMap<Int, List<String>> {\n    val groupedCalories: MutableMap<Int, List<String>> = HashMap()\n    var group: MutableList<String> = ArrayList()\n    for (calories in input) {\n        if (calories.isNotEmpty()) {\n            group.add(calories)\n        } else {\n            addToGroup(groupedCalories, group)\n            group = ArrayList()\n        }\n    }\n    if (group.size > 0) {\n        addToGroup(groupedCalories, group)\n    }\n    return groupedCalories\n}"}
{"task_id": "15", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "checkTrees", "fn_name": "checkTrees", "fn_signature": "private fun checkTrees(slope: Pair<Int, Int>): Int {", "context": "/**\n * Copyright (c) 2021 by <NAME>\n * Advent of Code 2020, Day 3\n * Problem Description: http://adventofcode.com/2020/day/3\n */\nclass Day03(private val input: List<String>) {\n\n    private val width = input.first().length\n\n    fun solvePart1(): Int = checkTrees(3 to 1)\n\n    fun solvePart2(): Long = listOf(1 to 1, 3 to 1, 5 to 1, 7 to 1, 1 to 2).fold(1L) { acc, i ->\n        acc * checkTrees(i)\n    }\n\n    private fun checkTrees(slope: Pair<Int, Int>): Int {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    private operator fun Pair<Int, Int>.plus(slope: Pair<Int, Int>) = Pair(\n        (first + slope.first) % width,\n        second + slope.second\n    )\n}", "test": "fun main() {\n    val exampleInput = listOf(\n        \"..##.......\",\n        \"#...#...#..\",\n        \".#....#..#.\",\n        \"..#.#...#.#\",\n        \".#...##..#.\",\n        \"..#.##.....\",\n        \".#.#.#....#\",\n        \".#........#\",\n        \"#.##...#...\",\n        \"#...##....#\",\n        \".#..#...#.#\"\n    )\n\n    // Simulated actual input (as if loaded from \"20day03.txt\")\n    val actualInput = \"\"\"\n        .....##.#.....#........#....##.\n        ....#...#...#.#.......#........\n        .....##.#......#.......#.......\n        ...##.........#...#............\n        ........#...#.......#.........#\n        ..........#......#..#....#....#\n        ..................#..#..#....##\n        .....##...#..#..#..#..#.##.....\n        ..##.###....#.#.........#......\n        #.......#......#......#....##..\n        .....#..#.#.......#......#.....\n        ............#............#.....\n        ...#.#........#........#.#.##.#\n        .#..#...#.....#....##..........\n        ##..........#...#...#..........\n        ...........#...###...#.......##\n        .#..#............#........#....\n        ##.#..#.....#.......#.#.#......\n        .##.....#....#.#.......#.##....\n        ..##...........#.......#..##.#.\n        ##...#.#........#..#...#...#..#\n        .#..#........#.#.......#..#...#\n        .##.##.##...#.#............##..\n        ..#.#..###......#..#......#....\n        .#..#..#.##.#.##.#.#...........\n        ...#....#..#.#.#.........#..#..\n        ......#.#....##.##......#......\n        #....#.##.##....#..#...........\n        ...#.#.#.#..#.#..#.#..#.##.....\n        #.....#######.###.##.#.#.#.....\n        ..#.##.....##......#...#.......\n        ..#....#..#...##.#..#..#..#..#.\n        .............#.##....#.........\n        .#....#.##.....#...............\n        .#............#....#...#.##....\n        .#.....#.##.###.......#..#.....\n        .#...#.........#.......#..#....\n        ..#.#..#.##.......##...........\n        .....##..#..#..#..#.##..#.....#\n        ..##............##...#..#......\n        ...#..#....#..##.....##..#.#...\n        #.....##....#.#.#...#...#..##.#\n        #.#..#.........#.##.#...#.#.#..\n        .....#.#....##....#............\n        #.......#..#.....##..#...#...#.\n        .....#.#...#...#..#......#.....\n        ..##....#.#.#.#.#..#...........\n        ##..#...#.........#......#...#.\n        ..#...#.#.#.#..#.#.##..##......\n        #............###.....###.......\n        ..........#...#........###.....\n        .......##...#...#...#........#.\n        .#..#.##.#.....................\n        .#..##........##.##...#.......#\n        .......##......#.....#......#..\n        .##.#.....#......#......#......\n        #...##.#.#...#.#...............\n        ........#..#...#.##.......#....\n        ...................#...#...##..\n        ...#...#.........#.....#..#.#..\n        .###..#........#..##.##..#.##..\n        #...#.....#.....#.....#..#..#..\n        ###..#.....#.#.#.#......#....#.\n        #........#....##.#...##........\n        .#.#..##........##....##.#.#...\n        #...#....#.###.#.#.........#...\n        ...#...##..###.......#.........\n        ......#....#..##..#.....#.#....\n        ........#...##...###......##...\n        ..........##.#.......##........\n        ...#....#......#...##.....#....\n        ###.#.....#.#..#..#....#...#..#\n        .#.....#.#....#...............#\n        ..#....#....####....###....#.#.\n        ....##........#..#.##.#....#...\n        .......##...#...#..#....####...\n        #...##.#......##...#..#........\n        ..##..#.##....#.......##.#.#...\n        ..#.#...............#...#.#....\n        ....#.....#.#.....#.##.......#.\n        ...#.#..##.#.#..............##.\n        ..#.....#...#.............#.##.\n        ##..#.#...#........#..#.....##.\n        ...........##...#.#.###...#....\n        ...#.#.#..#..................#.\n        .#...##.............#...#......\n        ..#..#...#.#.......#...#.....#.\n        ..##.......#.#.................\n        .##..#........###.....#....#.##\n        ......#..###.......#....##....#\n        ....#.....#.................#..\n        ........#...#...#..............\n        ...#..#.###.......#..#.#.#.##..\n        ..#...#.....#....#.........#...\n        ...#.............#........###..\n        ......#..............#......#..\n        #..#...........#...#..........#\n        ...##...#.###..#...#.....#.#...\n        ....#..##......#.......##......\n        ....#....##.#...#.#..#....#...#\n        .#...........#..#....##...#..##\n        ..#.#.................###.#...#\n        ..#.#.#...##...........#.......\n        ..........#..##...#.#..##....##\n        ........#........#.##..#.#...#.\n        .....#...##.......##......#...#\n        ....#...#..#..#.....#..........\n        .#..#......#..#..#..###.......#\n        .##..........#...#...#.#.....##\n        ..#..........#.#.#...###.......\n        ....#................#...##....\n        .##..#....#..........#.#.#.....\n        ..##...#.#........#.....#.##...\n        ....####.....#..#.........##..#\n        ......#.........#...#..........\n        ....#...................#..##..\n        .##....#.#.........#....#...#..\n        ....##...##.....#..####........\n        ..##.#....#.#.......##...#.....\n        #...#.#.#...#..#..##.....#.....\n        #..................###.....#...\n        #.#.....#.......#.#...###.#....\n        .#..#....#............#........\n        #.#....#..#.#...............#..\n        ..#..#..#.............#......#.\n        ..#.......##...................\n        .#....#.........#....#.#.#..#..\n        ....#....#..#...............#..\n        ......#..#..##......#.........#\n        ..#.##........##......#..#..#.#\n        #.....#.#....#.........##...#..\n        ###..............#....###...##.\n        ....#..##......#.......##......\n        ......#...#.##......##....#..#.\n        ..........#....#..##.......#..#\n        .#..#...##..#...........#..#..#\n        .....#....#...#..###...###....#\n        .#####..#...#.#.#..#.#.###...##\n        ..##............##.#...#.##...#\n        .##..#...#...#....##.#..#..##..\n        .#....#...#............##..#...\n        .#.#......#....#....#..##..##..\n        .........#...#.......#.##..#...\n        #.........#.....##.....#..#..#.\n        ...##.#...#...#..#..#....##..##\n        .#............#...#....##......\n        ..#...#.##.........#.#......#.#\n        ....#.##........#.........#..##\n        #.........#......#.#......#..#.\n        ........#.#.......#.#........#.\n        ..#..........##.#...#..#.#.....\n        ..#...#....#...#...#..#.#..#.#.\n        .#.........#....#..#####..#....\n        #.#....#.#.###...#.............\n        ..##...........##......##......\n        #.....#..#....#...............#\n        ...#.#..#....##......#...##....\n        ...#........#.....#...#..#.....\n        .#......##.........#......#....\n        ..#..###.##...#.#.....#........\n        .............#......#..#.......\n        ..#...............#.#...#..#..#\n        .......#..#...#.#####......#..#\n        .........#.....#...............\n        ##........#............#.#.....\n        .#...#.....#..#..#...#....#...#\n        ..#....#....##......##.....#.#.\n        #...##..##......#...#....#.....\n        ....#.#.#.....###....##.##....#\n        ..........##...##.......#......\n        ..#.......#...##.#....##.##....\n        ....#........................#.\n        ...#...#.#.##...#.....#...#..#.\n        .#....##..#..#..........##..##.\n        .#.....#..#...#.##.....#.......\n        .#.##...#.#..#.....##....#...#.\n        .##...#........##....#..#......\n        .....#........#..........#.#..#\n        ....#..##.......#..#.....#.....\n        ...........#...#........#.##..#\n        .....#..#....#..#.#.....#....##\n        .....#....#.##.#..##...........\n        ...##.......##.........#.......\n        ...............##..#....#.#....\n        .......###..#........#..####.##\n        .......#.##...#.#....#.####....\n        ....#...............#..........\n        ##.#.......#.....#......#...#..\n        ......##.....#....#.....#..#..#\n        .....#...##.............#......\n        #.#.##.#.....#..#........#.....\n        ......##....#..#........#......\n        ............#........#..#.#....\n        ##.......#......#...####..#.##.\n        ..##..#...#.............#.##...\n        .....#..##......#.##......###..\n        ............#........#........#\n        #.#.#.#...#.#.....#.........#..\n        .........#...............#.....\n        .............###.#.......#....#\n        ###.##..#..#..........#....#...\n        #......#...#..#..#.....#.##....\n        ............#....#....#..#.....\n        ..#.#....#...#......#.#..#..##.\n        ...#........................#..\n        #.#...#..........#......#.#....\n        .........#................#...#\n        ##.....#....#........##.......#\n        #...##........#...#...........#\n        ...#...#..........##.......#.#.\n        ..#.#.#....#......##...........\n        ...#.#...#.##.#..#.#.##........\n        #....##.....###..#.......#.....\n        ###.....#.#.#...#..#.........##\n        ..#......#..###...#.#.#.....#.#\n        .#....#.....#............#..##.\n        ....#....##..........#.....##..\n        #...........#....#...#..#...##.\n        ..#.......#.....#..........#...\n        .#..#................#......#..\n        ..#......#.#...#..#.#....#....#\n        ...#..#...###..#..##....#.#....\n        ..#..............#.....#.......\n        ...#.#...#.........#.#.........\n        ##......##...........##.#.##..#\n        ..#..##..#....#.#......#.#...##\n        ...#.###....###...#.....#......\n        #.#................#......#....\n        ..#.....#.....#....##.......#..\n        .#.#...............##..#.......\n        ...#....#.......#.#.....##..#..\n        .........#....#.......#.#...##.\n        #....#......##.#.........##...#\n        #.............#..##.#.#..##....\n        ...#....#..#...#....#.#.#.#...#\n        .#....#....#..##.....#.#...###.\n        ##............#.#...##.#..#.#..\n        ##.#....##.....#..#..###....#..\n        ##....#................##......\n        ...##..#...#..###....#.....##..\n        .#...##......#..#.#.....#...#..\n        ..##......##...#.##.......#....\n        ......#.....#.....##........#.#\n        ##....#...........#............\n        #.......#....#..#.##..##.#..#..\n        .#....##.#.....#..#..#.........\n        .#....#.#.#...#.....##.....#.#.\n        .......##.#.#........#......##.\n        ##........#.##.......#...#..#..\n        ...###..##....#.#....#.#.......\n        ......#.......#...##.....#...#.\n        ..#......##.#......#.....#.....\n        .....#.....###...#.............\n        #...#.#...#...#..#......#......\n        #.....#.......###.#....###.#...\n        ...#.......#....####....##..#..\n        #.#.....#....#........#.......#\n        .........#.......#......#.#...#\n        ..##....#.....##...............\n        ..........#..#.#..#......#.....\n        ..................##...##.#....\n        ........#.......#...#..#.#.#...\n        .....#.#..##..#..#.#..#.......#\n        .....#........#..#..#....#....#\n        ##............#..#..#...#....#.\n        .....#....................##..#\n        ........##.#....###............\n        ##.......#.##................#.\n        .....###.#..#..#...#....###.##.\n        .#......#.#....#.....##.#......\n        ...##......##.........#...#....\n        ....####..............#........\n        #...#.#..##..##.........##.....\n        ......#......#....#..#.........\n        #.....#.....#.##...............\n        ..#.##..#...##.#.####..#....###\n        #..#......#....#.##..##...#.#..\n        #....#.......#.....#.....#.#...\n        ##.......#.....##...#.....#....\n        ...#...##..........#..##..##..#\n        .###..#..##...#....#...#..#....\n        ......##..###.......###...#....\n        ....#...#.#.......#.##...##..##\n        #.#......#..##.#.#..#..#..#....\n        ......#........#.......#.......\n        ..........#.#.....##...........\n        ......#..#........#..#.#..###..\n        ##..#.............##..#........\n        .........#....#.....#.........#\n        .....#..##...#..#..##.##......#\n        ###..#...........#.......#....#\n        ...............#....#.#........\n        .##.#...#.#........##....#.....\n        .##.###...##..###....#...#...#.\n        .##..#....#.#.#...#.#.#.#...#..\n        .###.#...#.......#....#..#.....\n        ..#..#.#.#.#........#.....##...\n        .#.......#.#...#.#...........##\n        ...#.....##....#.....##...#....\n        ................#.....####...#.\n        .#.#......#.......##...#.##....\n        .###.........#.#......#..#.#...\n        #......#...#....#..##.......#..\n        .##..#....#..#...........#...#.\n        .#...#.......##........#.##....\n        ..#...........#...##...........\n        .....##....##......#....#..#...\n        #......#.#...#.##.#...##....#..\n        #....................#...##...#\n        ..#............#........#......\n        .............#.........##.....#\n        ...#...#......##.#...#...#.#...\n        ..#...#.#.................#....\n        ....##...#....#...###.##......#\n        ...#....#...#..#...#....#.....#\n        ...##.#........#..#.........#..\n        ..##.....#..##...#.....##...#..\n        #.........#.#.#...#......#...#.\n        #.#...........#...#..#..#..##..\n        ..#..#..##....#..........#.###.\n        .....#..#....#.#...#...#..#..#.\n        ###.....#..#.................#.\n        .#..##.##.#......#....##..#....\n    \"\"\".trimIndent().lines()\n\n    // Helper for assertion-like checks\n    fun assertEquals(expected: Any, actual: Any, message: String) {\n        if (expected != actual) {\n            throw AssertionError(\"Test failed: $message\\nExpected: $expected, Actual: $actual\")\n        }\n    }\n\n    // Part 1 - Example\n    val part1Example = Day03(exampleInput).solvePart1()\n    assertEquals(7, part1Example, \"Part 1 - Example input\")\n\n    // Part 1 - Actual\n    val part1Actual = Day03(actualInput).solvePart1()\n    assertEquals(203, part1Actual, \"Part 1 - Actual input\")\n\n    // Part 2 - Example\n    val part2Example = Day03(exampleInput).solvePart2()\n    assertEquals(336L, part2Example, \"Part 2 - Example input\")\n\n    // Part 2 - Actual\n    val part2Actual = Day03(actualInput).solvePart2()\n    assertEquals(3_316_272_960L, part2Actual, \"Part 2 - Actual input\")\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Counts the number of trees encountered when traversing the map using a given slope.\n *\n * Starting from the top-left corner, the function repeatedly moves by the given slope\n * until reaching the bottom of the map. The horizontal position wraps around when it\n * exceeds the map width. Each visited position is checked for a tree ('#'), and the\n * total count is returned.\n *\n * @param slope a pair of integers representing the rightward and downward steps per move\n * @return the total number of trees encountered along the traversal path\n */", "canonical_solution": "private fun checkTrees(slope: Pair<Int, Int>): Int {\n    var trees = 0\n    var location = 0 to 0\n    while (location.second < input.size) {\n        trees += if (input[location.second][location.first] == '#') 1 else 0\n        location += slope\n    }\n    return trees\n}"}
{"task_id": "52", "prompt": "<Construct prompt based on other fields>", "language": "kotlin", "entry_point": "solution", "fn_name": "solution", "fn_signature": "fun solution(n: Int, costs: Array<IntArray>): Int {", "context": "// https://github.com/antop-dev/algorithm/issues/530\nclass P42861 {\n\n    fun solution(n: Int, costs: Array<IntArray>): Int {\n        /* GENERATE THIS FUNCTION */\n    }\n\n    private fun IntArray.find(x: Int): Int = if (this[x] == x) x else find(this[x])\n\n    private fun IntArray.union(x: Int, y: Int) {\n        this[find(y)] = find(x)\n    }\n\n}", "test": "fun main() {\n    val sut = P42861()\n\n    fun assertEqual(actual: Int, expected: Int) {\n        if (actual != expected) {\n            throw IllegalStateException(\"Assertion failed: expected=$expected, actual=$actual\")\n        }\n    }\n\n    // example 1\n    assertEqual(\n        sut.solution(\n            4, arrayOf(\n                intArrayOf(0, 1, 1),\n                intArrayOf(0, 2, 2),\n                intArrayOf(1, 2, 5),\n                intArrayOf(1, 3, 1),\n                intArrayOf(2, 3, 8)\n            )\n        ),\n        4\n    )\n\n    // example 2\n    assertEqual(\n        sut.solution(\n            7, arrayOf(\n                intArrayOf(2, 3, 7),\n                intArrayOf(3, 6, 13),\n                intArrayOf(3, 5, 23),\n                intArrayOf(5, 6, 25),\n                intArrayOf(0, 1, 29),\n                intArrayOf(1, 5, 34),\n                intArrayOf(1, 2, 35),\n                intArrayOf(4, 5, 53),\n                intArrayOf(0, 4, 75)\n            )\n        ),\n        159\n    )\n\n    // example 3\n    assertEqual(\n        sut.solution(\n            5, arrayOf(\n                intArrayOf(0, 1, 5),\n                intArrayOf(1, 2, 3),\n                intArrayOf(2, 3, 3),\n                intArrayOf(3, 1, 2),\n                intArrayOf(3, 0, 4),\n                intArrayOf(2, 4, 6),\n                intArrayOf(4, 0, 7)\n            )\n        ),\n        15\n    )\n\n    println(\"All tests passed.\")\n}", "description": "/**\n * Computes the minimum total cost to connect all islands with bridges.\n *\n * Uses Kruskal’s algorithm with Union-Find to build a Minimum Spanning Tree (MST).\n * The edges (bridges) are sorted by construction cost, and added one by one if\n * they do not form a cycle. The process stops once enough edges are chosen to\n * connect all islands.\n *\n * @param n the number of islands (nodes) to be connected.\n * @param costs an array of edges, where each entry is [from, to, cost] representing\n *              the construction cost of a bridge between two islands.\n * @return the minimum total cost required to connect all islands.\n */", "canonical_solution": "fun solution(n: Int, costs: Array<IntArray>): Int {\n    costs.sortBy { (_, _, cost) -> cost }\n    val root = IntArray(n) { it }\n    var ans = 0\n    var count = 0\n    for ((from, to, cost) in costs) {\n        if (root.find(from) == root.find(to)) continue\n        ans += cost\n        root.union(from, to)\n        if (count++ >= n) break\n    }\n    return ans\n}"}
