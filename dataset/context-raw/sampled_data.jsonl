{"path": "src/main/kotlin/dev/shtanko/algorithms/leetcode/TrappingRainWater.kt", "owner": "ashtanko", "repo_id": 203993092, "is_fork": false, "languages_distribution": "{\"Kotlin\": 5856223, \"Shell\": 1168, \"Makefile\": 917}", "content": "/*\n * Copyright 2020 <NAME>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dev.shtanko.algorithms.leetcode\n\nimport dev.shtanko.datastructures.Stack\n\nfun interface RainWaterStrategy {\n    operator fun invoke(arr: IntArray): Int\n}\n\nclass RainWaterStraightForward : RainWaterStrategy {\n    override operator fun invoke(arr: IntArray): Int {\n        return arr.trapRainWater()\n    }\n\n    private fun IntArray.trapRainWater(): Int {\n        if (this.isEmpty()) return 0\n\n        var low = 0\n        var high = size - 1\n        var maxLeft = 0\n        var maxRight = 0\n        var ans = 0\n\n        while (low <= high) {\n            if (this[low] <= this[high]) {\n                if (this[low] >= maxLeft) {\n                    maxLeft = this[low]\n                } else {\n                    ans += maxLeft - this[low]\n                }\n                low++\n            } else {\n                if (this[high] >= maxRight) maxRight = this[high]\n                ans += maxRight - this[high]\n                high--\n            }\n        }\n\n        return ans\n    }\n}\n\nclass RainWaterStack : RainWaterStrategy {\n    override operator fun invoke(arr: IntArray): Int {\n        return arr.trapRainWaterUsingStack()\n    }\n\n    private fun IntArray.trapRainWaterUsingStack(): Int {\n        var ans = 0\n        var current = 0\n        val stack = Stack<Int>()\n        while (current < this.size) {\n            while (stack.isNotEmpty() && this[current] > this[stack.peek()]) {\n                val top = stack.peek()\n                stack.poll()\n                if (stack.isEmpty()) break\n                val distance = current - stack.peek() - 1\n                val boundedHeight = this[current].coerceAtMost(this[stack.peek()] - this[top])\n                ans += distance * boundedHeight\n            }\n            stack.push(current++)\n        }\n        return ans\n    }\n}\n", "issues": 4.0, "main_language": "Kotlin", "forks": 0, "stars": 19, "commit_sha": "776159de0b80f0bdc92a9d057c852b8b80147c11", "size": 2394, "name": "kotlab", "license": "Apache License 2.0"}
{"path": "src/day11.kt", "owner": "skuhtic", "repo_id": 572645300, "is_fork": false, "languages_distribution": "{\"Kotlin\": 36109}", "content": "fun main() {\n    day11.execute(onlyTests = false, forceBothParts = true)\n}\n\nval day11 = object : Day<Long>(11, 10605, 2713310158) {\n    override val testInput: InputData\n        get() = TEST_INPUT.trimIndent().lines()\n\n    override fun part1(input: InputData): Long { // divisibleBys: [23, 19, 13, 17]\n        val monkeys = mutableListOf<Monkey>()\n        input.chunked(7).map { Monkey.fromLinesToGroup(it, monkeys) }\n        repeat(20) {\n            monkeys.forEach { it.turn() }\n        }\n        return monkeys.map { it.inspections }.sortedDescending().take(2).fold(1L) { acc, i -> acc * i }\n    }\n\n    override fun part2(input: InputData): Long { // divisibleBys: [2, 7, 13, 3, 19, 17, 11, 5]\n        val monkeys = mutableListOf<Monkey>()\n        input.chunked(7).map { Monkey.fromLinesToGroup(it, monkeys) }\n        val common = monkeys.fold(1) { acc, m -> acc * m.testDivBy }\n        monkeys.forEach { m ->\n            m.setReliefFunctionTo { it % common }\n        }\n        repeat(10_000) {\n            monkeys.forEach { it.turn() }\n        }\n        return monkeys.map { it.inspections }.sortedDescending().take(2).fold(1L) { acc, i -> acc * i }\n    }\n}\n\nprivate class Monkey private constructor(\n    val id: Int,\n    val operation: (Long) -> Long,\n    val monkeyGroup: List<Monkey>,\n    val testDivBy: Int,\n    val toIfTestTrue: Int,\n    val toIfTestFalse: Int,\n    initialItems: List<Long>\n) {\n    private val items: ArrayDeque<Long> = ArrayDeque(initialItems)\n    override fun toString(): String = \"Monkey$id ($inspections): $items\"\n    var inspections: Int = 0\n        private set\n    fun add(item: Long) = items.addLast(item)\n    var relief: (Long) -> Long = { it / 3 }\n        private set\n    fun setReliefFunctionTo(reliefFunction: (Long) -> Long) {\n        relief = reliefFunction\n    }\n\n    fun turn() {\n        items.removeAll { i ->\n            val x = relief(operation(i))\n            inspections++\n            val to = if (x % testDivBy == 0L) toIfTestTrue else toIfTestFalse\n            monkeyGroup[to].add(x)\n            true\n        }\n    }\n\n    companion object {\n        fun fnSum(with: Long): (Long) -> Long = { it + with }\n        fun fnProduct(with: Long): (Long) -> Long = { it * with }\n        val fnSquare: (Long) -> Long = { it * it }\n\n        fun fromLinesToGroup(lines: InputData, monkeyGroup: MutableList<Monkey>): Monkey {\n            val l = if (lines.first().isEmpty()) lines.drop(1) else lines\n            require(l.size in 6..7)\n            val id = l[0].substringAfterLast(\"Monkey \").trimEnd(':').toInt()\n            val items = l[1].substringAfterLast(\"items: \").split(\", \").map { it.toLong() }\n            val opDef = l[2].substringAfter(\"= old \")\n            val testDivBy = l[3].substringAfter(\"divisible by \").toInt()\n            val toIfTestTrue = l[4].substringAfter(\"true: throw to monkey \").toInt()\n            val toIfTestFalse = l[5].substringAfter(\"false: throw to monkey \").toInt()\n            val operation: (Long) -> Long = when {\n                opDef.startsWith('+') -> fnSum(opDef.substringAfter(' ').toLong())\n                opDef == \"* old\" -> fnSquare\n                opDef.startsWith('*') -> fnProduct(opDef.substringAfter(' ').toLong())\n                else -> error(\"Invalid input\")\n            }\n            val monkey = Monkey(id, operation, monkeyGroup, testDivBy, toIfTestTrue, toIfTestFalse, items)\n            monkeyGroup.add(monkey)\n            return monkey\n        }\n    }\n}\n\nprivate const val TEST_INPUT = \"\"\"\nMonkey 0:\n  Starting items: 79, 98\n  Operation: new = old * 19\n  Test: divisible by 23\n    If true: throw to monkey 2\n    If false: throw to monkey 3\n\nMonkey 1:\n  Starting items: 54, 65, 75, 74\n  Operation: new = old + 6\n  Test: divisible by 19\n    If true: throw to monkey 2\n    If false: throw to monkey 0\n\nMonkey 2:\n  Starting items: 79, 60, 97\n  Operation: new = old * old\n  Test: divisible by 13\n    If true: throw to monkey 1\n    If false: throw to monkey 3\n\nMonkey 3:\n  Starting items: 74\n  Operation: new = old + 3\n  Test: divisible by 17\n    If true: throw to monkey 0\n    If false: throw to monkey 1\"\"\"", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "8de2933df90259cf53c9cb190624d1fb18566868", "size": 4099, "name": "aoc-2022", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/dev/shtanko/algorithms/leetcode/SortArrayByParity.kt", "owner": "ashtanko", "repo_id": 203993092, "is_fork": false, "languages_distribution": "{\"Kotlin\": 5856223, \"Shell\": 1168, \"Makefile\": 917}", "content": "/*\n * Copyright 2020 <NAME>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dev.shtanko.algorithms.leetcode\n\nimport dev.shtanko.algorithms.extensions.isEven\nimport dev.shtanko.algorithms.extensions.swap\nimport java.util.Arrays\n\n/**\n * 905. Sort Array By Parity\n * @see <a href=\"https://leetcode.com/problems/sort-array-by-parity\">Source</a>\n */\nfun interface SortArrayByParity {\n    operator fun invoke(nums: IntArray): IntArray\n}\n\n/**\n * Approach 1: Stream\n */\nclass SortArrayByParityStream : SortArrayByParity {\n    override operator fun invoke(nums: IntArray): IntArray {\n        return Arrays.stream(nums)\n            .boxed()\n            .sorted { a, b -> (a % 2).compareTo(b % 2) }\n            .mapToInt { i -> i }\n            .toArray()\n    }\n}\n\n/**\n * Approach 1: Kotlin\n */\nclass SortArrayByParityKotlin : SortArrayByParity {\n    override operator fun invoke(nums: IntArray): IntArray = nums\n        .sortedWith { a, b -> (a % 2).compareTo(b % 2) }\n        .toIntArray()\n}\n\nclass SortArrayByParityTwoPass : SortArrayByParity {\n    override operator fun invoke(nums: IntArray): IntArray {\n        val ans = IntArray(nums.size)\n        var t = 0\n\n        for (i in nums.indices) {\n            if (nums[i] % 2 == 0) ans[t++] = nums[i]\n        }\n\n        for (i in nums.indices) {\n            if (nums[i] % 2 == 1) ans[t++] = nums[i]\n        }\n\n        return ans\n    }\n}\n\nclass SortArrayByParityInPlace : SortArrayByParity {\n    override operator fun invoke(nums: IntArray): IntArray = nums.sortArrayByParity()\n\n    private fun IntArray.sortArrayByParity(): IntArray {\n        var i = 0\n        var j = size - 1\n        while (i < j) {\n            if (this[i].isEven) {\n                i++\n            } else {\n                if (!this[j].isEven) {\n                    j--\n                }\n                if (this[j].isEven) {\n                    swap(i, j)\n                    i++\n                    j--\n                }\n            }\n        }\n        return this\n    }\n}\n", "issues": 4.0, "main_language": "Kotlin", "forks": 0, "stars": 19, "commit_sha": "776159de0b80f0bdc92a9d057c852b8b80147c11", "size": 2518, "name": "kotlab", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/days/Day18.kt", "owner": "hughjdavey", "repo_id": 317575435, "is_fork": false, "languages_distribution": null, "content": "package days\n\nclass Day18 : Day(18) {\n\n    // 21993583522852\n    override fun partOne(): Any {\n        return inputList.map { doCalculation(it) }.sum()\n    }\n\n    // 122438593522757\n    override fun partTwo(): Any {\n        return inputList.map { doCalculation(it, true) }.sum()\n    }\n\n    fun doCalculation(expression: String, prioritizeAddition: Boolean = false): Long {\n        val maybeParens = parensNoNesting.find(expression)\n        return if (maybeParens == null)  doSingleCalculation(expression, prioritizeAddition) else {\n            val withoutSurroundingParens = maybeParens.value.drop(1).dropLast(1)\n            val replacedWithResult = expression.replaceRange(maybeParens.range, doCalculation(withoutSurroundingParens, prioritizeAddition).toString())\n            doCalculation(replacedWithResult, prioritizeAddition)\n        }\n    }\n\n    private fun doSingleCalculation(expression: String, prioritizeAddition: Boolean = false): Long {\n        val nextExpr = if (prioritizeAddition) singleExprAdd.find(expression) ?: singleExpr.find(expression)!!\n                       else singleExpr.find(expression)!!\n\n        val result = doSingleSum(nextExpr.groupValues.drop(1))\n        return if (expression == nextExpr.value) result else {\n            val newExpr = expression.replaceRange(nextExpr.range, result.toString())\n            return doSingleCalculation(newExpr, prioritizeAddition)\n        }\n    }\n\n    private fun doSingleSum(parts: List<String>): Long {\n        val (x, y) = parts[0].replace(\"(\", \"\").toLong() to parts[2].replace(\")\", \"\").toLong()\n        return when (parts[1]) {\n            \"*\" -> x * y\n            \"+\" -> x + y\n            else -> throw IllegalArgumentException()\n        }\n    }\n\n    companion object {\n        private val singleExpr = Regex(\"(\\\\d+) ([+\\\\-/*]) (\\\\d+)\")\n        private val singleExprAdd = Regex(\"(\\\\d+) (\\\\+) (\\\\d+)\")\n        private val parensNoNesting = Regex(\"(\\\\([\\\\d*+ ]+\\\\))\")\n    }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "63c677854083fcce2d7cb30ed012d6acf38f3169", "size": 1947, "name": "aoc-2020", "license": "Creative Commons Zero v1.0 Universal"}
{"path": "src/Day14.kt", "owner": "i-tatsenko", "repo_id": 575595840, "is_fork": false, "languages_distribution": "{\"Kotlin\": 90644}", "content": "\nfun toPoints(input: String): List<Point> {\n    return input.split(\" -> \").map { it.split(\",\") }.map { split -> Point(split[1].toInt(), split[0].toInt()) }\n}\n\nfun range(start: Int, end: Int): IntProgression = if (start <= end) start..end else start downTo end\n\nfun getBlocked(input: List<String>): Set<Point>  {\n    val blocked = mutableSetOf<Point>()\n    input.forEach { line ->\n        val points = toPoints(line)\n        var from = points[0]\n        blocked.add(from)\n        for (i in 1 until points.size) {\n            val current = points[i]\n            val blockedPoints = if (from.x == current.x)\n                range(from.y, current.y).map { Point(from.x, it) }\n            else\n                range(from.x, current.x).map { Point(it, from.y) }\n            blockedPoints.forEach { p ->\n                blocked.add(p)\n            }\n            from = current\n        }\n    }\n    return blocked\n}\n\nfun printState(blocked: Set<Point>, sand: Set<Point>) {\n    for (x in 0..blocked.maxBy { it.x }.x + 1) {\n        for (y in blocked.minBy { it.y }.y - 1..blocked.maxBy { it.y }.y + 1) {\n            val element = Point(x, y)\n            print(\n                when {\n                    blocked.contains(element) -> '#'\n                    sand.contains(element) -> 'o'\n                    element.x == 0 && element.y == 500 -> '+'\n                    else -> '.'\n                }\n            )\n        }\n        println()\n    }\n    println()\n\n}\nfun main() {\n\n    fun part1(input: List<String>): Int {\n        val blocked = getBlocked(input)\n\n        var droppedSand = -1\n        val sand = mutableSetOf<Point>()\n\n        val lowestX = blocked.maxBy { it.x }.x\n\n        dropSand@ while (true) {\n//            printState()\n            var p = Point(0, 500)\n            droppedSand++\n            moveSand@ while (true) {\n                if (p.x == lowestX) {\n                    break@dropSand\n                }\n                val finalPosition = listOf(Point(p.x + 1, p.y), Point(p.x + 1, p.y - 1), Point(p.x + 1, p.y + 1))\n                    .find { !blocked.contains(it) && !sand.contains(it)} ?: break@moveSand\n                p = finalPosition\n            }\n            sand.add(p)\n        }\n\n        printState(blocked, sand)\n\n        return droppedSand\n    }\n\n    fun part2(input: List<String>): Int {\n        val blocked = getBlocked(input)\n\n        var droppedSand = 0\n        val sand = mutableSetOf<Point>()\n\n        val lowestX = blocked.maxBy { it.x }.x + 1\n\n        dropSand@ while (true) {\n//            printState()\n            var p = Point(0, 500)\n            droppedSand++\n            moveSand@ while (true) {\n                if (p.x == lowestX) break@moveSand\n                val finalPosition = listOf(Point(p.x + 1, p.y), Point(p.x + 1, p.y - 1), Point(p.x + 1, p.y + 1))\n                    .find { !blocked.contains(it) && !sand.contains(it)}\n                if (finalPosition == null) {\n                    if (p.x == 0 && p.y == 500) {\n                        break@dropSand\n                    } else {\n                        break@moveSand\n                    }\n                }\n                p = finalPosition\n\n            }\n            sand.add(p)\n        }\n\n        printState(blocked, sand)\n\n        return droppedSand\n    }\n\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day14_test\")\n    check(part1(testInput) == 24)\n//    check(part2(testInput) == 2713358)\n//your answer is too low\n    val input = readInput(\"Day14\")\n    check(part1(input) == 674)\n    println(part1(input))\n\n    check(part2(input) == 24957)\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "0a9b360a5fb8052565728e03a665656d1e68c687", "size": 3640, "name": "advent-of-code-2022", "license": "Apache License 2.0"}
{"path": "src/Day09.kt", "owner": "vi-quang", "repo_id": 573647667, "is_fork": false, "languages_distribution": "{\"Kotlin\": 49703}", "content": "import kotlin.math.abs\n\n/**\n * Main -------------------------------------------------------------------\n */\nfun main() {\n\n    fun Int.toIdentity(): Int {\n        if (this == 0) {\n            return 0\n        }\n\n        if (this < 1) {\n            return -1\n        } else {\n            return 1\n        }\n    }\n\n    fun getHeadPositions(input: List<String>): List<Pair<Int, Int>> {\n        val positionList = mutableListOf<Pair<Int, Int>>()\n        var headR = 0\n        var headC = 0\n\n        input.forEach {\n            val token = it.split(\" \")\n            var step = token[1].toInt()\n\n            System.err.println(\">>$it\")\n            while (step > 0) {\n                //System.err.println(\"STEPS: $step\")\n                step-- //we take a step\n\n                when (token[0]) {\n                    \"R\" -> {\n                        headC++\n                    }\n\n                    \"L\" -> {\n                        headC--\n                    }\n\n                    \"U\" -> {\n                        headR++\n                    }\n\n                    \"D\" -> {\n                        headR--\n                    }\n                }\n                positionList.add(Pair(headR, headC))\n            }\n        }\n\n        return positionList\n    }\n\n    fun getTailPositions(headPositions: List<Pair<Int, Int>>): List<Pair<Int, Int>> {\n        val tailPositions = mutableListOf<Pair<Int, Int>>()\n\n        var tailR = 0\n        var tailC = 0\n\n        headPositions.forEach {\n\n            val headR = it.first\n            val headC = it.second\n\n            val diffC = headC - tailC\n            val diffR = headR - tailR\n            val deltaC = abs(diffC)\n            val deltaR = abs(diffR)\n\n            if (deltaC == 2 || deltaR == 2) {\n                tailC += diffC.toIdentity()\n                tailR += diffR.toIdentity()\n            }\n\n            //System.err.println(\"H:$headR, $headC --- T:$tailR, $tailC\")\n\n            tailPositions.add(Pair(tailR, tailC))\n\n        }\n\n        return tailPositions\n    }\n\n    fun part1(input: List<String>): Int {\n        val headPositions = getHeadPositions(input)\n        val tailPositions = getTailPositions(headPositions)\n\n        return tailPositions.toSet().size\n    }\n\n    fun part2(input: List<String>): Int {\n        val headPositions = getHeadPositions(input)\n        var tailPositions = getTailPositions(headPositions) //tail 1\n\n        for (i in 2 .. 9) { //tails 2 .. 9\n            System.err.println(\"$i\")\n            tailPositions = getTailPositions(tailPositions)\n        }\n\n        return tailPositions.toSet().size\n    }\n\n\n    val input = readInput(9)\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 2, "commit_sha": "ae153c99b58ba3749f16b3fe53f06a4b557105d3", "size": 2670, "name": "aoc-2022", "license": "Apache License 2.0"}
{"path": "src/test/kotlin/Day21.kt", "owner": "FredrikFolkesson", "repo_id": 320692155, "is_fork": false, "languages_distribution": null, "content": "import org.junit.jupiter.api.Test\nimport kotlin.test.assertEquals\n\n\nclass Day21 {\n\n    @Test\n    fun `test demo input`() {\n        val input =\n            \"mxmxvkd kfcds sqjhc nhms (contains dairy, fish)\\n\" +\n                    \"trh fvjkl sbzzf mxmxvkd (contains dairy)\\n\" +\n                    \"sqjhc fvjkl (contains soy)\\n\" +\n                    \"sqjhc mxmxvkd sbzzf (contains fish)\"\n\n        println(countTimesNonAllergenicItemAppears(input))\n\n    }\n\n    @Test\n    fun `test real input`() {\n        val input = readFileAsString(\"/Users/fredrikfolkesson/git/advent-of-code/inputs/input-day21.txt\")\n\n        println(countTimesNonAllergenicItemAppears(input))\n\n\n    }\n\n    private fun countTimesNonAllergenicItemAppears(input: String): Int {\n\n        val allIngredients = input.lines().map { parseFood(it) }.flatMap { it.values.first() }.toSet()\n        val allergenMap = findAllergenMap(input)\n        val nonAllergenics = allIngredients.filter { it !in allergenMap.values }.toSet()\n\n\n        val allIngredientsList = input\n            .lines()\n            .map { parseFood(it) }\n            .map { it.values.first() }\n\n        val allIngredientsCount = mutableMapOf<String, Int>()\n        allIngredientsList.forEach {\n            it.forEach { ingredient ->\n                allIngredientsCount[ingredient] = allIngredientsCount.getOrDefault(ingredient, 0) + 1\n            }\n        }\n        return allIngredientsCount.filter { it.key in nonAllergenics }.values.sum()\n    }\n\n\n    @Test\n    fun `test demo input part 2`() {\n        val input =\n            \"mxmxvkd kfcds sqjhc nhms (contains dairy, fish)\\n\" +\n                    \"trh fvjkl sbzzf mxmxvkd (contains dairy)\\n\" +\n                    \"sqjhc fvjkl (contains soy)\\n\" +\n                    \"sqjhc mxmxvkd sbzzf (contains fish)\"\n\n\n        val allergenMap = findAllergenMap(input)\n        println(allergenMap.toSortedMap().values.joinToString(\",\"))\n    }\n\n    @Test\n    fun `test real input part 2`() {\n        val input = readFileAsString(\"/Users/fredrikfolkesson/git/advent-of-code/inputs/input-day21.txt\")\n\n\n        val allergenMap = findAllergenMap(input)\n        println(allergenMap.toSortedMap().values.joinToString(\",\"))\n    }\n\n\n    private fun findAllergenMap(foods: String): MutableMap<String, String> {\n\n        val foundPossibleAllergens = mutableMapOf<String, MutableSet<String>>()\n        //First remove intersections\n        foods\n            .lines()\n            .map { parseFood(it) }\n            .forEach {\n                it.keys.forEach { key ->\n                    if (key in foundPossibleAllergens) {\n                        val currentPossibleAllergens = foundPossibleAllergens[key]!!\n                        foundPossibleAllergens[key] = currentPossibleAllergens.intersect(it.values.first()).toMutableSet()\n                    } else {\n                        //They are all the same\n                        foundPossibleAllergens[key] = it.values.first().toMutableSet()\n                    }\n                }\n            }\n\n        val ingredientToAllergen = mutableMapOf<String,String>()\n        while (foundPossibleAllergens.values.any { it.isNotEmpty() }) {\n\n            val entryThatIsAnAllergen = foundPossibleAllergens.entries.first { it.value.size == 1 }\n            val onlyOneIngredientForAllergen = entryThatIsAnAllergen.value.toList().first()\n\n            ingredientToAllergen.put(entryThatIsAnAllergen.key,onlyOneIngredientForAllergen)\n\n            foundPossibleAllergens.values.map {\n                it.remove(onlyOneIngredientForAllergen)\n            }\n\n        }\n\n        return ingredientToAllergen\n\n    }\n\n    @Test\n    fun `test parse foodItem`() {\n\n        assertEquals(\n            mapOf(\n                \"fish\" to setOf(\"mxmxvkd\", \"kfcds\", \"sqjhc\", \"nhms\"),\n                \"dairy\" to setOf(\"mxmxvkd\", \"kfcds\", \"sqjhc\", \"nhms\")\n            ), parseFood(\"mxmxvkd kfcds sqjhc nhms (contains dairy, fish)\")\n        )\n        assertEquals(\n            mapOf(\"dairy\" to setOf(\"trh\", \"fvjkl\", \"sbzzf\", \"mxmxvkd\")),\n            parseFood(\"trh fvjkl sbzzf mxmxvkd (contains dairy)\")\n        )\n\n    }\n\n    private fun parseFood(input: String): Map<String, Set<String>> {\n        val ingredients = input.split(\" (contains \")[0].split(\" \").toSet()\n        return input.split(\" (contains \")[1].replace(\")\", \"\").split(\", \").map { it to ingredients }.toMap()\n    }\n\n\n}\n\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "79a67f88e1fcf950e77459a4f3343353cfc1d48a", "size": 4362, "name": "advent-of-code", "license": "MIT License"}
{"path": "src/main/kotlin/Problem10.kt", "owner": "jimmymorales", "repo_id": 496703114, "is_fork": false, "languages_distribution": "{\"Kotlin\": 67323}", "content": "import kotlin.math.floor\nimport kotlin.math.sqrt\nimport kotlin.system.measureNanoTime\n\n/**\n * Summation of primes\n *\n * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\n * Find the sum of all the primes below two million.\n *\n * https://projecteuler.net/problem=10\n */\n\nfun main() {\n    println(sumOfPrimes(10))\n    println(sumOfPrimesSieve(10))\n    val time1 = measureNanoTime { println(sumOfPrimes(2_000_000)) }\n    val time2 = measureNanoTime { println(sumOfPrimesSieve(2_000_000)) }\n\n    println(time1)\n    println(time2)\n}\n\nprivate fun sumOfPrimes(n: Long): Long {\n    if (n < 2) return 0\n    return (3..n step 2).asSequence()\n        .filter(::isPrime)\n        .sum() + 2\n}\n\nprivate fun sumOfPrimesSieve(n: Long): Long {\n    return primes(n).sumOf(Int::toLong)\n}\n\n// The sieve of Eratosthenes optimized\nfun primes(n: Long): List<Int> {\n    val sieveBound = ((n - 1) / 2).toInt()\n    val sieve = Array(sieveBound) { true }\n    val crosslimit = (floor(sqrt(n.toDouble())).toInt() - 1) / 2\n\n    for (i in 1..crosslimit) {\n        if (!sieve[i-1]) continue\n        for (j in (2 * i * (i + 1)) .. sieveBound step 2 * i + 1) {\n            sieve[j-1] = false\n        }\n    }\n\n    return listOf(2) + sieve.mapIndexedNotNull { i, isPrime -> if (isPrime) 2 * (i + 1) + 1 else null }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "e881cadf85377374e544af0a75cb073c6b496998", "size": 1285, "name": "project-euler", "license": "MIT License"}
{"path": "src/2022/Day15.kt", "owner": "ttypic", "repo_id": 572859357, "is_fork": false, "languages_distribution": "{\"Kotlin\": 94821}", "content": "package `2022`\n\nimport readInput\nimport kotlin.math.abs\n\nfun main() {\n\n    fun findDistressedBeacon(sensorToDistance: List<Day15Input>, maxSize: Int): YPoint {\n        (0..maxSize).forEach { y ->\n            val ranges = sensorToDistance.toReverseRanges(y, maxSize)\n            if (ranges.isNotEmpty()) {\n                return ranges.first().start\n            }\n        }\n        error(\"Can't find distressed beacon\")\n    }\n\n    fun readInput(input: List<String>): List<Day15Input> {\n        val sensorToDistance = input.map { s ->\n            val (sensor, beacon) = \"(x=|y=)(-?\\\\d+)\"\n                .toRegex().findAll(s)\n                .map { it.groups[2]!!.value.toInt() }\n                .chunked(2)\n                .map { (x, y) -> YPoint(x, y) }\n                .toList()\n            val distance = sensor.dist(beacon)\n            Day15Input(sensor, distance, beacon)\n        }\n        return sensorToDistance\n    }\n\n    fun part1(input: List<String>, row: Int): Int {\n        val sensorToBeacon = readInput(input)\n        val sensors = sensorToBeacon.map { it.sensor }.toSet()\n        val beacons = sensorToBeacon.map { it.beacon }.toSet()\n        val ranges = sensorToBeacon.toRanges(row)\n        val minX = ranges.map { it.start.x }.min()\n        val maxX = ranges.map { it.endInclusive.x }.max()\n\n        return (minX..maxX).asSequence().filter { x ->\n            val point = YPoint(x, row)\n            !sensors.contains(point) && !beacons.contains(point)\n        }.count()\n    }\n\n    fun part2(input: List<String>, maxSize: Int): Long {\n        val sensorToDistance = readInput(input)\n        val (x, y) = findDistressedBeacon(sensorToDistance, maxSize)\n        return x * 4000000L + y\n    }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day15_test\")\n    println(part1(testInput, 10))\n    println(part2(testInput, 20))\n    check(part1(testInput, 10) == 26)\n    check(part2(testInput, 20) == 56000011L)\n\n    val input = readInput(\"Day15\")\n    println(part1(input, 2000000))\n    println(part2(input, 4000000))\n}\n\nprivate fun YPoint.dist(other: YPoint): Int {\n    return abs(x - other.x) + abs(y - other.y)\n}\n\nprivate data class Day15Input(val sensor: YPoint, val distance: Int, val beacon: YPoint)\n\nprivate data class YPoint(val x: Int, val y: Int): Comparable<YPoint> {\n    override fun compareTo(other: YPoint): Int {\n        return x - other.x\n    }\n}\n\nprivate fun YPoint.prev(): YPoint {\n    return YPoint(x - 1, y)\n}\n\nprivate fun YPoint.next(): YPoint {\n    return YPoint(x + 1, y)\n}\n\nprivate fun List<Day15Input>.toRanges(row: Int): List<ClosedRange<YPoint>> {\n    return mapNotNull { (sensor, distance) ->\n        val delta = distance - abs(sensor.y - row)\n        if (delta >= 0) {\n            YPoint(sensor.x - delta, row)..YPoint(sensor.x + delta, row )\n        } else {\n            null\n        }\n    }\n}\n\nprivate fun List<Day15Input>.toReverseRanges(row: Int, maxSize: Int): List<ClosedRange<YPoint>> {\n    val ranges = toRanges(row)\n    return ranges.fold(listOf(YPoint(0, row)..YPoint(maxSize, row))) { acc, range ->\n        acc.subtract(range)\n    }\n}\n\nprivate fun List<ClosedRange<YPoint>>.subtract(range: ClosedRange<YPoint>): List<ClosedRange<YPoint>> {\n    return filter {\n        !(range.contains(it.start) && range.contains(it.endInclusive))\n    }.flatMap {\n        if (range.contains(it.start)) {\n            listOf(range.endInclusive.next()..it.endInclusive)\n        } else if (range.contains(it.endInclusive)) {\n            listOf(it.start..range.start.prev())\n        } else if (it.contains(range.start)) {\n            listOf(\n                it.start..range.start.prev(),\n                range.endInclusive.next()..it.endInclusive\n            )\n        } else {\n            listOf(it)\n        }\n    }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "b3e718d122e04a7322ed160b4c02029c33fbad78", "size": 3799, "name": "aoc-2022-in-kotlin", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/com/hj/leetcode/kotlin/problem2251/Solution.kt", "owner": "hj-core", "repo_id": 534054064, "is_fork": false, "languages_distribution": "{\"Kotlin\": 619841}", "content": "package com.hj.leetcode.kotlin.problem2251\n\n/**\n * LeetCode page: [2251. Number of Flowers in Full Bloom](https://leetcode.com/problems/number-of-flowers-in-full-bloom/);\n */\nclass Solution {\n    /* Complexity:\n     * Time O((N+M)LogN) and Space O(N) where N is the size of flowers and\n     * M is the size of people;\n     */\n    fun fullBloomFlowers(flowers: Array<IntArray>, people: IntArray): IntArray {\n        val sortedStarts =\n            IntArray(flowers.size) { flowers[it][0] }.apply { sort() }\n\n        val sortedEnds =\n            IntArray(flowers.size) { flowers[it][1] }.apply { sort() }\n\n        return IntArray(people.size) { index ->\n            numFlowersInFullBloom(people[index], sortedStarts, sortedEnds)\n        }\n    }\n\n    private fun numFlowersInFullBloom(\n        time: Int,\n        sortedStarts: IntArray,\n        sortedEnds: IntArray\n    ): Int {\n        val numStarted = leftInsertionIndex(time + 1, sortedStarts)\n        val numEnded = leftInsertionIndex(time, sortedEnds)\n        return numStarted - numEnded\n    }\n\n    /**\n     * Return the leftmost index to insert the [target] while keeping\n     * the [sorted] sorted.\n     */\n    private fun leftInsertionIndex(target: Int, sorted: IntArray): Int {\n        if (sorted.isEmpty() || target <= sorted[0]) {\n            return 0\n        }\n        if (sorted.last() < target) {\n            return sorted.size\n        }\n\n        var left = 0\n        var right = sorted.lastIndex\n\n        while (left < right) {\n            val mid = (left + right) ushr 1\n\n            if (sorted[mid] < target) {\n                left = mid + 1\n            } else {\n                right = mid\n            }\n        }\n        return left\n    }\n}", "issues": 1.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "14c033f2bf43d1c4148633a222c133d76986029c", "size": 1706, "name": "hj-leetcode-kotlin", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/nl/kelpin/fleur/advent2018/Day04.kt", "owner": "fdlk", "repo_id": 159925533, "is_fork": false, "languages_distribution": null, "content": "package nl.kelpin.fleur.advent2018\n\ntypealias GuardID = Int\ntypealias Minute = Int\n\nclass Day04(input: List<String>) {\n    data class Nap(val guard: GuardID, val minutes: IntRange)\n\n    data class State(val guard: GuardID? = null, val napStarted: Int? = null, val naps: List<Nap> = listOf()) {\n        fun beginShift(newGuard: GuardID) = copy(guard = newGuard, napStarted = null)\n        fun fallAsleep(minutes: Int) = copy(napStarted = minutes)\n        fun wakeUp(minutes: Int) = copy(napStarted = null, naps = naps + Nap(guard!!, napStarted!! until minutes))\n    }\n\n    companion object {\n        private val beginShiftRE = Regex(\"\"\".*Guard #(\\d+) begins shift\"\"\")\n        private val fallAsleepRE = Regex(\"\"\".*00:(\\d{2})] falls asleep\"\"\")\n        private val wakesUpRE = Regex(\"\"\".*00:(\\d{2})] wakes up\"\"\")\n        private fun MatchResult.intMatch(): Int = destructured.let{ (firstResult) -> firstResult.toInt() }\n\n        fun processLine(status: State, line: String): State = when {\n            line.matches(beginShiftRE) -> beginShiftRE.find(line)!!.intMatch().run(status::beginShift)\n            line.matches(fallAsleepRE) -> fallAsleepRE.find(line)!!.intMatch().run(status::fallAsleep)\n            line.matches(wakesUpRE) -> wakesUpRE.find(line)!!.intMatch().run(status::wakeUp)\n            else -> throw IllegalArgumentException(\"Failed to parse: $line\")\n        }\n    }\n\n    private val guardNaps: Map<GuardID, List<Minute>> = input\n            .sorted()\n            .fold(State(), ::processLine).naps\n            .groupBy { it.guard }\n            .mapValues { it.value.flatMap { it.minutes } }\n\n    fun part1(): Int = guardNaps\n            .maxBy { it.value.size }!!\n            .let { (guardID: GuardID, minutes: List<Minute>) -> guardID * minutes.mostFrequent().element }\n\n    fun part2(): Int = guardNaps\n            .mapValues { it.value.mostFrequent() }\n            .maxBy { it.value.occurrence }!!\n            .let { (guardID: GuardID, mostFrequent: Frequency<Minute>) -> guardID * mostFrequent.element }\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 3, "commit_sha": "a089dbae93ee520bf7a8861c9f90731eabd6eba3", "size": 2022, "name": "advent-2018", "license": "MIT License"}
{"path": "src/main/kotlin/g2501_2600/s2503_maximum_number_of_points_from_grid_queries/Solution.kt", "owner": "javadev", "repo_id": 190711550, "is_fork": false, "languages_distribution": "{\"Kotlin\": 4420233, \"TypeScript\": 50437, \"Python\": 3646, \"Shell\": 994}", "content": "package g2501_2600.s2503_maximum_number_of_points_from_grid_queries\n\n// #Hard #Array #Sorting #Breadth_First_Search #Heap_Priority_Queue #Union_Find\n// #2023_07_04_Time_581_ms_(100.00%)_Space_62.6_MB_(100.00%)\n\nimport java.util.ArrayDeque\nimport java.util.Arrays\nimport java.util.PriorityQueue\nimport java.util.Queue\n\nclass Solution {\n    private val dirs = arrayOf(intArrayOf(-1, 0), intArrayOf(1, 0), intArrayOf(0, -1), intArrayOf(0, 1))\n\n    fun maxPoints(grid: Array<IntArray>, queries: IntArray): IntArray {\n        val r = grid.size\n        val c = grid[0].size\n        val res = IntArray(queries.size)\n        val index = arrayOfNulls<Int>(queries.size)\n        for (i in queries.indices) {\n            index[i] = i\n        }\n        Arrays.sort(index, { o: Int?, m: Int? -> queries[o!!].compareTo(queries[m!!]) })\n        val q1: Queue<IntArray> = ArrayDeque()\n        val q2 = PriorityQueue({ a: IntArray, b: IntArray -> a[2].compareTo(b[2]) })\n        q2.offer(intArrayOf(0, 0, grid[0][0]))\n        val visited = Array(r) { BooleanArray(c) }\n        var count = 0\n        visited[0][0] = true\n        for (i in queries.indices) {\n            val currLimit = queries[index[i]!!]\n            while (q2.isNotEmpty() && q2.peek()[2] < currLimit) {\n                q1.offer(q2.poll())\n            }\n            while (q1.isNotEmpty()) {\n                val curr = q1.poll()\n                count++\n                for (dir in dirs) {\n                    val x = dir[0] + curr[0]\n                    val y = dir[1] + curr[1]\n                    if (x < 0 || y < 0 || x >= r || y >= c || visited[x][y]) {\n                        continue\n                    }\n                    if (!visited[x][y] && grid[x][y] < currLimit) {\n                        q1.offer(intArrayOf(x, y, grid[x][y]))\n                    } else {\n                        q2.offer(intArrayOf(x, y, grid[x][y]))\n                    }\n                    visited[x][y] = true\n                }\n            }\n            res[index[i]!!] = count\n        }\n        return res\n    }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 14, "stars": 24, "commit_sha": "fc95a0f4e1d629b71574909754ca216e7e1110d2", "size": 2054, "name": "LeetCode-in-Kotlin", "license": "MIT License"}
{"path": "advent-of-code-2023/src/main/kotlin/eu/janvdb/aoc2023/day19/day19.kt", "owner": "janvdbergh", "repo_id": 318992922, "is_fork": false, "languages_distribution": "{\"Java\": 1000798, \"Kotlin\": 284065, \"Shell\": 452, \"C\": 335}", "content": "package eu.janvdb.aoc2023.day19\n\nimport eu.janvdb.aocutil.kotlin.readGroupedLines\n\n//const val FILENAME = \"input19-test.txt\"\nconst val FILENAME = \"input19.txt\"\n\nval VARIABLES = listOf(\"x\", \"m\", \"a\", \"s\")\n\nconst val MIN_VALUE = 1\nconst val MAX_VALUE = 4000\n\nfun main() {\n    val lines = readGroupedLines(2023, FILENAME)\n    val rules = Rules.parse(lines[0])\n    val parts = lines[1].map(Part::parse)\n\n    part1(parts, rules)\n\n    part2(rules)\n}\n\nprivate fun part1(parts: List<Part>, rules: Rules) {\n    val acceptedParts = parts.filter(rules::evaluate)\n    println(acceptedParts.sumOf { it.rating })\n}\n\nprivate fun part2(rules: Rules) {\n    val ranges = VARIABLES.associateWith { MIN_VALUE..MAX_VALUE }\n    val result = rules.countAccepted(\"in\", ranges)\n    println(result)\n}\n\ndata class Rules(val rules: Map<String, Rule>) {\n    fun evaluate(part: Part): Boolean {\n        var current = \"in\"\n        while (!current.isAccepted() && !current.isRejected()) {\n            val rule = rules[current]!!\n            current = rule.evaluate(part)\n        }\n\n        return current.isAccepted()\n    }\n\n    fun countAccepted(outcome: String, ranges: Map<String, IntRange>, index: Int = 0): Long {\n        val spaces = (0..<index).joinToString(\"\", \"\", \"+-\") { \"| \" }\n        println(\"$spaces$ranges -> $outcome\")\n\n        if (outcome.isAccepted())\n            return 1L * ranges.values.fold(1L) { acc, range -> acc * (range.last - range.first + 1) }\n        if (outcome.isRejected())\n            return 0L\n        if (ranges.values.any { it.last < it.first })\n            return 0L\n\n        val rule = rules[outcome]!!\n\n        var currentRanges = ranges\n        var sum = 0L\n        rule.conditions.forEach { condition ->\n            val currentRange = currentRanges[condition.variable]!!\n            val newRange1 =\n                if (condition.operation == Operation.LT) currentRange.first..<condition.value else condition.value + 1..currentRange.last\n            val newRange2 =\n                if (condition.operation == Operation.LT) condition.value..currentRange.last else currentRange.first..condition.value\n\n            val newRanges = currentRanges + Pair(condition.variable, newRange1)\n            sum += countAccepted(condition.outcome, newRanges, index + 1)\n\n            currentRanges = currentRanges + Pair(condition.variable, newRange2)\n        }\n\n        sum += countAccepted(rule.defaultOutcome, currentRanges, index + 1)\n\n        return sum\n    }\n\n    companion object {\n        fun parse(lines: List<String>): Rules {\n            val rules = lines.map(Rule::parse).associateBy { it.name }\n            return Rules(rules)\n        }\n    }\n}\n\n\ndata class Rule(val name: String, val conditions: List<Condition>, val defaultOutcome: String) {\n    fun evaluate(part: Part): String {\n        return conditions.find { it.matches(part) }?.outcome ?: defaultOutcome\n    }\n\n    companion object {\n        fun parse(line: String): Rule {\n            val parts = line.split(\"{\")\n            val name = parts[0]\n            val parts2 = parts[1].substring(0, parts[1].length - 1).split(\",\")\n            val conditions = parts2.subList(0, parts2.size - 1).map(Condition::parse)\n            val defaultOutcome = parts2.last()\n            return Rule(name, conditions, defaultOutcome)\n        }\n    }\n}\n\ndata class Condition(val variable: String, val operation: Operation, val value: Int, val outcome: String) {\n    fun matches(part: Part): Boolean {\n        val partValue = part.values[variable]!!\n        return operation.evaluate(partValue, value)\n    }\n\n    companion object {\n        private val REGEX = Regex(\"(\\\\w+)([<>])(\\\\d+):(\\\\w+)\")\n        fun parse(value: String): Condition {\n            val matchResult = REGEX.matchEntire(value)!!\n            return Condition(\n                matchResult.groupValues[1],\n                Operation.parse(matchResult.groupValues[2]),\n                matchResult.groupValues[3].toInt(),\n                matchResult.groupValues[4]\n            )\n        }\n    }\n}\n\nenum class Operation(val text: String) {\n    GT(\">\"), LT(\"<\");\n\n    fun evaluate(x: Int, y: Int) = when (this) {\n        LT -> x < y\n        GT -> x > y\n    }\n\n    companion object {\n        fun parse(value: String) = entries.find { it.text == value }!!\n    }\n}\n\nfun String.isAccepted() = equals(\"A\")\nfun String.isRejected() = equals(\"R\")\n\ndata class Part(val values: Map<String, Int>) {\n    val rating = VARIABLES.sumOf { values.getOrDefault(it, 0) }\n\n    companion object {\n        private val REGEX = Regex(\"(\\\\w+)=(\\\\d+)\")\n        fun parse(value: String): Part {\n            val values = REGEX.findAll(value).associate { Pair(it.groupValues[1], it.groupValues[2].toInt()) }\n            return Part(values)\n        }\n    }\n}", "issues": 0.0, "main_language": "Java", "forks": 0, "stars": 0, "commit_sha": "78ce266dbc41d1821342edca484768167f261752", "size": 4730, "name": "advent-of-code", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/com/jacobhyphenated/advent2022/day13/Day13.kt", "owner": "jacobhyphenated", "repo_id": 573603184, "is_fork": false, "languages_distribution": "{\"Kotlin\": 144303}", "content": "package com.jacobhyphenated.advent2022.day13\n\nimport com.jacobhyphenated.advent2022.Day\n\n/**\n * Day 13: Distress Signal\n *\n * Packets are coming in out of order.\n * Packets come in pairs (one on each line of the input).\n *\n * A packet consists of a number or list of packets, ex:\n *      [[1],[2,3,4]] turns into Packet[Packet[Packet[1]], Packet[Packet[2],Packet[3],Packet[4]]]\n *      [[1],4] turns into Packet[Packet[Packet[1]], Packet[4]]\n *\n */\nclass Day13: Day<List<Pair<Packet, Packet>>> {\n    override fun getInput(): List<Pair<Packet, Packet>> {\n        return parseInput(readInputFile(\"day13\"))\n    }\n\n    /**\n     * Observe each pair of packets. Find the index (1 based) in the list of\n     * all the packets that are in the correct order.\n     * Return the sum of those indexes\n     */\n    override fun part1(input: List<Pair<Packet, Packet>>): Int {\n        return input.mapIndexed { index, (lhs, rhs) ->\n            if (lhs <= rhs) { index + 1 } else { 0 }\n        }.sum()\n    }\n\n    /**\n     * Take all packets and put them in a single list. Add two marker packets: [[2]] and [[6]]\n     * Put the packets in the correct order and find the (1 based) index of the marker packets.\n     * Return the product of both marker indexes\n     */\n    override fun part2(input: List<Pair<Packet, Packet>>): Any {\n        val (marker1, _) = parsePacket(\"[[2]]\")\n        val (marker2, _) = parsePacket(\"[[6]]\")\n        val allPackets = input.flatMap { listOf(it.first, it.second) } + listOf(marker1, marker2)\n        val sortedPackets = allPackets.sorted()\n        return (sortedPackets.indexOf(marker1) + 1) * (sortedPackets.indexOf(marker2) + 1)\n    }\n\n    fun parseInput(input: String): List<Pair<Packet, Packet>> {\n        return input.split(\"\\n\\n\").map { pairs ->\n            val (lhs, rhs) = pairs.lines().map { parsePacket(it).first }\n            Pair(lhs, rhs)\n        }\n    }\n\n    /**\n     * Recursive function to parse the packet out of the string.\n     * Nested [] get their own recursive call.\n     *\n     * @param packetString The entire packet string\n     * @param index the index to start the parsing at (defaults to 1 - all packets start with '[')\n     * @return A pair tuple consisting of the parsed packet\n     * and the index of the lasted visited location in the overall packetString\n     */\n    private fun parsePacket(packetString: String, index: Int = 1): Pair<Packet, Int> {\n        var buffer = \"\"\n        var i = index\n        val packets = mutableListOf<Packet>()\n        // when we hit the close bracket, this parse function is done\n        while (packetString[i] != ']') {\n            if (packetString[i] == '[') {\n                // we are opening a new sub packet - recursively call this method\n                val (p, newIndex) = parsePacket(packetString, i+1)\n                packets.add(p)\n                i = newIndex\n                continue\n            }\n            if (packetString[i] == ',') {\n                // On a comma, move to the next item in the list (clear the buffer if necessary)\n                if (buffer.isNotEmpty()) {\n                    packets.add(Packet(buffer.toInt(), null))\n                    buffer = \"\"\n                }\n                i++\n                continue\n            }\n            // Numbers are stored in the buffer (as multi digit numbers are valid)\n            buffer += packetString[i]\n            i++\n        }\n        if (buffer.isNotEmpty()) {\n            packets.add(Packet(buffer.toInt(), null))\n        }\n        return Pair(Packet(null, packets), i + 1)\n    }\n}\n\nclass Packet (\n    private val value: Int?,\n    private val packets: List<Packet>?\n) : Comparable<Packet> {\n\n    /**\n     * To check order, look from left to right in each packet\n     *      If the value is a number on both, the left should be less than the right\n     *      If one of the two packets has a number, convert that number to a single value list\n     *      If both are lists, go from left to right comparing each value in the list (left-hand side should be smaller)\n     *      - if the left-hand side runs out of values first, they are in the correct order\n     *      - if the right-hand side runs out of values first, they are out of order\n     */\n    override fun compareTo(other: Packet): Int {\n        if (this.value != null && other.value != null) {\n            return this.value.compareTo(other.value)\n        }\n        val listA = this.packets ?: listOf(Packet(this.value!!, null))\n        val listB = other.packets ?: listOf(Packet(other.value!!, null))\n        for (i in listA.indices) {\n            if (i >= listB.size) { return 1 }\n            val cmp = listA[i].compareTo(listB[i])\n            if (cmp != 0) { return cmp }\n        }\n        if (listA.size < listB.size) {\n            return - 1\n        }\n        return 0\n    }\n\n    /**\n     * We could probably cheat and just do reference equivalence for this problem\n     * But here is a real equals method implementation\n     */\n    override fun equals(other: Any?): Boolean {\n        if (this === other) { return true }\n        if (other !is Packet) { return false }\n        if (other.value != null && this.value != null && this.value == other.value) {\n            return true\n        }\n        if (other.packets != null && this.packets != null){\n            if (other.packets.size != this.packets.size) { return false }\n            return other.packets == this.packets\n        }\n        return false\n    }\n\n    // The IDE generated this one (It's always recommended to have hashCode if you have equals)\n    override fun hashCode(): Int {\n        val result = value ?: 0\n        return 31 * result + (packets?.hashCode() ?: 0)\n    }\n\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "9f4527ee2655fedf159d91c3d7ff1fac7e9830f7", "size": 5666, "name": "advent2022", "license": "The Unlicense"}
{"path": "games-core/src/main/kotlin/net/zomis/games/dsl/DslSplendor.kt", "owner": "Tejpbit", "repo_id": 260966032, "is_fork": true, "languages_distribution": "{\"Kotlin\": 395303, \"Vue\": 83692, \"JavaScript\": 27193, \"Java\": 17130, \"CSS\": 3871, \"HTML\": 1358, \"Dockerfile\": 228}", "content": "package net.zomis.games.dsl\n\ndata class Player(var chips: Money = Money(), val owned: MutableSet<Card> = mutableSetOf(),\n                  val reserved: MutableSet<Card> = mutableSetOf()) {\n    fun total(): Money = this.discounts() + this.chips\n\n    fun canBuy(card: Card): Boolean = this.total().has(card.costs)\n\n    fun buy(card: Card) {\n        val actualCost = card.costs.minus(this.discounts())\n        this.chips -= actualCost\n        this.owned.add(card)\n    }\n\n    fun discounts(): Money {\n        return this.owned.map { it.discounts }.fold(Money()) { acc, money -> acc + money }\n    }\n\n}\n\ndata class Card(val level: Int, val discounts: Money, val costs: Money, val points: Int) {\n    // Possible to support multiple discounts on the same card. Because why not!\n    constructor(level: Int, discount: MoneyType, costs: Money, points: Int):\n        this(level, Money(discount to 1), costs, points)\n}\n\nfun <K, V> Map<K, V>.mergeWith(other: Map<K, V>, merger: (V?, V?) -> V): Map<K, V> {\n    return (this.keys + other.keys).associateWith {\n        merger(this[it], other[it])\n    }\n}\n\nenum class MoneyType {\n    BLACK, WHITE, RED, BLUE, GREEN;\n\n    fun toMoney(count: Int): Money {\n        return Money(mutableMapOf(this to count))\n    }\n}\ndata class Money(val moneys: MutableMap<MoneyType, Int> = mutableMapOf()) {\n    // TODO: Add wildcards as a separate field\n    constructor(vararg money: Pair<MoneyType, Int>) : this(mutableMapOf<MoneyType, Int>(*money))\n\n    operator fun plus(other: Money): Money {\n        val result = moneys.mergeWith(other.moneys) {a, b -> (a ?: 0) + (b ?: 0)}\n        return Money(result.toMutableMap())\n    }\n\n    fun has(costs: Money): Boolean = costs.moneys.entries.all { it.value <= this.moneys[it.key] ?: 0 }\n\n    operator fun minus(other: Money): Money {\n        val result = moneys.mergeWith(other.moneys) {a, b -> (a ?: 0) - (b ?: 0)}.mapValues {\n            if (it.value < 0) 0 else it.value\n        }\n        return Money(result.toMutableMap())\n    }\n}\n\ndata class MoneyChoice(val moneys: List<MoneyType>) {\n    fun toMoney(): Money {\n        return Money(moneys.groupBy { it }.mapValues { it.value.size }.toMutableMap())\n    }\n}\n\nfun startingStockForPlayerCount(playerCount: Int): Int {\n    return 10\n}\n\nclass SplendorGame(playerCount: Int = 2) {\n\n    // TODO: Add nobles\n    val cardLevels = 1..3\n    private fun randomType(): MoneyType {\n        return MoneyType.values().toList().shuffled().first()\n    }\n    private fun randomCard(level: Int): Card {\n        return Card(level, randomType(), Money(randomType() to level * 2), level)\n    }\n    val players: List<Player> = (1..playerCount).map { Player() }\n    val board: MutableList<Card> = mutableListOf()\n    val deck: MutableList<Card> = cardLevels.flatMap { level ->\n        (0 until 30).map { randomCard(level) }\n    }.toMutableList()\n    var stock: Money = MoneyType.values().fold(Money()) {money, type -> money + type.toMoney(startingStockForPlayerCount(playerCount))}\n    var currentPlayerIndex: Int = 0\n\n    init {\n        cardLevels.forEach {level ->\n            (1..4).forEach { _ ->\n                val card = deck.find { it.level == level }\n                if (card != null) {\n                    deck.remove(card)\n                    board.add(card)\n                }\n            }\n        }\n    }\n\n    val currentPlayer: Player\n        get() = this.players[this.currentPlayerIndex]\n\n    fun replaceCard(card: Card) {\n        val index = board.indexOf(card)\n        if (index < 0) {\n            throw IllegalArgumentException(\"Card does not exist on board: $card\")\n        }\n        val nextCard = deck.firstOrNull { it.level == card.level }\n        if (nextCard != null) {\n            board[index] = nextCard\n        } else {\n            board.removeAt(index)\n        }\n    }\n\n}\n\nclass DslSplendor {\n\n    val buy = createActionType(\"buy\", Card::class)\n    val takeMoney = createActionType(\"takeMoney\", MoneyChoice::class)\n    val reserve = createActionType(\"reserve\", Card::class)\n    val discardMoney = createActionType(\"discardMoney\", MoneyType::class)\n    val splendorGame = createGame<SplendorGame>(\"Splendor\") {\n        setup {\n//            players(2..4)\n            init {\n                SplendorGame()\n            }\n//            effect {\n//                state(\"cards\", game.board)\n//            }\n//            replay {\n//                game.board = state(\"cards\")\n//            }\n        }\n        logic {\n            singleTarget(buy, {it.board}) { // Is it possible to use API as `buy.singleTarget(game.board)` ?\n                allowed { it.game.currentPlayer.canBuy(it.parameter) }\n                effect {\n                    it.game.currentPlayer.buy(it.parameter)\n                    state(\"nextCard\", it.game.replaceCard(it.parameter))\n                }\n//                replayEffect {\n//                    it.game.currentPlayer.buy(it.parameter)\n//                    it.game.replaceCard(it.parameter, state(\"nextCard\") as Card)\n//                }\n            }\n//            singleTarget(discardMoney, {MoneyType.values().toList()}) {\n//                allowed { it.game.currentPlayer.chips.count > 10 }\n//                effect { it.game.currentPlayer.money -= choice }\n//            }\n//            singleTarget(reserve, {it.board}) {\n//                allowed { it.game.currentPlayer.reserved.size < 3 }\n//                effect {\n//                    it.game.currentPlayer.reserve(it.parameter)\n//                    state(\"nextCard\", replaceCard(it.parameter))\n//                }\n//                replayEffect {\n//                    it.game.currentPlayer.reserve(it.parameter)\n//                    replaceCard(it.parameter, state(\"nextCard\"))\n//                }\n//            }\n            action(takeMoney) {\n                options {\n                    option(MoneyType.values().asIterable()) { first ->\n                        option(MoneyType.values().asIterable()) {second ->\n                            if (first == second) {\n                                actionParameter(MoneyChoice(listOf(first, second)))\n                            } else {\n                                option(MoneyType.values().asIterable()) {third ->\n                                    actionParameter(MoneyChoice(listOf(first, second, third)))\n                                }\n                            }\n                        }\n                    }\n                }\n                allowed {\n                    val moneyChosen = it.parameter.toMoney()\n                    if (!it.game.stock.has(moneyChosen)) {\n                        return@allowed false\n                    }\n                    val chosen = it.parameter.moneys\n                    return@allowed when {\n                        chosen.size == 2 -> chosen.distinct().size == 1 && it.game.stock.has(moneyChosen.plus(moneyChosen))\n                        chosen.size == 3 -> chosen.distinct().size == chosen.size\n                        else -> false\n                    }\n                }\n                effect {\n                    it.game.stock -= it.parameter.toMoney()\n                    it.game.currentPlayer.chips += it.parameter.toMoney()\n                }\n            }\n        }\n        fun viewMoney(money: Money): List<Pair<String, Int>> {\n            return money.moneys.entries.sortedBy { it.key.name }.map { it.key.name to it.value }\n        }\n        fun viewCard(card: Card): Map<String, Any?> {\n            // TODO: Test without this special mapping function. Perhaps it works anyway?\n            return mapOf(\n                \"level\" to card.level,\n                \"discount\" to card.discounts,\n                \"costs\" to card.costs,\n                \"points\" to card.points\n            )\n        }\n        view {\n            currentPlayer { it.currentPlayerIndex }\n//            winner { game -> game.winner.takeIf { game.isFinished } }\n            value(\"board\") {game ->\n                game.board.map { viewCard(it) }\n            }\n            value(\"stock\") {game ->\n                game.stock\n            }\n            value(\"players\") {game ->\n                game.players.map {\n                    mapOf(\n                        \"money\" to it.chips,\n                        \"cards\" to it.owned,\n                        \"reserved\" to it.reserved.size // TODO: Add possibility for that player to see this card\n                    )\n                }\n            }\n        }\n    }\n}\n", "issues": 0.0, "main_language": null, "forks": 0, "stars": 0, "commit_sha": "cb1cafb4d5ae5c09a9edb336f04ef7cf48ee2714", "size": 8421, "name": "Server2", "license": "MIT License"}
{"path": "src/main/kotlin/co/csadev/advent2020/Day03.kt", "owner": "gtcompscientist", "repo_id": 577439489, "is_fork": false, "languages_distribution": "{\"Kotlin\": 252918}", "content": "/**\n * Copyright (c) 2021 by <NAME>\n * Advent of Code 2020, Day 3\n * Problem Description: http://adventofcode.com/2020/day/3\n */\npackage co.csadev.advent2020\n\nclass Day03(private val input: List<String>) {\n\n    private val width = input.first().length\n\n    fun solvePart1(): Int = checkTrees(3 to 1)\n\n    fun solvePart2(): Long = listOf(1 to 1, 3 to 1, 5 to 1, 7 to 1, 1 to 2).fold(1L) { acc, i ->\n        acc * checkTrees(i)\n    }\n\n    private fun checkTrees(slope: Pair<Int, Int>): Int {\n        var trees = 0\n        var location = 0 to 0\n        while (location.second < input.size) {\n            trees += if (input[location.second][location.first] == '#') 1 else 0\n            location += slope\n        }\n        return trees\n    }\n\n    private operator fun Pair<Int, Int>.plus(slope: Pair<Int, Int>) = Pair(\n        (first + slope.first) % width,\n        second + slope.second\n    )\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "43cbaac4e8b0a53e8aaae0f67dfc4395080e1383", "size": 901, "name": "advent-of-kotlin", "license": "Apache License 2.0"}
{"path": "src/year_2022/day_12/Day12.kt", "owner": "scottschmitz", "repo_id": 572656097, "is_fork": false, "languages_distribution": "{\"Kotlin\": 240069}", "content": "package year_2022.day_12\n\nimport readInput\nimport util.toAlphabetPosition\n\ndata class Position(\n    val row: Int,\n    val column: Int\n)\n\ndata class Heatmap (\n    val startingPosition: Position,\n    val endingPosition: Position,\n    val locations: List<List<Int>>\n)\n\nobject Day12 {\n\n    /**\n     * @return\n     */\n    fun solutionOne(text: List<String>): Int {\n        val startingElevation = 'a'.toAlphabetPosition()\n        val endingElevation = 'z'.toAlphabetPosition()\n\n        val heatmap = parseText(\n            text = text,\n            startingElevation = startingElevation,\n            endingElevation = endingElevation\n        )\n\n        val path = findPath(heatmap, heatmap.startingPosition, heatmap.endingPosition)!!\n        return path.size - 1\n    }\n\n    /**\n     * @return\n     */\n    fun solutionTwo(text: List<String>): Int {\n        val startingElevation = 'a'.toAlphabetPosition()\n        val endingElevation = 'z'.toAlphabetPosition()\n\n        val heatmap = parseText(\n                text = text,\n                startingElevation = startingElevation,\n                endingElevation = endingElevation\n        )\n\n        val lowestLocations = mutableListOf<Position>()\n        heatmap.locations.forEachIndexed { rowIndex, row ->\n            row.forEachIndexed { colIndex, height ->\n                if (height == 1) {\n                    lowestLocations.add(Position(rowIndex, colIndex))\n                }\n            }\n        }\n\n        return lowestLocations\n            .mapNotNull { position ->\n                findPath(heatmap, position, heatmap.endingPosition)?.size\n            }\n            .minByOrNull { it }!! - 1\n    }\n\n    private fun parseText(\n        text: List<String>,\n        startingElevation: Int,\n        endingElevation: Int\n    ): Heatmap {\n\n        var startingPosition = Position(0, 0)\n        var endingPosition = Position(0,0)\n\n        val locations = text.mapIndexed() { row, line ->\n            line.mapIndexed { column, letter ->\n                when (letter) {\n                    'S' -> {\n                        startingPosition = Position(row, column)\n                        startingElevation\n                    }\n                    'E' -> {\n                        endingPosition = Position(row, column)\n                        endingElevation\n                    }\n                    else -> letter.toAlphabetPosition()\n                }\n            }\n        }\n\n        return Heatmap(\n            startingPosition = startingPosition,\n            endingPosition = endingPosition,\n            locations = locations\n        )\n    }\n\n    private fun findPath(heatmap: Heatmap, startingPosition: Position, endingPosition: Position): List<Position>? {\n        val shortestDistance = mutableMapOf<Position, List<Position>>()\n        val toEvaluateDistance = mutableListOf<Pair<List<Position>, Position>>() // path to positionToEvaluate\n\n        val startingElevation = heatmap.locations[startingPosition.row][startingPosition.column]\n\n        shortestDistance[startingPosition] = listOf(startingPosition)\n        val potentialSteps = potentialSteps(startingPosition, heatmap.locations)\n        potentialSteps.forEach { position ->\n            toEvaluateDistance.add(listOf(startingPosition) to position)\n        }\n\n        while (toEvaluateDistance.isNotEmpty()) {\n            val (path, position) = toEvaluateDistance.removeFirst()\n            val fullPath = path + position\n\n            when (val previousShortest = shortestDistance[position]) {\n                null -> {\n                    shortestDistance[position] = fullPath\n                    potentialSteps(position, heatmap.locations).forEach { potentialNextStep ->\n                        toEvaluateDistance.add(fullPath to potentialNextStep)\n                    }\n                }\n                else -> {\n                    if (fullPath.size < previousShortest.size) {\n                        shortestDistance[position] = fullPath\n                        potentialSteps(position, heatmap.locations).forEach { potentialNextStep ->\n                            toEvaluateDistance.add(fullPath to potentialNextStep)\n                        }\n                    }\n                }\n            }\n        }\n\n        return shortestDistance[endingPosition]\n    }\n\n    private fun potentialSteps(position: Position, locations: List<List<Int>>): List<Position> {\n        val elevation = locations[position.row][position.column]\n        val possibleOtherPositions = mutableListOf<Position>()\n\n        // up\n        if (position.row > 0 && locations[position.row - 1][position.column] <= elevation + 1) {\n            possibleOtherPositions.add(Position(position.row - 1, position.column))\n        }\n\n        // down\n        if (position.row < locations.size - 1 && locations[position.row + 1][position.column] <= elevation + 1) {\n            possibleOtherPositions.add(Position(position.row + 1, position.column))\n        }\n\n        // left\n        if (position.column > 0 && locations[position.row][position.column - 1] <= elevation + 1) {\n            possibleOtherPositions.add(Position(position.row, position.column - 1))\n        }\n\n        // right\n        if (position.column < locations.first().size - 1 && locations[position.row][position.column + 1] <= elevation + 1) {\n            possibleOtherPositions.add(Position(position.row, position.column + 1))\n        }\n\n        return possibleOtherPositions\n    }\n}\n\nfun main() {\n    val inputText = readInput(\"year_2022/day_12/Day12.txt\")\n\n    val solutionOne = Day12.solutionOne(inputText)\n    println(\"Solution 1: $solutionOne\")\n\n    val solutionTwo = Day12.solutionTwo(inputText)\n    println(\"Solution 2: $solutionTwo\")\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "70efc56e68771aa98eea6920eb35c8c17d0fc7ac", "size": 5691, "name": "advent_of_code", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/day24_arithmetic_logic_unit/ArithmeticLogicUnit.kt", "owner": "barneyb", "repo_id": 425532798, "is_fork": false, "languages_distribution": "{\"Kotlin\": 238776, \"Shell\": 3825, \"Java\": 567}", "content": "package day24_arithmetic_logic_unit\n\n/**\n * At first blush, this looks like a \"build an interpreter/VM\" sort of problem\n * in the style of Intcode. However, 9^14 numbers to check... This is another\n * \"find the optimal path\" (like Chiton #15), but the thing you need to find a\n * path through is expressed by the input program's _behavior_, not a map you\n * are provided. The only info you know is that the final Z must be zero, so\n * pruning the \"paths\" has to be done backwards. You don't necessarily need an\n * interpreter either; manually disassembling to identify the algorithm, and\n * then re-coding in your solution language will work just as well.\n *\n * Part two is just inverting the fitness function: find min vs find max.\n */\nfun main() {\n    util.solve(51983999947999, ::partOne) // 51993999947999 is too high\n    util.solve(11211791111365, ::partTwo)\n}\n\nprivate typealias Round = List<Op>\n\nprivate fun Round.execute(z: Long, w: Long) =\n    Machine().let { m ->\n        m.z = z\n        m.execute(this, listOf(w))\n        m.z\n    }\n\nprivate fun Round.searchIn(targets: Set<Long>): Set<Long> =\n    mutableSetOf<Long>().let { next ->\n        for (z in -10_000..10_000L)\n            for (w in 1..9L)\n                if (targets.contains(execute(z, w)))\n                    next.add(z)\n        next\n    }\n\nprivate typealias Slices = List<Round>\n\nprivate fun Slices.buildInputZByRound(): Map<Int, Set<Long>> =\n    mutableMapOf<Int, Set<Long>>().also { byRound ->\n        ((size - 1) downTo 0).fold(setOf(0L)) { targets, r ->\n            if (targets.isEmpty()) {\n                throw IllegalStateException(\"no targets for round $r\")\n            }\n            byRound[r] = this[r].searchIn(targets)\n            byRound[r]!!\n        }\n    }\n\nfun partOne(input: String) =\n    solve(input, 9 downTo 1L)\n\nfun solve(input: String, digitPriority: Iterable<Long>): Long {\n    // break the problem into per-digit rounds\n    val m = Machine()\n    val slices = m.parse(input)\n        .chunked(18)\n\n    // back-track and find all the per-round output Z that might work\n    val inputZByRound = slices.buildInputZByRound()\n\n    // go forward and find the largest per-round W that passes the check\n    fun walk(r: Int, z: Long, digits: List<Long>): Long {\n        if (digits.size == 14) {\n            return digits.fold(0L) { agg, n ->\n                agg * 10 + n\n            }\n        }\n        val targets = if (r == 13) setOf(0L)\n        else inputZByRound[r + 1]!!\n        for (w in digitPriority) {\n            val v = slices[r].execute(z, w)\n            if (targets.contains(v)) {\n                val answer = walk(r + 1, v, digits + w)\n                if (answer > 0) {\n                    return answer\n                }\n            }\n        }\n        return -1\n    }\n    return walk(0, 0, emptyList())\n}\n\nfun partTwo(input: String) =\n    solve(input, 1..9L)\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "a8d52412772750c5e7d2e2e018f3a82354e8b1c3", "size": 2860, "name": "aoc-2021", "license": "MIT License"}
{"path": "src/main/kotlin/com/adventofcode/year2021/day3/part2/App.kt", "owner": "demidko", "repo_id": 433889383, "is_fork": false, "languages_distribution": "{\"Kotlin\": 7692, \"Dockerfile\": 264}", "content": "package com.adventofcode.year2021.day3.part2\n\nimport com.adventofcode.year2021.day\nimport java.math.BigInteger\n\nfun List<String>.mostCommonBit(column: Int): Char {\n  return when (count { it[column] == '1' } >= count { it[column] == '0' }) {\n    true -> '1'\n    else -> '0'\n  }\n}\n\nfun List<String>.leastCommonBit(column: Int): Char {\n  return when (count { it[column] == '0' } <= count { it[column] == '1' }) {\n    true -> '0'\n    else -> '1'\n  }\n}\n\ntailrec fun List<String>.filterBy(detectBitCriteria: List<String>.(Int) -> Char, column: Int = 0): BigInteger {\n  val bitCriteria = detectBitCriteria(column)\n  val foundedNumbers = filter { it[column] == bitCriteria }\n  return when (foundedNumbers.size > 1) {\n    true -> foundedNumbers.filterBy(detectBitCriteria, column + 1)\n    else -> BigInteger(foundedNumbers.first(), 2)\n  }\n}\n\n\nfun main() {\n  val allBinaryNumbers = day(3)\n  val oxygenGeneratorRating = allBinaryNumbers.filterBy(List<String>::mostCommonBit)\n  val co2ScrubberRating = allBinaryNumbers.filterBy(List<String>::leastCommonBit)\n  println(oxygenGeneratorRating * co2ScrubberRating)\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "2f42bede3ed0c4b17cb2575f6b61a1917a465bda", "size": 1101, "name": "adventofcode", "license": "MIT License"}
{"path": "src/main/kotlin/com/github/fantom/codeowners/search/CodeownersSearchFilter.kt", "owner": "fan-tom", "repo_id": 325829611, "is_fork": false, "languages_distribution": "{\"Kotlin\": 257763, \"Lex\": 5866, \"HTML\": 966}", "content": "package com.github.fantom.codeowners.search\n\nimport com.github.fantom.codeowners.CodeownersManager\nimport com.github.fantom.codeowners.OwnersList\nimport com.github.fantom.codeowners.indexing.CodeownersEntryOccurrence\nimport com.github.fantom.codeowners.indexing.OwnerString\nimport com.intellij.openapi.vfs.VirtualFile\n\ninterface Predicate {\n    // TODO change to OwnersSet, duplicates make no sense\n    fun satisfies(fileOwners: OwnersList?): Boolean\n}\n\nsealed interface Filter: Predicate {\n    fun displayName(): CharSequence\n\n    // TODO rewrite using service + context\n    /**\n     * @return false, if this filter definitely cannot be satisfied by given codeowners file, true otherwise\n     */\n    fun satisfiable(codeownersFile: CodeownersEntryOccurrence): Boolean\n\n    sealed interface Condition: Filter {\n        // files without assigned owners\n        data object Unowned: Condition {\n            override fun displayName() = \"unowned\"\n\n            override fun satisfiable(codeownersFile: CodeownersEntryOccurrence): Boolean {\n                return true // cannot easily calculate it precise: need to proof there is at least one unowned file\n            }\n\n            override fun satisfies(fileOwners: OwnersList?) = fileOwners == null\n        }\n\n        // explicitly unowned files\n        data object OwnershipReset: Condition {\n            override fun displayName() = \"explicitly unowned\"\n\n            override fun satisfiable(codeownersFile: CodeownersEntryOccurrence): Boolean {\n                return codeownersFile.items.any { it.second.owners.isEmpty() }\n            }\n\n            override fun satisfies(fileOwners: OwnersList?) = fileOwners?.isEmpty() ?: false\n        }\n\n        // files, owned by any (at least one) of the given owners\n        data class OwnedByAnyOf(val owners: Set<OwnerString>): Condition {\n            override fun displayName() = \"owned by any of ${owners.joinToString(\", \")}\"\n\n            override fun satisfiable(codeownersFile: CodeownersEntryOccurrence): Boolean {\n                return true // because \"owners\" can be only from this file, so they own some files\n            }\n\n            override fun satisfies(fileOwners: OwnersList?) = fileOwners?.any { it in owners } ?: false\n        }\n\n        // files, owned by all the given owners, and maybe by some extra owners\n        data class OwnedByAllOf(val owners: Set<OwnerString>): Condition {\n            override fun displayName() = \"owned by all of ${owners.joinToString(\", \")}\"\n\n            override fun satisfiable(codeownersFile: CodeownersEntryOccurrence): Boolean {\n                return codeownersFile.items.map { it.second }.any { satisfies(it.owners) }\n            }\n\n            override fun satisfies(fileOwners: OwnersList?) = fileOwners?.containsAll(owners) ?: false\n        }\n\n        // files, owned by only given owners, no extra owners allowed\n        data class OwnedByExactly(val owners: Set<OwnerString>): Condition {\n            override fun displayName() = \"owned by exactly ${owners.joinToString(\", \")}\"\n\n            override fun satisfiable(codeownersFile: CodeownersEntryOccurrence): Boolean {\n                return codeownersFile.items.map { it.second }.any { satisfies(it.owners) }\n            }\n\n            override fun satisfies(fileOwners: OwnersList?) = fileOwners?.let { owners == it.toSet() } ?: false\n        }\n    }\n\n    // negation of some Condition\n    data class Not(val condition: Condition): Filter {\n        override fun displayName() = \"not ${condition.displayName()}\"\n\n        override fun satisfiable(codeownersFile: CodeownersEntryOccurrence): Boolean {\n            // cannot calculate it in abstract: it depends on the nature of the \"condition\"\n            return true\n        }\n\n        override fun satisfies(fileOwners: OwnersList?): Boolean {\n            return !condition.satisfies(fileOwners)\n        }\n    }\n}\n\n// disjunction of conjunctions\ndata class DNF(val filters: List<List<Filter>>): Predicate {\n    override fun satisfies(fileOwners: OwnersList?) = filters.any { conj -> conj.all { n -> n.satisfies(fileOwners) } }\n\n    fun displayName() =\n        filters.joinToString(\" or \") { conj -> \"(${conj.joinToString(\" and \") { n -> n.displayName() }})\" }\n}\n\ndata class CodeownersSearchFilter(\n    val codeownersFile: CodeownersEntryOccurrence,\n    // DNF: disjunction of conjunctions\n    private val dnf: DNF\n): Predicate by dnf {\n    fun displayName() = \"${codeownersFile.url}: ${dnf.displayName()}\"\n\n    context(CodeownersManager)\n    fun satisfies(file: VirtualFile): Boolean {\n        val ownersRef = getFileOwners(file, codeownersFile).getOrNull() ?: return false\n        val ownersList = ownersRef.ref?.owners\n\n        return satisfies(ownersList)\n    }\n}", "issues": 22.0, "main_language": "Kotlin", "forks": 4, "stars": 15, "commit_sha": "f898c1113f2f81b25aaeb6ba87f8e570da0ba08e", "size": 4726, "name": "intellij-codeowners", "license": "MIT License"}
{"path": "src/Day06.kt", "owner": "euphonie", "repo_id": 571665044, "is_fork": false, "languages_distribution": "{\"Kotlin\": 23344}", "content": "fun main() {\n    \n    fun findFirstUniqueSequence(input: String, windowSize: Int) : Int {\n        var startIndex = 0\n\n        for (i in IntRange(0, input.length-windowSize-1) step 1) {\n            val letters = input.substring(i, i+windowSize)\n            if (letters.toSet().size == letters.toList().size) {\n                startIndex = i\n                break\n            }\n        }\n        return startIndex + windowSize\n    }\n    \n    fun part1(input: List<String>) : List<Int> {\n        val windowSize = 4\n        return input.map { findFirstUniqueSequence(it, windowSize) }\n    }\n    fun part2(input: List<String>) : List<Int> {\n        val markerSize = 4\n        val messageSize = 14\n        return input.map { \n            val markerIndex = findFirstUniqueSequence(it, markerSize) + 1\n            Pair(\n                markerIndex,\n                it.substring(markerIndex, it.length)\n            )\n        }\n        .map { findFirstUniqueSequence(it.second, messageSize) + it.first }\n    }\n\n    val testInput = readInput(\"Day06_test\")\n    check(part1(testInput) == listOf(7, 5, 6, 10, 11))\n    check(part2(testInput) == listOf(25,23,23,29,26))\n    \n    val input = readInput(\"Day06\")\n    check(part1(input) == listOf(1598))\n    check(part2(input) == listOf(2414))\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "82e167e5a7e9f4b17f0fbdfd01854c071d3fd105", "size": 1275, "name": "advent-of-code-kotlin", "license": "Apache License 2.0"}
{"path": "src/y2015/Day06.kt", "owner": "gaetjen", "repo_id": 572857330, "is_fork": false, "languages_distribution": "{\"Kotlin\": 325874, \"Mermaid\": 571}", "content": "package y2015\n\nimport util.getRange\nimport util.printMatrix\nimport util.readInput\nimport kotlin.math.max\n\n\ndata class Light(var on: Boolean = false, var brightness: Int = 0) {\n    fun toggle() {\n        on = !on\n    }\n\n    fun turnOn() {\n        on = true\n    }\n\n    fun turnOff() {\n        on = false\n    }\n\n    fun increase() {\n        brightness += 1\n    }\n\n    fun decrease() {\n        brightness = max(brightness - 1, 0)\n    }\n\n    fun jump() {\n        increase()\n        increase()\n    }\n}\n\ndata class Switch(\n    val instruction: String,\n    val startRow: Int,\n    val stopRow: Int,\n    val startCol: Int,\n    val stopCol: Int\n)\n\nobject Day06 {\n    private fun parse(input: List<String>): List<Switch> {\n        return input.map { line ->\n            val (ins, start, _, stop) =  line.split(' ').takeLast(4)\n            val (rowStart, colStart) = start.split(',').map { it.toInt() }\n            val (rowStop, colStop) = stop.split(',').map { it.toInt() }\n            Switch(\n                ins,\n                rowStart,\n                rowStop,\n                colStart,\n                colStop\n            )\n        }\n    }\n\n    fun part1(input: List<String>): Int {\n        val parsed = parse(input)\n        val lightGrid = List(1000) { List(1000) {Light()} }\n        parsed.forEach {\n            getRange(lightGrid, it.startRow, it.startCol, it.stopRow, it.stopCol).map { light ->\n                when (it.instruction) {\n                    \"on\" -> light.turnOn()\n                    \"off\" -> light.turnOff()\n                    else -> light.toggle()\n                }\n            }\n        }\n        printMatrix(lightGrid) {\n            if (it.on) \"*\" else \" \"\n        }\n        return lightGrid.flatten().filter { it.on }.size\n    }\n\n    fun part2(input: List<String>): Int {\n        val parsed = parse(input)\n        val lightGrid = List(1000) { List(1000) {Light()} }\n        parsed.forEach {\n            getRange(lightGrid, it.startRow, it.startCol, it.stopRow, it.stopCol).map { light ->\n                when (it.instruction) {\n                    \"on\" -> light.increase()\n                    \"off\" -> light.decrease()\n                    else -> light.jump()\n                }\n            }\n        }\n        printMatrix(lightGrid) {\n            it.brightness.toString()\n        }\n        return lightGrid.flatten().sumOf { it.brightness }\n    }\n}\n\nfun main() {\n    val testInput = \"\"\"\n        turn on 0,0 through 999,999\n        toggle 0,0 through 999,0\n        turn off 499,499 through 500,500\n    \"\"\".trimIndent().split(\"\\n\")\n    println(\"------Tests------\")\n    println(Day06.part1(testInput))\n    println(Day06.part2(testInput))\n\n    println(\"------Real------\")\n    val input = readInput(\"resources/2015/day06\")\n    println(Day06.part1(input))\n    println(Day06.part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "d0b9b5e16cf50025bd9c1ea1df02a308ac1cb66a", "size": 2803, "name": "advent-of-code", "license": "Apache License 2.0"}
{"path": "src/Day02.kt", "owner": "JIghtuse", "repo_id": 572807913, "is_fork": false, "languages_distribution": "{\"Kotlin\": 46764}", "content": "import java.lang.IllegalStateException\n\nenum class Shape {\n    Rock,\n    Paper,\n    Scissors\n}\n\nfun opponentInputToShape(s: String): Shape =\n    when (s) {\n        \"A\" -> Shape.Rock\n        \"B\" -> Shape.Paper\n        \"C\" -> Shape.Scissors\n        else -> throw IllegalStateException(\"invalid opponent input $s\")\n    }\n\nfun ourInputToShape(s: String): Shape =\n    when (s) {\n        \"X\" -> Shape.Rock\n        \"Y\" -> Shape.Paper\n        \"Z\" -> Shape.Scissors\n        else -> throw IllegalStateException(\"invalid our input $s\")\n    }\n\nfun scoreForShape(shape: Shape) =\n    when (shape) {\n        Shape.Rock -> 1\n        Shape.Paper -> 2\n        Shape.Scissors -> 3\n    }\n\nfun scoreForRound(me: Shape, opponent: Shape): Int {\n    if (me == opponent) {\n        return 3 // draw\n    }\n\n    return when (me to opponent) {\n        (Shape.Rock to Shape.Scissors) -> 6 // win\n        (Shape.Scissors to Shape.Paper) -> 6 // win\n        (Shape.Paper to Shape.Rock) -> 6 // win\n        else -> 0 // lost\n    }\n}\n\nfun main() {\n    fun scoreForTwoShapes(me: Shape, opponent: Shape) =\n        scoreForShape(me) + scoreForRound(me, opponent)\n\n    fun part1(input: List<String>): Int =\n        input.sumOf {\n            val (s, t) = it.split(\" \")\n            val ourShape = ourInputToShape(t)\n            val opponentShape = opponentInputToShape(s)\n\n            scoreForTwoShapes(ourShape, opponentShape)\n        }\n\n    fun determineShape(opponent: Shape, expectedOutcome: String) =\n        when (opponent to expectedOutcome) {\n            Shape.Rock to \"Z\" -> Shape.Paper\n            Shape.Scissors to \"Z\" -> Shape.Rock\n            Shape.Paper to \"Z\" -> Shape.Scissors\n            Shape.Rock to \"X\" -> Shape.Scissors\n            Shape.Scissors to \"X\" -> Shape.Paper\n            Shape.Paper to \"X\" -> Shape.Rock\n            else -> opponent\n    }\n\n    fun part2(input: List<String>): Int =\n        input.sumOf {\n            val (s, t) = it.split(\" \")\n            val opponentShape = opponentInputToShape(s)\n            val ourShape = determineShape(opponentShape, t)\n\n            scoreForTwoShapes(ourShape, opponentShape)\n        }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day02_test\")\n    check(part1(testInput) == 15)\n\n    val input = readInput(\"Day02\")\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "8f33c74e14f30d476267ab3b046b5788a91c642b", "size": 2358, "name": "aoc-2022-in-kotlin", "license": "Apache License 2.0"}
{"path": "year2021/day14/part1/src/main/kotlin/com/curtislb/adventofcode/year2021/day14/part1/Year2021Day14Part1.kt", "owner": "curtislb", "repo_id": 226797689, "is_fork": false, "languages_distribution": "{\"Kotlin\": 2146738}", "content": "/*\n--- Day 14: Extended Polymerization ---\n\nThe incredible pressures at this depth are starting to put a strain on your submarine. The submarine\nhas polymerization equipment that would produce suitable materials to reinforce the submarine, and\nthe nearby volcanically-active caves should even have the necessary input elements in sufficient\nquantities.\n\nThe submarine manual contains instructions for finding the optimal polymer formula; specifically, it\noffers a polymer template and a list of pair insertion rules (your puzzle input). You just need to\nwork out what polymer would result after repeating the pair insertion process a few times.\n\nFor example:\n\n```\nNNCB\n\nCH -> B\nHH -> N\nCB -> H\nNH -> C\nHB -> C\nHC -> B\nHN -> C\nNN -> C\nBH -> H\nNC -> B\nNB -> B\nBN -> B\nBB -> N\nBC -> B\nCC -> N\nCN -> C\n```\n\nThe first line is the polymer template - this is the starting point of the process.\n\nThe following section defines the pair insertion rules. A rule like `AB -> C` means that when\nelements `A` and `B` are immediately adjacent, element `C` should be inserted between them. These\ninsertions all happen simultaneously.\n\nSo, starting with the polymer template `NNCB`, the first step simultaneously considers all three\npairs:\n\n- The first pair (`NN`) matches the rule `NN -> C`, so element `C` is inserted between the first `N`\n  and the second `N`.\n- The second pair (`NC`) matches the rule `NC -> B`, so element `B` is inserted between the `N` and\n  the `C`.\n- The third pair (`CB`) matches the rule `CB -> H`, so element `H` is inserted between the `C` and\n  the `B`.\n\nNote that these pairs overlap: the second element of one pair is the first element of the next pair.\nAlso, because all pairs are considered simultaneously, inserted elements are not considered to be\npart of a pair until the next step.\n\nAfter the first step of this process, the polymer becomes `NCNBCHB`.\n\nHere are the results of a few steps using the above rules:\n\n```\nTemplate:     NNCB\nAfter step 1: NCNBCHB\nAfter step 2: NBCCNBBBCBHCB\nAfter step 3: NBBBCNCCNBBNBNBBCHBHHBCHB\nAfter step 4: NBBNBNBBCCNBCNCCNBBNBBNBBBNBBNBBCBHCBHHNHCBBCBHCB\n```\n\nThis polymer grows quickly. After step 5, it has length 97; After step 10, it has length 3073. After\nstep 10, `B` occurs 1749 times, `C` occurs 298 times, `H` occurs 161 times, and `N` occurs 865\ntimes; taking the quantity of the most common element (`B`, 1749) and subtracting the quantity of\nthe least common element (`H`, 161) produces 1749 - 161 = 1588.\n\nApply 10 steps of pair insertion to the polymer template and find the most and least common elements\nin the result. What do you get if you take the quantity of the most common element and subtract the\nquantity of the least common element?\n*/\n\npackage com.curtislb.adventofcode.year2021.day14.part1\n\nimport com.curtislb.adventofcode.year2021.day14.polymer.PolymerizationProcess\nimport java.nio.file.Path\nimport java.nio.file.Paths\n\n/**\n * Returns the solution to the puzzle for 2021, day 14, part 1.\n *\n * @param inputPath The path to the input file for this puzzle.\n * @param stepCount The number of pair insertion steps to apply to the polymer template.\n */\nfun solve(inputPath: Path = Paths.get(\"..\", \"input\", \"input.txt\"), stepCount: Int = 10): Long {\n    val polymerization = PolymerizationProcess.fromFile(inputPath.toFile())\n    polymerization.applyPairInsertions(stepCount)\n    return polymerization.maxElementCountDifference()\n}\n\nfun main() {\n    println(solve())\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 1, "stars": 1, "commit_sha": "6b64c9eb181fab97bc518ac78e14cd586d64499e", "size": 3450, "name": "AdventOfCode", "license": "MIT License"}
{"path": "src/com/ajithkumar/aoc2022/Day09.kt", "owner": "ajithkumar", "repo_id": 574372025, "is_fork": false, "languages_distribution": "{\"Kotlin\": 21950}", "content": "package com.ajithkumar.aoc2022\n\nimport com.ajithkumar.utils.*\nimport kotlin.math.absoluteValue\n\nclass Knot(var X: Int, var Y: Int) {\n    fun moveAlone(direction: String) {\n        when(direction) {\n            \"L\" -> X-=1\n            \"R\" -> X+=1\n            \"U\" -> Y+=1\n            \"D\" -> Y-=1\n        }\n    }\n\n    fun moveLinked(leadingKnot: Knot): Boolean {\n        val xDiff = (leadingKnot.X - this.X)\n        val yDiff = (leadingKnot.Y - this.Y)\n        if(xDiff.absoluteValue > 1 || yDiff.absoluteValue > 1) {\n            if(xDiff.absoluteValue == 2 && yDiff.absoluteValue == 2) {\n                X = leadingKnot.X + (if(xDiff < 0)  1 else -1)\n                Y = leadingKnot.Y + (if(yDiff < 0)  1 else -1)\n            } else if(xDiff.absoluteValue == 2) {\n                X = leadingKnot.X + (if(xDiff < 0)  1 else -1)\n                Y = if(yDiff.absoluteValue > 0) leadingKnot.Y else this.Y\n            } else {\n                X = if(xDiff.absoluteValue > 0) leadingKnot.X else this.X\n                Y = leadingKnot.Y + (if(yDiff < 0)  1 else -1)\n            }\n            return true\n        }\n        return false\n    }\n\n    fun currentPosition(): Pair<Int, Int> {\n        return Pair(X, Y)\n    }\n}\n\nclass Rope(private val numberOfKnots: Int) {\n    private val knots = buildList {\n        repeat(numberOfKnots) {\n            add(Knot(0,0))\n        }\n    }\n    val tailVisited = mutableSetOf(knots.last().currentPosition())\n    fun moveHead(direction: String, steps: Int) {\n        repeat(steps) {\n            moveHeadOnce(direction)\n            tailVisited.add(knots.last().currentPosition())\n        }\n    }\n\n    private fun moveHeadOnce(direction: String) {\n        knots[0].moveAlone(direction)\n        for(i in 1 until knots.size) {\n            val moved = knots[i].moveLinked(knots[i-1])\n            if(!moved) break\n        }\n    }\n}\n\nfun main() {\n    fun part1(input: List<String>): Int {\n        val knotsInRope = 2\n\n        val moves = input.map { it.split(\" \") }\n        val rope = Rope(knotsInRope)\n        moves.forEach { (dir, steps) ->\n            rope.moveHead(dir, steps.toInt())\n        }\n        return rope.tailVisited.size\n    }\n\n    fun part2(input: List<String>): Int {\n        val knotsInRope = 10\n\n        val moves = input.map { it.split(\" \") }\n        val rope = Rope(knotsInRope)\n        moves.forEach { (dir, steps) ->\n            rope.moveHead(dir, steps.toInt())\n        }\n        return rope.tailVisited.size\n    }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day09_test\")\n    println(part1(testInput))\n\n    val testInput2 = readInput(\"Day09_test2\")\n    println(part2(testInput2))\n\n    val input = readInput(\"Day09\")\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "f95b8d1c3c8a67576eb76058a1df5b78af47a29c", "size": 2774, "name": "advent-of-code-kotlin-template", "license": "Apache License 2.0"}
{"path": "app/src/main/java/com/betulnecanli/kotlindatastructuresalgorithms/CodingPatterns/TheBreadth-FirstSearch.kt", "owner": "betulnecanli", "repo_id": 568477911, "is_fork": false, "languages_distribution": "{\"Kotlin\": 167849}", "content": "/*\nThe Breadth-First Search (BFS) coding pattern is a popular technique for traversing or processing data structures \nin a level-by-level manner. \nIt is commonly used with trees, graphs, and other structures where you want to visit all the neighbors at the current\ndepth before moving on to the next level.\n*/\n//1. Binary Tree Level Order Traversal\nimport java.util.*\n\nclass TreeNode(var `val`: Int) {\n    var left: TreeNode? = null\n    var right: TreeNode? = null\n}\n\nfun levelOrderTraversal(root: TreeNode?): List<List<Int>> {\n    val result = mutableListOf<List<Int>>()\n\n    if (root == null) {\n        return result\n    }\n\n    val queue: Queue<TreeNode> = LinkedList()\n    queue.offer(root)\n\n    while (queue.isNotEmpty()) {\n        val levelSize = queue.size\n        val currentLevel = mutableListOf<Int>()\n\n        for (i in 0 until levelSize) {\n            val currentNode = queue.poll()\n            currentLevel.add(currentNode.`val`)\n\n            currentNode.left?.let { queue.offer(it) }\n            currentNode.right?.let { queue.offer(it) }\n        }\n\n        result.add(currentLevel)\n    }\n\n    return result\n}\n\nfun main() {\n    val root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right?.left = TreeNode(15)\n    root.right?.right = TreeNode(7)\n\n    val result = levelOrderTraversal(root)\n    println(\"Level Order Traversal: $result\")\n}\n\n//2. Minimum Depth of a Binary Tree\nclass TreeNode(var `val`: Int) {\n    var left: TreeNode? = null\n    var right: TreeNode? = null\n}\n\nfun minDepth(root: TreeNode?): Int {\n    if (root == null) {\n        return 0\n    }\n\n    val queue: Queue<TreeNode> = LinkedList()\n    queue.offer(root)\n    var depth = 1\n\n    while (queue.isNotEmpty()) {\n        val levelSize = queue.size\n\n        for (i in 0 until levelSize) {\n            val currentNode = queue.poll()\n\n            if (currentNode.left == null && currentNode.right == null) {\n                return depth\n            }\n\n            currentNode.left?.let { queue.offer(it) }\n            currentNode.right?.let { queue.offer(it) }\n        }\n\n        depth++\n    }\n\n    return depth\n}\n\nfun main() {\n    val root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right?.left = TreeNode(15)\n    root.right?.right = TreeNode(7)\n\n    val result = minDepth(root)\n    println(\"Minimum Depth of the Binary Tree: $result\")\n}\n//3. Connect Level Order Siblings\nclass TreeNode(var `val`: Int) {\n    var left: TreeNode? = null\n    var right: TreeNode? = null\n    var next: TreeNode? = null\n}\n\nfun connectLevelOrderSiblings(root: TreeNode?) {\n    if (root == null) {\n        return\n    }\n\n    val queue: Queue<TreeNode> = LinkedList()\n    queue.offer(root)\n\n    while (queue.isNotEmpty()) {\n        val levelSize = queue.size\n        var prevNode: TreeNode? = null\n\n        for (i in 0 until levelSize) {\n            val currentNode = queue.poll()\n\n            if (prevNode != null) {\n                prevNode.next = currentNode\n            }\n\n            prevNode = currentNode\n\n            currentNode.left?.let { queue.offer(it) }\n            currentNode.right?.let { queue.offer(it) }\n        }\n    }\n}\n\nfun main() {\n    val root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left?.left = TreeNode(4)\n    root.left?.right = TreeNode(5)\n    root.right?.left = TreeNode(6)\n    root.right?.right = TreeNode(7)\n\n    connectLevelOrderSiblings(root)\n\n    // The 'next' pointers are now connected level by level\n    println(\"Next pointers connected: ${root.next?.`val`}, ${root.left?.next?.`val`}, ${root.right?.next?.`val`}\")\n}\n/*\nBinary Tree Level Order Traversal:\nThe levelOrderTraversal function performs a BFS traversal of a binary tree, processing nodes level by level. \nIt uses a queue to enqueue and dequeue nodes at each level.\nMinimum Depth of a Binary Tree:\nThe minDepth function calculates the minimum depth of a binary tree using BFS. \nIt traverses the tree level by level, and when it encounters the first leaf node, it returns the depth.\nConnect Level Order Siblings:\nThe connectLevelOrderSiblings function connects the 'next' pointers of nodes at the same level in a binary tree.\nIt uses BFS to traverse the tree level by level and connects the 'next' pointers accordingly.\n*/\n", "issues": 2.0, "main_language": "Kotlin", "forks": 2, "stars": 40, "commit_sha": "70a4a311f0c57928a32d7b4d795f98db3bdbeb02", "size": 4282, "name": "Kotlin-Data-Structures-Algorithms", "license": "Apache License 2.0"}
{"path": "src/day01/Day01.kt", "owner": "emartynov", "repo_id": 572129354, "is_fork": false, "languages_distribution": "{\"Kotlin\": 11347}", "content": "package day01\n\nimport readInput\n\nfun main() {\n    fun part1(input: List<String>): Int {\n        return input.split { string -> string.isEmpty() }\n            .map { list ->\n                list.sumOf { string -> string.toInt() }\n            }.max()\n    }\n\n    fun part2(input: List<String>): Int {\n        return input.split { string -> string.isEmpty() }\n            .map { list ->\n                list.sumOf { string -> string.toInt() }\n            }.sortedDescending()\n            .take(3)\n            .sum()\n    }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"day01/Day01_test\")\n    check(part1(testInput) == 24000)\n    check(part2(testInput) == 45000)\n\n    val input = readInput(\"day01/Day01\")\n    println(part1(input))\n    println(part2(input))\n}\n\nfun <T : Any> List<T>.split(isMarker: (T) -> Boolean): List<List<T>> {\n    val result = mutableListOf<List<T>>()\n    var previousIndex = 0\n    forEachIndexed { index, value ->\n        if (isMarker(value)) {\n            result.add(subList(previousIndex, index))\n            previousIndex = index + 1\n        } else if (index == size -1) {\n            result.add(subList(previousIndex, size))\n        }\n    }\n    return result\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "8f3598cf29948fbf55feda585f613591c1ea4b42", "size": 1240, "name": "advent-of-code-2022", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/cz/tomasbublik/Day01.kt", "owner": "tomasbublik", "repo_id": 572856220, "is_fork": false, "languages_distribution": "{\"Kotlin\": 21908}", "content": "package cz.tomasbublik\n\nfun main() {\n    fun addToGroup(\n        groupedCalories: MutableMap<Int, List<String>>,\n        group: MutableList<String>\n    ) {\n        groupedCalories[group.sumOf { it.toInt() }] = group\n    }\n\n    fun getGroupedCalories(input: List<String>): MutableMap<Int, List<String>> {\n        val groupedCalories: MutableMap<Int, List<String>> = HashMap()\n        var group: MutableList<String> = ArrayList()\n        for (calories in input) {\n            if (calories.isNotEmpty()) {\n                group.add(calories)\n            } else {\n                addToGroup(groupedCalories, group)\n                group = ArrayList()\n            }\n        }\n        if (group.size > 0) {\n            addToGroup(groupedCalories, group)\n        }\n        return groupedCalories\n    }\n\n    fun part1(input: List<String>): Int {\n        val groupedCalories: MutableMap<Int, List<String>> = getGroupedCalories(input)\n\n        return groupedCalories.keys.max()\n    }\n\n    fun part2(input: List<String>): Int {\n        val groupedCalories: MutableMap<Int, List<String>> = getGroupedCalories(input)\n        val sortedCalories = groupedCalories.keys.sorted().reversed()\n\n        return sortedCalories.take(3).sum()\n    }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readFileAsLinesUsingUseLines(\"src/main/resources/day_1_input_test\")\n    check(part1(testInput) == 24000)\n    check(part2(testInput) == 45000)\n\n    val input = readFileAsLinesUsingUseLines(\"src/main/resources/day_1_input\")\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "8c26a93e8f6f7ab0f260c75a287608dd7218d0f0", "size": 1595, "name": "advent-of-code-kotlin-2022", "license": "Apache License 2.0"}
{"path": "kotlinLeetCode/src/main/kotlin/leetcode/editor/cn/[674]最长连续递增序列.kt", "owner": "maoqitian", "repo_id": 175940000, "is_fork": false, "languages_distribution": "{\"Kotlin\": 354268, \"Java\": 297740, \"C++\": 634}", "content": "//给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 \n//\n// 连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那\n//么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 \n//\n// \n//\n// 示例 1： \n//\n// \n//输入：nums = [1,3,5,4,7]\n//输出：3\n//解释：最长连续递增序列是 [1,3,5], 长度为3。\n//尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 \n// \n//\n// 示例 2： \n//\n// \n//输入：nums = [2,2,2,2,2]\n//输出：1\n//解释：最长连续递增序列是 [2], 长度为1。\n// \n//\n// \n//\n// 提示： \n//\n// \n// 0 <= nums.length <= 104 \n// -109 <= nums[i] <= 109 \n// \n// Related Topics 数组 \n// 👍 164 👎 0\n\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\n    fun findLengthOfLCIS(nums: IntArray): Int {\n\n        //连续递增 动态规划 nums[index] > nums[index-1]\n        //时间复杂度 O(n)\n\n        if(nums.isEmpty()) return 0\n\n        var index =0 // 开始递增开始 index\n        var max = 1\n\n        for ( i in 1 until nums.size){\n            if (nums[i] > nums[i-1]){\n                //符合递增\n                //计算记录最大长度\n                max = Math.max(i - index + 1,max)\n            }else{\n                index = i\n            }\n        }\n\n        return  max\n    }\n}\n//leetcode submit region end(Prohibit modification and deletion)\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "8a85996352a88bb9a8a6a2712dce3eac2e1c3463", "size": 1590, "name": "MyLeetCode", "license": "Apache License 2.0"}
{"path": "src/AOC2022/Day04/Day04.kt", "owner": "kfbower", "repo_id": 573519224, "is_fork": false, "languages_distribution": "{\"Kotlin\": 44562}", "content": "package AOC2022.Day04\n\nimport AOC2022.readInput\n\nfun main() {\n\n\n\n    fun part1(input: List<String>): Int {\n        var encapsulatedcount = 0\n        input.forEachIndexed { i, s ->\n\n            val parts = s.split(\",\",\"-\")\n            val min1= parts[0].toInt()\n            val max1 = parts[1].toInt()\n            val min2 = parts[2].toInt()\n            val max2 = parts[3].toInt()\n\n            if (min1 <= min2 && max1>=max2){\n                encapsulatedcount+=1\n            }\n            else if (min2 <= min1 && max2>= max1){\n                encapsulatedcount+=1\n            }\n        }\n\n        return encapsulatedcount\n    }\n\n    fun part2(input: List<String>): Int {\n        var noOverlap = 0\n        input.forEachIndexed { i, s ->\n\n            val parts = s.split(\",\",\"-\")\n            val min1= parts[0].toInt()\n            val max1 = parts[1].toInt()\n            val min2 = parts[2].toInt()\n            val max2 = parts[3].toInt()\n\n            if (max1 < min2){\n                noOverlap +=1\n                println(\"No Overlap\")\n            }\n            else if (max2 < min1){\n                noOverlap +=1\n                println(\"No Overlap\")\n            }\n\n\n        }\n\n        return input.size-noOverlap\n\n\n    }\n\n\n    val input = readInput(\"Day04\")\n    println(part1(input))\n    println(part2(input))\n\n}\n\n\n\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "48a7c563ebee77e44685569d356a05e8695ae36c", "size": 1322, "name": "advent-of-code-2022", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/com/ginsberg/advent2023/Day23.kt", "owner": "tginsberg", "repo_id": 723688654, "is_fork": false, "languages_distribution": "{\"Kotlin\": 112398}", "content": "/*\n * Copyright (c) 2023 by <NAME>\n */\n\n/**\n * Advent of Code 2023, Day 23 - A Long Walk\n * Problem Description: http://adventofcode.com/2023/day/23\n * Blog Post/Commentary: https://todd.ginsberg.com/post/advent-of-code/2023/day23/\n */\npackage com.ginsberg.advent2023\n\nimport kotlin.math.max\n\nclass Day23(input: List<String>) {\n\n    private val grid = input.map { it.toCharArray() }.toTypedArray()\n    private val start = Point2D(input.first().indexOfFirst { it == '.' }, 0)\n    private val goal = Point2D(input.last().indexOfFirst { it == '.' }, input.lastIndex)\n\n    fun solvePart1(): Int =\n        traverse { location ->\n            location.cardinalNeighbors()\n                .filter { grid.isSafe(it) }\n                .filter { newLocation -> grid[newLocation].matchesDirection(newLocation - location) }\n                .map { it to 1 }\n        }\n\n    fun solvePart2(): Int {\n        val reducedGrid = reduceGrid()\n        return traverse { location ->\n            reducedGrid\n                .getValue(location)\n                .map { it.key to it.value }\n        }\n    }\n\n    private fun Char.matchesDirection(direction: Point2D): Boolean =\n        when (this) {\n            '^' -> Point2D.NORTH == direction\n            '<' -> Point2D.WEST == direction\n            'v' -> Point2D.SOUTH == direction\n            '>' -> Point2D.EAST == direction\n            '.' -> true\n            else -> false\n        }\n\n    private fun traverse(nextLocations: (Point2D) -> List<Pair<Point2D, Int>>): Int {\n        var best = 0\n        val visited = mutableSetOf<Point2D>()\n\n        fun traverseWork(location: Point2D, steps: Int):Int {\n            if (location == goal) {\n                best = max(steps, best)\n                return best\n            }\n            visited += location\n            nextLocations(location)\n                .filter { (place, _) -> place !in visited }\n                .forEach { (place, distance) -> traverseWork(place, distance + steps) }\n            visited -= location\n            return best\n        }\n\n        return traverseWork(start, 0)\n    }\n\n    private fun reduceGrid(): Map<Point2D, Map<Point2D, Int>> =\n        grid.findDecisionPoints().let { decisionPoints ->\n            decisionPoints.associateWith { point ->\n                reduceGridFromPoint(point, decisionPoints)\n            }\n        }\n\n    private fun reduceGridFromPoint(from: Point2D, toAnyOther: Set<Point2D>): Map<Point2D, Int> {\n        val queue = ArrayDeque<Pair<Point2D, Int>>().apply {\n            add(from to 0)\n        }\n        val seen = mutableSetOf(from)\n        val answer = mutableMapOf<Point2D, Int>()\n        while (queue.isNotEmpty()) {\n            val (location, distance) = queue.removeFirst()\n            if (location != from && location in toAnyOther) {\n                answer[location] = distance\n            } else {\n                location.cardinalNeighbors()\n                    .filter { grid.isSafe(it) }\n                    .filter { grid[it] != '#' }\n                    .filter { it !in seen }\n                    .forEach {\n                        seen += it\n                        queue.add(it to distance + 1)\n                    }\n            }\n        }\n        return answer\n    }\n\n    private fun Array<CharArray>.findDecisionPoints() = buildSet {\n        add(start)\n        add(goal)\n        this@findDecisionPoints.forEachIndexed { y, row ->\n            row.forEachIndexed { x, c ->\n                if (c != '#') {\n                    Point2D(x, y).apply {\n                        if (cardinalNeighbors()\n                                .filter { grid.isSafe(it) }\n                                .filter { grid[it] != '#' }.size > 2\n                        ) {\n                            add(this)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 12, "commit_sha": "0d5732508025a7e340366594c879b99fe6e7cbf0", "size": 3847, "name": "advent-2023-kotlin", "license": "Apache License 2.0"}
{"path": "2021/src/day17/Solution.kt", "owner": "vadimsemenov", "repo_id": 437677116, "is_fork": false, "languages_distribution": "{\"Kotlin\": 56211, \"Rust\": 37295}", "content": "package day17\n\nimport java.nio.file.Files\nimport java.nio.file.Paths\nimport kotlin.math.absoluteValue\nimport kotlin.math.sign\n\nfun main() {\n  fun part1(input: Input): Int {\n    val (xRange, yRange) = input.toList().map { it.first..it.second }\n    require(xRange.first > 0 && xRange.last >= xRange.first)\n    require(yRange.last < 0 && yRange.last >= yRange.first)\n    // assume we can find X such that X * (X + 1) / 2 in xRange and X <= Y * 2 + 1\n    // works for my test case, YMMW\n    val y = yRange.first.absoluteValue - 1\n    return y * (y + 1) / 2\n  }\n\n  fun part2(input: Input): Int {\n    val (xRange, yRange) = input.toList().map { it.first..it.second }\n    require(xRange.first > 0 && xRange.last >= xRange.first)\n    require(yRange.last < 0 && yRange.last >= yRange.first)\n    var answer = 0\n    for (xv in 1..xRange.last) {\n      for (yv in yRange.first..yRange.first.absoluteValue) {\n        var (cx, cy) = 0 to 0\n        var (cxv, cyv) = xv to yv\n        while (true) {\n          cx += cxv.also { cxv -= cxv.sign }\n          cy += cyv--\n          if (cx in xRange && cy in yRange) {\n            answer++\n            break\n          }\n          if (cx > xRange.last || cy < yRange.first) break\n        }\n      }\n    }\n    return answer\n  }\n\n//  illustrate(7, 2, readInput(\"test-input.txt\"))\n//  illustrate(6, 3, readInput(\"test-input.txt\"))\n//  illustrate(9, 0, readInput(\"test-input.txt\"))\n//  illustrate(17, -4, readInput(\"test-input.txt\"))\n//  illustrate(6, 9, readInput(\"test-input.txt\"))\n//  illustrate(6, 10, readInput(\"test-input.txt\"))\n\n  check(part1(readInput(\"test-input.txt\")) == 45)\n  check(part2(readInput(\"test-input.txt\")) == 112)\n\n  println(part1(readInput(\"input.txt\")))\n  println(part2(readInput(\"input.txt\")))\n}\n\nprivate fun illustrate(xv: Int, yv: Int, target: Input) {\n  val (txRange, tyRange) = target\n  val tx = txRange.first..txRange.second\n  val ty = tyRange.first..tyRange.second\n  var (cx, cy) = 0 to 0\n  var (cxv, cyv) = xv to yv\n  val visited = mutableListOf<Pair<Int, Int>>()\n  while (cx <= tx.last && cy >= ty.last) {\n    cx += cxv.also { cxv -= cxv.sign }\n    cy += cyv--\n    visited.add(cx to cy)\n  }\n  val minX = minOf(minOf(0, tx.first), visited.minOf { it.first })\n  val maxX = maxOf(maxOf(0, tx.last), visited.maxOf { it.first })\n  val minY = minOf(minOf(0, ty.first), visited.minOf { it.second })\n  val maxY = maxOf(maxOf(0, ty.last), visited.maxOf { it.second })\n  val output = Array(maxY - minY + 1) {\n    CharArray(maxX - minX + 1) { '.' }\n  }\n  for (x in tx) {\n    for (y in ty) {\n      output[maxY - y][x - minX] = 'T'\n    }\n  }\n  output[maxY - 0][0 - minX] = 'S'\n  for ((x, y) in visited) {\n    output[maxY - y][x - minX] = '#'\n  }\n  println(\"($xv, $yv) -> $target\")\n  println(output.joinToString(\"\\n\") { String(it) })\n}\n\n\nprivate fun readInput(s: String): Input {\n  return Files.newBufferedReader(Paths.get(\"src/day17/$s\")).readLine()!!.let { line ->\n    val (xRange, yRange) = line.substring(\"target area: \".length).split(\", \")\n    val (xMin, xMax) = xRange.substring(\"x=\".length).split(\"..\").map { it.toInt() }\n    val (yMin, yMax) = yRange.substring(\"y=\".length).split(\"..\").map { it.toInt() }\n    Pair(xMin to xMax, yMin to yMax)\n  }\n}\n\nprivate typealias Input = Pair<Pair<Int, Int>, Pair<Int, Int>>", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "8f31d39d1a94c862f88278f22430e620b424bd68", "size": 3259, "name": "advent-of-code", "license": "Apache License 2.0"}
{"path": "archive/src/main/kotlin/com/grappenmaker/aoc/year22/Day15.kt", "owner": "770grappenmaker", "repo_id": 434645245, "is_fork": false, "languages_distribution": "{\"Kotlin\": 409647, \"Python\": 647}", "content": "package com.grappenmaker.aoc.year22\n\nimport com.grappenmaker.aoc.*\nimport com.grappenmaker.aoc.Direction.*\n\nfun PuzzleSet.day15() = puzzle {\n    val scanners = inputLines.map { l ->\n        val ints = l.splitInts()\n        Scanner(Point(ints[0], ints[1]), Point(ints[2], ints[3]))\n    }\n\n    fun Point.isValid() = scanners.none { it.loc manhattanDistanceTo this <= it.distance }\n\n    val min = scanners.minOf { it.loc.x - it.distance }\n    val max = scanners.maxOf { it.loc.x + it.distance }\n    partOne = (min..max).count { !Point(it, 2000000).isValid() }.s()\n\n    val range = 0..4000000\n    val directions = listOf(DOWN + LEFT, DOWN + RIGHT, UP + LEFT, UP + RIGHT)\n    val (x, y) = scanners.asSequence().flatMap { scan ->\n        val away = scan.distance + 1\n        (0..away).flatMap { dx ->\n            val dy = away - dx\n            directions.map { (Point(dx, dy) * it) + scan.loc }\n        }.filter { (x, y) -> x in range && y in range }\n    }.first { it.isValid() }\n\n    partTwo = (x.toLong() * 4000000 + y.toLong()).s()\n}\n\ndata class Scanner(val loc: Point, val beacon: Point) {\n    val distance = loc manhattanDistanceTo beacon\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 7, "commit_sha": "92ef1b5ecc3cbe76d2ccd0303a73fddda82ba585", "size": 1139, "name": "advent-of-code", "license": "The Unlicense"}
{"path": "src/Day18.kt", "owner": "akijowski", "repo_id": 574262746, "is_fork": false, "languages_distribution": "{\"Kotlin\": 56887, \"Shell\": 101}", "content": "import kotlin.math.max\nimport kotlin.math.min\n\ndata class Point3D(val x: Int, val y: Int, val z: Int) {\n    operator fun plus(other: Point3D) = Point3D(x + other.x, y + other.y, z + other.z)\n\n    fun within(minPos: Point3D, maxPos: Point3D) =\n        (x in minPos.x..maxPos.x) && (y in minPos.y..maxPos.y) && (z in minPos.z..maxPos.z)\n\n    fun minimum(other: Point3D) = Point3D(min(x, other.x), min(y, other.y), min(z, other.z))\n    fun maximum(other: Point3D) = Point3D(max(x, other.x), max(y, other.y), max(z, other.z))\n}\n\n// flood fill, collecting each point within the boundary\nfun flood(lava: Set<Point3D>, pos: Point3D, minPos: Point3D, maxPos: Point3D): Set<Point3D> {\n    val water = mutableSetOf<Point3D>()\n\n    val q = ArrayDeque<Point3D>().apply { addFirst(pos) }\n    val outsideMin = minPos + Point3D(-1, -1, -1)\n    val outsideMax = maxPos + Point3D(1, 1, 1)\n\n    while (q.isNotEmpty()) {\n        val curr = q.removeFirst()\n\n        if (curr !in water) {\n            water += curr\n            listOf(\n                Point3D(-1, 0, 0),\n                Point3D(1, 0, 0),\n                Point3D(0, -1, 0),\n                Point3D(0, 1, 0),\n                Point3D(0, 0, -1),\n                Point3D(0, 0, 1)\n            ).forEach {\n                val n = curr + it\n                if (n !in lava && n !in water && n.within(outsideMin, outsideMax)) {\n                    q.addFirst(n)\n                }\n            }\n        }\n    }\n    return water\n}\n\nfun main() {\n    fun part1(input: List<String>): Int {\n        val droplets = input.map {\n            val (x, y, z) = it.trim().split(\",\").map { p -> p.toInt() }\n            Point3D(x, y, z)\n        }.toSet()\n        return droplets\n            .flatMap { d ->\n                listOf(\n                    Point3D(-1, 0, 0),\n                    Point3D(1, 0, 0),\n                    Point3D(0, -1, 0),\n                    Point3D(0, 1, 0),\n                    Point3D(0, 0, -1),\n                    Point3D(0, 0, 1)\n                ).map { n ->\n                    n + d\n                }\n            }.count { it !in droplets }\n    }\n\n    fun part2(input: List<String>): Int {\n        val droplets = input.map {\n            val (x, y, z) = it.trim().split(\",\").map { p -> p.toInt() }\n            Point3D(x, y, z)\n        }.toSet()\n\n        val minPos = droplets.fold(\n            Point3D(\n                Int.MAX_VALUE,\n                Int.MAX_VALUE,\n                Int.MAX_VALUE\n            )\n        ) { acc, d -> acc.minimum(d) } + Point3D(-1, -1, -1)\n\n        val maxPos = droplets.fold(\n            Point3D(\n                Int.MIN_VALUE,\n                Int.MIN_VALUE,\n                Int.MIN_VALUE\n            )\n        ) { acc, d -> acc.maximum(d) } + Point3D(1, 1, 1)\n        val water = flood(droplets, minPos, minPos, maxPos)\n\n        // area without \"air\".  Ones that can be filled with water\n        return droplets\n            .flatMap { d ->\n                listOf(\n                    Point3D(-1, 0, 0),\n                    Point3D(1, 0, 0),\n                    Point3D(0, -1, 0),\n                    Point3D(0, 1, 0),\n                    Point3D(0, 0, -1),\n                    Point3D(0, 0, 1)\n                ).map { n -> n + d }\n            }\n            .count { it !in droplets && it in water }\n    }\n\n    // sanity check\n    val example = setOf(Point3D(1, 1, 1), Point3D(2, 1, 1))\n    // neighbors that are not part of the original set\n    println(example.flatMap { e ->\n        listOf(\n            Point3D(-1, 0, 0),\n            Point3D(1, 0, 0),\n            Point3D(0, -1, 0),\n            Point3D(0, 1, 0),\n            Point3D(0, 0, -1),\n            Point3D(0, 0, 1)\n        ).map { n ->\n            n + e\n        }\n    }.count { it !in example })\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day18_test\")\n    check(part1(testInput) == 64)\n    check(part2(testInput) == 58)\n\n    val input = readInput(\"Day18\")\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 1, "stars": 0, "commit_sha": "84d86a4bbaee40de72243c25b57e8eaf1d88e6d1", "size": 4013, "name": "advent-of-code-2022", "license": "Apache License 2.0"}
{"path": "src/day7/puzzle07.kt", "owner": "brendencapps", "repo_id": 572821792, "is_fork": false, "languages_distribution": "{\"Kotlin\": 70597}", "content": "package day7\n\nimport Puzzle\nimport PuzzleInput\nimport java.io.File\n\nclass FileSystemEntry(val name: String, val parent: FileSystemEntry? = null, private var size: Long = 0) {\n    val children = mutableListOf<FileSystemEntry>()\n    val isDir = size == 0.toLong()\n    fun getEntrySize(): Long {\n        if(size == 0.toLong() && children.isNotEmpty()) {\n            size = children.sumOf { child ->\n                child.getEntrySize()\n            }\n        }\n        return size\n    }\n}\n\nclass Day7PuzzleInput(input: String, expectedResult: Long? = null) : PuzzleInput<Long>(expectedResult) {\n    val root: FileSystemEntry = FileSystemEntry(\"/\")\n\n    init {\n        val filePattern = \"(\\\\d+) (.*)\".toRegex()\n        var currentDir = root\n        File(input).readLines().forEach { line ->\n            if(line.startsWith(\"$ cd ..\")) {\n                currentDir = currentDir.parent ?: currentDir\n            }\n            else if(line.startsWith(\"$ cd \")) {\n                val dir = line.substring(\"$ cd \".length)\n                currentDir = currentDir.children.find { it.name == dir } ?: currentDir\n            }\n            else if(line.startsWith(\"dir \")) {\n                currentDir.children.add(FileSystemEntry(line.substring(\"dir \".length), currentDir))\n            }\n            else if(filePattern.matches(line)) {\n                val (size, name) = filePattern.find(line)!!.destructured\n                currentDir.children.add(FileSystemEntry(name, currentDir, size.toLong()))\n            }\n        }\n        root.getEntrySize()\n    }\n}\n\nclass Day7PuzzleInputList(input: String, expectedResult: Long? = null) : PuzzleInput<Long>(expectedResult) {\n    val root = FileSystemEntry(\"/\")\n    val dirQueue = mutableListOf<FileSystemEntry>()\n\n    init {\n        val filePattern = \"(\\\\d+) (.*)\".toRegex()\n        var currentDir = root\n        File(input).readLines().forEach { line ->\n            if(line.startsWith(\"$ cd ..\")) {\n                currentDir = currentDir.parent ?: currentDir\n            }\n            else if(line.startsWith(\"$ cd \")) {\n                val dir = line.substring(\"$ cd \".length)\n                currentDir = currentDir.children.find { it.name == dir } ?: currentDir\n            }\n            else if(line.startsWith(\"dir \")) {\n                val dir = FileSystemEntry(line.substring(\"dir \".length), currentDir)\n                currentDir.children.add(dir)\n                dirQueue.add(dir)\n            }\n            else if(filePattern.matches(line)) {\n                val (size, name) = filePattern.find(line)!!.destructured\n                currentDir.children.add(FileSystemEntry(name, currentDir, size.toLong()))\n            }\n        }\n        root.getEntrySize()\n    }\n}\n\nclass Day7PuzzleSolution(private val targetDirSize: Long) : Puzzle<Long, Day7PuzzleInput>() {\n    override fun solution(input: Day7PuzzleInput): Long {\n        return getTotalSizeSmallDirectories(targetDirSize, input.root)\n    }\n\n    private fun getTotalSizeSmallDirectories(size: Long, entry: FileSystemEntry): Long {\n        val sizeOfSmallChildren = entry.children.sumOf { child ->\n            getTotalSizeSmallDirectories(size, child)\n        }\n        if(entry.isDir && entry.getEntrySize() <= size) {\n            return sizeOfSmallChildren + entry.getEntrySize()\n        }\n        return sizeOfSmallChildren\n    }\n}\n\nclass Day7PuzzleSolutionList(private val targetDirSize: Long) : Puzzle<Long, Day7PuzzleInputList>() {\n    override fun solution(input: Day7PuzzleInputList): Long {\n        return input.dirQueue.sumOf {dir ->\n            if(dir.getEntrySize() <= targetDirSize) {\n                dir.getEntrySize()\n            }\n            else {\n                0\n            }\n        }\n    }\n\n}\n\nclass Day7Puzzle2Solution : Puzzle<Long, Day7PuzzleInput>() {\n    override fun solution(input: Day7PuzzleInput): Long {\n        val targetDirSize = 30000000 - (70000000 - input.root.getEntrySize())\n        val result = findDirectoryToDelete(targetDirSize, input.root)\n        return result?.getEntrySize() ?: error(\"Did not find a directory\")\n    }\n\n    private fun findDirectoryToDelete(size: Long, entry: FileSystemEntry): FileSystemEntry? {\n        if(!entry.isDir || entry.getEntrySize() < size) return null\n\n        var potentialDir: FileSystemEntry? = null\n        for(child in entry.children) {\n            val potentialChildDir = findDirectoryToDelete(size, child)\n            if(potentialChildDir != null) {\n                if(potentialDir == null || potentialDir.getEntrySize() > potentialChildDir.getEntrySize()) {\n                    potentialDir = potentialChildDir\n                }\n            }\n        }\n        if(potentialDir != null) {\n            return potentialDir\n        }\n        return entry\n    }\n}\n\nclass Day7Puzzle2SolutionList : Puzzle<Long, Day7PuzzleInputList>() {\n    override fun solution(input: Day7PuzzleInputList): Long {\n        val targetDirSize = 30000000 - (70000000 - input.root.getEntrySize())\n        var currentBest = input.root\n        for (dir in input.dirQueue) {\n            if (dir.getEntrySize() < currentBest.getEntrySize() && dir.getEntrySize() > targetDirSize) {\n                currentBest = dir\n            }\n        }\n        return currentBest.getEntrySize()\n    }\n}\n\nfun day7Puzzle() {\n    Day7PuzzleSolution(100000).solve(Day7PuzzleInput(\"inputs/day7/exampleCommands.txt\", 95437))\n    Day7PuzzleSolution(100000).solve(Day7PuzzleInput(\"inputs/day7/inputCommands.txt\",1428881))\n    Day7PuzzleSolutionList(100000).solve(Day7PuzzleInputList(\"inputs/day7/exampleCommands.txt\", 95437))\n    Day7PuzzleSolutionList(100000).solve(Day7PuzzleInputList(\"inputs/day7/inputCommands.txt\",1428881))\n    Day7Puzzle2Solution().solve(Day7PuzzleInput(\"inputs/day7/exampleCommands.txt\", 24933642))\n    Day7Puzzle2Solution().solve(Day7PuzzleInput(\"inputs/day7/inputCommands.txt\", 10475598))\n    Day7Puzzle2SolutionList().solve(Day7PuzzleInputList(\"inputs/day7/exampleCommands.txt\", 24933642))\n    Day7Puzzle2SolutionList().solve(Day7PuzzleInputList(\"inputs/day7/inputCommands.txt\", 10475598))\n}\n\n\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "00e9bd960f8bcf6d4ca1c87cb6e8807707fa28f3", "size": 6207, "name": "aoc_2022", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/days/day7/Day7.kt", "owner": "Stenz123", "repo_id": 694797878, "is_fork": false, "languages_distribution": "{\"Kotlin\": 27460}", "content": "package days.day7\n\nimport days.Day\n\nclass Day7:Day() {\n    override fun partOne(): Any {\n        return getValidBagCunt(\"shiny gold\", readInput()).count()\n    }\n\n    fun getValidBagCunt(bag: String, input: List<String>): Set<String> {\n        val validBags = input.filter{it.substringAfter(\" \").contains(bag)}\n        if (validBags.isEmpty()) {\n            return setOf()\n        }\n        val result = validBags.map{it.substringBefore(\" bags\")}.toSet().toMutableSet()\n        for (validBag in validBags) {\n            result += getValidBagCunt(validBag.substringBefore(\" bags\"), input)\n        }\n        return result\n    }\n\n    fun countBagsInGOldBag(bag: String , input: List<String>): Int{\n        val validBags = input.filter{it.substringBefore(\" contain\").contains(bag)}\n        val containedBags = validBags.map { it.substringAfter(\"contain \").split(\", \").map{it.replace(\".\",\"\")} }.flatten()\n\n        var result = 1\n        for (containedBag in containedBags) {\n            val numberOfBags = containedBag.substringBefore(\" \").toIntOrNull() ?: return 1\n            result += numberOfBags * countBagsInGOldBag(containedBag.substringAfter(\" \"), input)\n        }\n        return result\n    }\n\n    override fun partTwo(): Any {\n        return countBagsInGOldBag(\"shiny gold\", readInput())-1\n    }\n\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "3e5ee86cd723c293ec44b1be314697ccf5cdaab7", "size": 1301, "name": "advent-of-code-2020", "license": "The Unlicense"}
{"path": "src/main/kotlin/dev/bogwalk/batch6/Problem68.kt", "owner": "bog-walk", "repo_id": 381459475, "is_fork": false, "languages_distribution": null, "content": "package dev.bogwalk.batch6\n\nimport dev.bogwalk.util.combinatorics.permutations\n\n/**\n * Problem 68: Magic 5-Gon Ring\n *\n * https://projecteuler.net/problem=68\n *\n * Goal: Given N, representing a magic N-gon ring, and S, representing the total to which each\n * ring's line sums, return all concatenated strings (in lexicographic order) representing the N\n * sets of solutions.\n *\n * Constraints: 3 <= N <= 10\n *\n * Magic 3-Gon Ring (as seen in above link): The ring has 3 external nodes, each ending a line of\n * 3 nodes (6 nodes total representing digits 1 to 6). The ring can be completed so the lines\n * reach 4 different totals, [9, 12], so there are 8 solutions in total:\n *      9 -> [{4,2,3}, {5,3,1}, {6,1,2}], [{4,3,2}, {6,2,1}, {5,1,3}]\n *      10 -> [{2,3,5}, {4,5,1}, {6,1,3}], [{2,5,3}, {6,3,1}, {4,1,5}]\n *      11 -> [{1,4,6}, {3,6,2}, {5,2,4}], [{1,6,4}, {5,4,2}, {3,2,6}]\n *      12 -> [{1,5,6}, {2,6,4}, {3,4,5}], [{1,6,5}, {3,5,4}, {2,4,6}]\n *      So the maximum concatenated string for a magic 3-gon is \"432621513\".\n *\n * e.g.: N = 3, S = 9\n *       solutions = [\"423531612\", \"432621513\"]\n */\n\nclass Magic5GonRing {\n    /**\n     * Project Euler specific implementation that requests the maximum 16-digit string solution\n     * from all solutions for a magic 5-gon ring that uses numbers 1 to 10 in its nodes.\n     *\n     * For the solution to have 16 digits, the number 10 has to be an external node, as, if it\n     * were placed on the internal ring, it would be used by 2 unique lines & would create a\n     * 17-digit concatenation. So, at minimum, the line with 10 as an external node will sum to 13.\n     *\n     * To create the largest lexicographic concatenation, larger numbers ideally should be placed\n     * first. Based on the magic 3-gon ring example detailed in the problem description, if the\n     * largest numbers are external nodes and the smallest numbers are ring nodes, the maximum\n     * solution occurs at the lowest total achieved by the following:\n     *\n     *      (externalNodes.sum() + 2 * internalNodes.sum()) / N\n     *\n     *      e.g. ([4, 5, 6].sum() + 2 * [1, 2, 3].sum()) / 3 = 9\n     *\n     * The maximum solution indeed occurs when S = 14 with the largest numbers on the external\n     * nodes, but all totals up to 27 were explored given the speed of the recursive solution below.\n     *\n     * N.B. Solutions exist for the following totals: [14, 16, 17, 19].\n     */\n    fun maxMagic5GonSolution(): String {\n        val solutions = mutableListOf<List<String>>()\n        for (s in 13..27) {\n            val solution = magicRingSolutionsOptimised(5, s)\n            if (solution.isNotEmpty()) {\n                solutions.add(solution)\n            }\n        }\n        return solutions.flatten().filter { it.length == 16 }.sortedDescending()[0]\n    }\n\n    /**\n     * Solution uses recursion to search through all permutations ([n] * 2 digits choose 3) from an\n     * increasingly smaller set of remaining digits. Permutations are checked to see if they sum\n     * to [s] & if their middle digit matches the last digit of the permutation found previously.\n     *\n     * A stack of the remaining digits to use is cached so the search can continue if a solution\n     * that cannot close the ring is reached. This is done by adding the elements of the last\n     * permutation back to the stack if the solution becomes invalid.\n     *\n     * Rather than searching for a final permutation that completes the ring, the expected list is\n     * generated based on the remaining digits possible & checked to see if it complements the\n     * starter list & adds up to [s].\n     *\n     * SPEED (WORST) 1.57s for N = 7, S = 23\n     */\n    fun magicRingSolutions(n: Int, s: Int): List<String> {\n        val solutions = mutableListOf<String>()\n        val allDigits = (1..n * 2).toMutableSet()\n\n        fun nextRingLine(solution: MutableList<List<Int>>) {\n            if (allDigits.size == 2) {\n                val expected = listOf(\n                    (allDigits - setOf(solution.last()[2])).first(),\n                    solution.last()[2],\n                    solution[0][1]\n                )\n                if (expected[0] > solution[0][0] && expected.sum() == s) {\n                    solutions.add(\n                        solution.flatten().joinToString(\"\") +\n                                expected.joinToString(\"\")\n                    )\n                }\n            } else {\n                for (perm in permutations(allDigits, 3)) {\n                    if (\n                        perm[1] != solution.last()[2] ||\n                        perm[0] < solution[0][0] ||\n                        perm.sum() != s\n                    ) continue\n                    solution.add(perm)\n                    allDigits.removeAll(perm.toSet() - setOf(perm[2]))\n                    nextRingLine(solution)\n                }\n            }\n            allDigits.addAll(solution.removeLast())\n        }\n\n        // starter must have the lowest external node, which limits the digits it can have\n        val starterMax = n * 2 - n + 1\n        for (starter in permutations(allDigits, 3)) {\n            if (starter[0] > starterMax || starter.sum() != s) continue\n            allDigits.removeAll(starter.toSet() - setOf(starter[2]))\n            nextRingLine(mutableListOf(starter))\n            allDigits.clear()\n            allDigits.addAll((1..n * 2).toMutableSet())\n        }\n        return solutions.sorted()\n    }\n\n    /**\n     * While still using recursion, the solution is optimised by not generating all permutations\n     * of 3-digit lines. Instead, nodes on the internal ring alone are recursively generated from\n     * an increasingly smaller set of available digits and the corresponding external node for\n     * every pair of ring nodes is calculated.\n     *\n     * SPEED (BETTER) 66.16ms for N = 7, S = 23\n     */\n    fun magicRingSolutionsImproved(n: Int, s: Int): List<String> {\n        val solutions = mutableListOf<String>()\n        val allDigits = (1..n * 2)\n        val remainingDigits = allDigits.toMutableSet()\n        val ringNodes = IntArray(n)\n        val externalNodes = IntArray(n)\n\n        fun nextRingNode(i: Int) {\n            if (i == n - 1) {\n                externalNodes[i] = s - ringNodes[i] - ringNodes[0]\n                if (\n                    externalNodes[i] in remainingDigits &&\n                    // first external node must be smallest of all external nodes\n                    externalNodes[0] == externalNodes.minOrNull()\n                ) {\n                    var solution = \"\"\n                    for (j in 0 until n) {\n                        solution += \"${externalNodes[j]}${ringNodes[j]}${ringNodes[(j+1)%n]}\"\n                    }\n                    solutions.add(solution)\n                }\n            } else {\n                for (digit in allDigits) {\n                    if (digit !in remainingDigits) continue\n                    val nextExternal = s - ringNodes[i] - digit\n                    if (nextExternal == digit || nextExternal !in remainingDigits) continue\n                    ringNodes[i+1] = digit\n                    externalNodes[i] = nextExternal\n                    val justUsed = setOf(digit, nextExternal)\n                    remainingDigits.removeAll(justUsed)\n                    nextRingNode(i + 1)\n                    // solution found or not; either way backtrack to try a different ring node\n                    remainingDigits.addAll(justUsed)\n                }\n            }\n        }\n\n        for (digit in allDigits) {\n            ringNodes[0] = digit\n            remainingDigits.remove(digit)\n            nextRingNode(0)\n            // solutions found or not; either way backtrack to start ring with a novel node\n            remainingDigits.clear()\n            remainingDigits.addAll(allDigits.toMutableSet())\n        }\n        return solutions.sorted()\n    }\n\n    /**\n     * This solution is identical to the above improved solution but cuts speed in half by taking\n     * advantage of the pattern that all solutions present in pairs.\n     *\n     * e.g. when N = 4, S = 12, the 1st solution will be found when the starter digit = 2, with\n     *\n     *      ringNodes = [2, 6, 1 ,3] and externalNodes = [4, 5, 8, 7] -> \"426561813732\"\n     *\n     * If the 1st 2 elements of ringNodes are swapped & the rest reversed, and all elements of\n     * externalNodes, except the static lowest external, are also reversed, the arrays become:\n     *\n     *      ringNodes = [6, 2, 3, 1] and externalNodes = [4, 7, 8, 5] -> \"462723831516\"\n     *\n     * This latter solution would have been eventually found when the starter digit = 6.\n     *\n     * Instead, any duplicate searches are eliminated by reversing all solutions when found & not\n     * allowing starter digits to explore adjacent ring digits that are smaller (as these would\n     * already have been found by previous iterations). So the starter digit 6 would only end up\n     * searching through ringNodes = [6, [7, 12], X, X]\n     *\n     * Lastly, neither digit 1 nor digit n need to be assessed as they will be found in later or\n     * earlier iterations.\n     *\n     * SPEED (BEST) 36.84ms for N = 7, S = 23\n     */\n    fun magicRingSolutionsOptimised(n: Int, s: Int): List<String> {\n        val solutions = mutableListOf<String>()\n        val allDigits = (1..n * 2)\n        val remainingDigits = allDigits.toMutableSet()\n        val ringNodes = IntArray(n)\n        val externalNodes = IntArray(n)\n\n        fun nextRingNode(i: Int) {\n            if (i == n - 1) {\n                externalNodes[i] = s - ringNodes[i] - ringNodes[0]\n                if (\n                    externalNodes[i] in remainingDigits &&\n                    externalNodes[0] == externalNodes.minOrNull()\n                ) {\n                    var solution1 = \"\"\n                    var solution2 = \"\"\n                    for (j in 0 until n) {\n                        solution1 += \"${externalNodes[j]}${ringNodes[j]}${ringNodes[(j+1)%n]}\"\n                        solution2 += \"${externalNodes[(n-j)%n]}${ringNodes[(n-j+1)%n]}${ringNodes[(n-j)%n]}\"\n                    }\n                    solutions.add(solution1)\n                    solutions.add(solution2)\n                }\n            } else {\n                val searchRange = if (i == 0) (ringNodes[0] + 1)..(n * 2) else allDigits\n                for (digit in searchRange) {\n                    if (digit !in remainingDigits) continue\n                    val nextExternal = s - ringNodes[i] - digit\n                    if (nextExternal == digit || nextExternal !in remainingDigits) continue\n                    ringNodes[i+1] = digit\n                    externalNodes[i] = nextExternal\n                    val justUsed = setOf(digit, nextExternal)\n                    remainingDigits.removeAll(justUsed)\n                    nextRingNode(i + 1)\n                    remainingDigits.addAll(justUsed)\n                }\n            }\n        }\n\n        for (digit in 2 until n * 2) {\n            ringNodes[0] = digit\n            remainingDigits.remove(digit)\n            nextRingNode(0)\n            remainingDigits.clear()\n            remainingDigits.addAll(allDigits.toMutableSet())\n        }\n        return solutions.sorted()\n    }\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "62b33367e3d1e15f7ea872d151c3512f8c606ce7", "size": 11230, "name": "project-euler-kotlin", "license": "MIT License"}
{"path": "src/Day11.kt", "owner": "xabgesagtx", "repo_id": 572139500, "is_fork": false, "languages_distribution": "{\"Kotlin\": 23192}", "content": "import Operator.PLUS\nimport Operator.TIMES\n\nfun main() {\n\n    val day = \"Day11\"\n\n    fun readMonkeys(input: List<String>): Map<Int, Monkey> {\n        return input.filter { it.isNotBlank() }\n            .chunked(6)\n            .mapIndexed { index, lines ->  lines.toMonkey(index) }\n            .associateBy { it.number }\n    }\n\n    fun Map<Int,Monkey>.simulateRound(worryLevelDivider: Long) {\n        for(i in 0 until size) {\n            val monkey = getValue(i)\n            while (monkey.items.isNotEmpty()) {\n                monkey.inspectedItems++\n                var item = monkey.items.removeFirst()\n                item = monkey.operation.perform(item)\n                item /= worryLevelDivider\n                if (item % monkey.testDivider == 0L) {\n                    getValue(monkey.firstTarget).items.add(item)\n                } else {\n                    getValue(monkey.secondTarget).items.add(item)\n                }\n            }\n        }\n    }\n\n    fun part1(input: List<String>): Long {\n        val monkeys = readMonkeys(input)\n        repeat(20) {\n            monkeys.simulateRound(3L)\n        }\n        val (firstHighest, secondHighest) =  monkeys.values.map { it.inspectedItems }.sortedDescending().take(2)\n        return firstHighest * secondHighest\n    }\n\n    fun part2(input: List<String>): Long {\n        val monkeys = readMonkeys(input)\n        repeat(10000) {\n            monkeys.simulateRound(1L)\n        }\n        val (firstHighest, secondHighest) =  monkeys.values.map { it.inspectedItems }.sortedDescending().take(2)\n        return firstHighest * secondHighest\n    }\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"${day}_test\")\n    readMonkeys(testInput).values.forEach { println(it) }\n    println(\"Test part 1:\")\n    println(part1(testInput))\n    check(part1(testInput) == 10605L)\n    println()\n    println(\"Test part 2:\")\n    println(part2(testInput))\n    check(part2(testInput) == 2713310158L)\n\n    val input = readInput(day)\n    println()\n    println(\"Part 1\")\n    println(part1(input))\n    println()\n    println(\"Part 2\")\n    println(part2(input))\n}\n\nprivate fun List<String>.toMonkey(index: Int): Monkey {\n    val (startingItemsLine, operationLine, testLine, trueCaseLine, falseCaseLine) = this.drop(1)\n    val startingItems =\n        startingItemsLine.substringAfter(\"Starting items:\").split(\",\").mapNotNull { it.trim().toLongOrNull() }\n    val (operatorString, operandString) = operationLine.substringAfter(\"Operation: new = old \").split(\" \")\n    val operator = when (operatorString) {\n        \"*\" -> TIMES\n        \"+\" -> PLUS\n        else -> error(\"Unexpected operator: $operatorString\")\n    }\n    val fixedOperand = operandString.toLongOrNull()\n    val operation = Operation(operator, fixedOperand)\n    val testDivider = testLine.substringAfter(\"Test: divisible by \").toLong()\n    val firstTarget = trueCaseLine.substringAfter(\"If true: throw to monkey \").toInt()\n    val secondTarget = falseCaseLine.substringAfter(\"If false: throw to monkey \").toInt()\n\n    return Monkey(index, ArrayDeque(startingItems), operation, testDivider, firstTarget, secondTarget)\n}\n\nprivate enum class Operator {\n    PLUS, TIMES\n}\n\nprivate data class Operation(val operator: Operator, val fixedOperand: Long?) {\n    fun perform(oldValue: Long): Long {\n        val operand = fixedOperand ?: oldValue\n        return when (operator) {\n            PLUS -> oldValue + operand\n            TIMES -> oldValue * operand\n        }\n    }\n}\n\nprivate data class Monkey(\n    val number: Int,\n    val items: ArrayDeque<Long>,\n    val operation: Operation,\n    val testDivider: Long,\n    val firstTarget: Int,\n    val secondTarget: Int,\n    var inspectedItems: Long = 0\n)\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "976d56bd723a7fc712074066949e03a770219b10", "size": 3730, "name": "advent-of-code-2022", "license": "Apache License 2.0"}
{"path": "src/leetcodeProblem/leetcode/editor/en/RussianDollEnvelopes.kt", "owner": "faniabdullah", "repo_id": 382893751, "is_fork": false, "languages_distribution": null, "content": "//You are given a 2D array of integers envelopes where envelopesintArrayOf(i) = intArrayOf(wi, hi)\n//represents the width and the height of an envelope. \n//\n// One envelope can fit into another if and only if both the width and height \n//of one envelope are greater than the other envelope's width and height. \n//\n// Return the maximum number of envelopes you can Russian doll (i.e., put one \n//inside the other). \n//\n// Note: You cannot rotate an envelope. \n//\n// \n// Example 1: \n//\n// \n//Input: envelopes = intArrayOf(intArrayOf(5,4),intArrayOf(6,4),intArrayOf(6,7),intArrayOf(2,3))\n//Output: 3\n//Explanation: The maximum number of envelopes you can Russian doll is 3 (intArrayOf(2,3) \n//=> intArrayOf(5,4) => intArrayOf(6,7)).\n// \n//\n// Example 2: \n//\n// \n//Input: envelopes = intArrayOf(intArrayOf(1,1),intArrayOf(1,1),intArrayOf(1,1))\n//Output: 1\n// \n//\n// \n// Constraints: \n//\n// \n// 1 <= envelopes.length <= 5000 \n// envelopesintArrayOf(i).length == 2 \n// 1 <= wi, hi <= 10⁴ \n// \n// Related Topics Array Binary Search Dynamic Programming Sorting 👍 2606 👎 66\n\n\npackage leetcodeProblem.leetcode.editor.en\n\nimport java.util.*\n\n\nclass RussianDollEnvelopes {\n    fun solution() {\n    }\n\n    //below code will be used for submission to leetcode (using plugin of course)\n    //leetcode submit region begin(Prohibit modification and deletion)\n    class Solution {\n        fun maxEnvelopes(envelopes: Array<IntArray>): Int {\n            var maxEnvelopes = 1\n            val dp = IntArray(envelopes.size) { 1 }\n            Arrays.sort(\n                envelopes\n            ) { arr1, arr2 -> if (arr1[0] == arr2[0]) arr2[1] - arr1[1] else arr1[0] - arr2[0] }\n\n            for (i in 1 until envelopes.size) {\n                for (j in 0..i) {\n                    if (envelopes[j][0] > envelopes[i][0] && envelopes[j][1] > envelopes[i][1]\n                        && dp[j] + 1 > dp[i]\n                    ) {\n                        dp[i] = dp[j] + 1\n                    } else if (envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1] && dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1\n                    }\n                }\n                maxEnvelopes = maxOf(maxEnvelopes, dp[i])\n            }\n            return maxEnvelopes\n        }\n    }\n//leetcode submit region end(Prohibit modification and deletion)\n\n}\n\nfun main() {\n    RussianDollEnvelopes.Solution().maxEnvelopes(\n        arrayOf(\n            intArrayOf(1, 15),\n            intArrayOf(7, 18),\n            intArrayOf(7, 6),\n            intArrayOf(7, 100),\n            // 3 , 5 ?\n\n            intArrayOf(2, 200), //\n            intArrayOf(17, 30), // 4\n            intArrayOf(17, 45), // 5\n            intArrayOf(3, 5),\n            intArrayOf(7, 8),\n            intArrayOf(3, 6),\n            intArrayOf(3, 10),\n            intArrayOf(7, 20),\n            intArrayOf(17, 3),\n            intArrayOf(17, 45)\n        )\n    )\n}\n  \n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 6, "commit_sha": "ecf14fe132824e944818fda1123f1c7796c30532", "size": 2923, "name": "dsa-kotlin", "license": "MIT License"}
{"path": "src/day9/Code.kt", "owner": "fcolasuonno", "repo_id": 162470286, "is_fork": false, "languages_distribution": null, "content": "package day9\n\nimport MultiMap\nimport permutations\nimport java.io.File\n\nfun main(args: Array<String>) {\n    val name = if (false) \"test.txt\" else \"input.txt\"\n    val dir = ::main::class.java.`package`.name\n    val input = File(\"src/$dir/$name\").readLines()\n    val parsed = parse(input)\n    println(\"Part 1 = ${part1(parsed)}\")\n    println(\"Part 2 = ${part2(parsed)}\")\n}\n\ndata class Distance(val city1: String, val city2: String, val dist: Int)\n\nprivate val lineStructure = \"\"\"(\\w+) to (\\w+) = (\\d+)\"\"\".toRegex()\n\nfun parse(input: List<String>) = input.map {\n    lineStructure.matchEntire(it)?.destructured?.let {\n        val (city1, city2, dist) = it.toList()\n        Distance(city1, city2, dist.toInt())\n    }\n}.requireNoNulls().let { distances ->\n    MultiMap<String, String, Int>().apply {\n        distances.forEach {\n            this[it.city1][it.city2] = it.dist\n            this[it.city2][it.city1] = it.dist\n        }\n    }\n}\n\nfun part1(input: MultiMap<String, String, Int>): Any? = input.keys.permutations.map {\n    it.windowed(size = 2).sumBy { (from, to) -> input[from][to] }\n}.min()\n\nfun part2(input: MultiMap<String, String, Int>): Any? = input.keys.permutations.map {\n    it.windowed(size = 2).sumBy { (from, to) -> input[from][to] }\n}.max()\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "24f54bf7be4b5d2a91a82a6998f633f353b2afb6", "size": 1255, "name": "AOC2015", "license": "MIT License"}
{"path": "src/Lesson3TimeComplexity/TapeEquilibrium.kt", "owner": "slobodanantonijevic", "repo_id": 557942075, "is_fork": false, "languages_distribution": "{\"Kotlin\": 50634}", "content": "/**\n * 100/100\n * @param A\n * @return\n */\nfun solution(A: IntArray): Int {\n    var left = 0\n    var right = A.sum()\n    var min = 0\n    for (i in 1 until A.size) {\n        left += A[i - 1]\n        right -= A[i - 1]\n        val diff: Int = Math.abs(left - right)\n        min = getMin(i, diff, min)\n    }\n    return min\n}\n\nprivate fun getMin(i: Int, diff: Int, min: Int): Int {\n    return if (i == 1 || diff < min) {\n        diff\n    } else min\n}\n\n/**\n * A non-empty array A consisting of N integers is given. Array A represents numbers on a tape.\n *\n * Any integer P, such that 0 < P < N, splits this tape into two non-empty parts: A[0], A[1], ..., A[P − 1] and A[P], A[P + 1], ..., A[N − 1].\n *\n * The difference between the two parts is the value of: |(A[0] + A[1] + ... + A[P − 1]) − (A[P] + A[P + 1] + ... + A[N − 1])|\n *\n * In other words, it is the absolute difference between the sum of the first part and the sum of the second part.\n *\n * For example, consider array A such that:\n *\n *   A[0] = 3\n *   A[1] = 1\n *   A[2] = 2\n *   A[3] = 4\n *   A[4] = 3\n * We can split this tape in four places:\n *\n * P = 1, difference = |3 − 10| = 7\n * P = 2, difference = |4 − 9| = 5\n * P = 3, difference = |6 − 7| = 1\n * P = 4, difference = |10 − 3| = 7\n * Write a function:\n *\n * class Solution { public int solution(int[] A); }\n *\n * that, given a non-empty array A of N integers, returns the minimal difference that can be achieved.\n *\n * For example, given:\n *\n *   A[0] = 3\n *   A[1] = 1\n *   A[2] = 2\n *   A[3] = 4\n *   A[4] = 3\n * the function should return 1, as explained above.\n *\n * Write an efficient algorithm for the following assumptions:\n *\n * N is an integer within the range [2..100,000];\n * each element of array A is an integer within the range [−1,000..1,000].\n */", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "155cf983b1f06550e99c8e13c5e6015a7e7ffb0f", "size": 1798, "name": "Codility-Kotlin", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/com/jacobhyphenated/advent2023/day8/Day8.kt", "owner": "jacobhyphenated", "repo_id": 725928124, "is_fork": false, "languages_distribution": "{\"Kotlin\": 121644}", "content": "package com.jacobhyphenated.advent2023.day8\n\nimport com.jacobhyphenated.advent2023.Day\n\ntypealias Direction = Map<String, Pair<String,String>>\n\n/**\n * Day 8: <NAME>\n *\n * The puzzle input consists of two parts. The first part is a set of instructions indicating which\n * direction to take (R = right, L = left). Those instructions repeat forever.\n * The second part maps a starting position to two possible ending positions (a left and a right)\n */\nclass Day8: Day<Pair<String, Direction>> {\n  override fun getInput(): Pair<String, Direction> {\n    return parseInput(readInputFile(\"8\"))\n  }\n\n  /**\n   * Part1: The starting position is AAA and the ending position is ZZZ\n   * Following the instructions, how many steps does it take to get to the end?\n   */\n  override fun part1(input: Pair<String, Direction>): Int {\n    val (instructionString, directions) = input\n    val instructionGenerator = InfiniteGenerator(instructionString.toCharArray().toList())\n    var current = \"AAA\"\n    while (current != \"ZZZ\") {\n      current = nextPosition(instructionGenerator, current, directions)\n    }\n    return instructionGenerator.num\n  }\n\n  /**\n   * Part 2: There are multiple starting points (every position that ends with A)\n   * and multiple ending points (every position that ends with Z)\n   *\n   * Starting at all possible starting locations at the same time, how many steps until\n   * each position has reached and end point at the same time?\n   */\n  override fun part2(input: Pair<String, Direction>): Long {\n    val (instructionString, directions) = input\n    val currentPositions = directions.keys.filter { it.endsWith(\"A\") }.toMutableList()\n\n    // find how long it takes to reach the end from each starting position\n    val endIndexes = currentPositions.map { start ->\n      var current = start\n      val instructionGenerator = InfiniteGenerator(instructionString.toCharArray().toList())\n      while (!current.endsWith(\"Z\")){\n        current = nextPosition(instructionGenerator, current, directions)\n      }\n      instructionGenerator.num.toLong()\n    }\n\n    // Note: This only works because for this puzzle, the repeating pattern of the instructions\n    // starts at the same time for each starting location. That does not necessarily have to be true\n    return lcm(endIndexes)\n  }\n\n  fun parseInput(input: String): Pair<String, Direction> {\n    val (instructions, directionList) = input.split(\"\\n\\n\")\n    val directionMap = directionList.lines().map { line ->\n      val (key, lrPair) = line.split(\" = \")\n      val (left, right) = lrPair.removeSuffix(\")\").removePrefix(\"(\").split(\", \")\n      Pair(key, Pair(left, right))\n    }.associate { (key, pair) -> key to pair }.toMap()\n    return Pair(instructions, directionMap)\n  }\n\n  private fun nextPosition(generator: InfiniteGenerator<Char>, current: String, directions: Direction): String {\n    return when(val instruction = generator.next()) {\n      'L' -> directions.getValue(current).first\n      'R' -> directions.getValue(current).second\n      else -> throw IllegalArgumentException(\"Invalid instruction $instruction\")\n    }\n  }\n\n  override fun warmup(input: Pair<String, Direction>) {\n    part1(input)\n  }\n}\n\nclass InfiniteGenerator<T>(private val order: List<T>) {\n  var num = 0\n  fun next(): T {\n    return order[num % order.size].also { num++ }\n  }\n}\n\nfun main(@Suppress(\"UNUSED_PARAMETER\") args: Array<String>) {\n  Day8().run()\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "90d8a95bf35cae5a88e8daf2cfc062a104fe08c1", "size": 3398, "name": "advent2023", "license": "The Unlicense"}
{"path": "src/Day08.kt", "owner": "fedochet", "repo_id": 573033793, "is_fork": false, "languages_distribution": "{\"Kotlin\": 77129}", "content": "fun main() {\n    data class Pos(val row: Int, val column: Int) {\n        fun moveLeft() = Pos(row, column - 1)\n        fun moveRight() = Pos(row, column + 1)\n        fun moveUp() = Pos(row - 1, column)\n        fun moveDown() = Pos(row + 1, column)\n    }\n\n    class Forest(private val trees: List<String>) {\n        val rows: Int = trees.size\n        val columns: Int = trees.first().length\n\n        operator fun get(pos: Pos): Int {\n            return trees[pos.row][pos.column].digitToInt()\n        }\n\n        operator fun contains(pos: Pos): Boolean {\n            return pos.column in 0 until columns && pos.row in 0 until rows\n        }\n    }\n\n    fun goIntoForest(forest: Forest, from: Pos, action: (Pos) -> Pos): Sequence<Pos> =\n        generateSequence(from, action).drop(1).takeWhile { it in forest }\n\n    fun seenFromDirection(forest: Forest, direction: Sequence<Pos>, pos: Pos) =\n        direction.all { forest[it] < forest[pos] }\n\n    fun checkVisibility(forest: Forest, pos: Pos): Boolean {\n        val leftRange = goIntoForest(forest, pos, Pos::moveLeft)\n        val rightRange = goIntoForest(forest, pos, Pos::moveRight)\n\n        val upRange = goIntoForest(forest, pos, Pos::moveUp)\n        val downRange = goIntoForest(forest, pos, Pos::moveDown)\n\n        return listOf(leftRange, rightRange, upRange, downRange)\n            .any { direction -> seenFromDirection(forest, direction, pos) }\n    }\n\n    fun positionsFor(forest: Forest): Sequence<Pos> = sequence {\n        for (row in 0 until forest.rows) {\n            for (column in 0 until forest.columns) {\n                yield(Pos(row, column))\n            }\n        }\n    }\n\n    fun part1(input: List<String>): Int {\n        val forest = Forest(input)\n\n        return positionsFor(forest).count { checkVisibility(forest, it) }\n    }\n\n    fun countVisibleTrees(forest: Forest, direction: Sequence<Pos>, viewPos: Pos): Int {\n        var count = 0\n        \n        for (pos in direction) {\n            count += 1\n\n            if (forest[pos] >= forest[viewPos]) break\n        }\n\n        return count\n    }\n\n    fun ratePosition(forest: Forest, pos: Pos): Int {\n        val leftRange = goIntoForest(forest, pos, Pos::moveLeft)\n        val rightRange = goIntoForest(forest, pos, Pos::moveRight)\n\n        val upRange = goIntoForest(forest, pos, Pos::moveUp)\n        val downRange = goIntoForest(forest, pos, Pos::moveDown)\n\n        val numberOfTreesFromSides = listOf(leftRange, rightRange, upRange, downRange)\n            .map { direction -> countVisibleTrees(forest, direction, pos) }\n        \n        return numberOfTreesFromSides.fold(1, Int::times)\n    }\n\n    fun part2(input: List<String>): Int {\n        val forest = Forest(input)\n\n        return positionsFor(forest).maxOf { ratePosition(forest, it) }\n    }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day08_test\")\n    check(part1(testInput) == 21)\n    check(part2(testInput) == 8)\n\n    val input = readInput(\"Day08\")\n    println(part1(input))\n    println(part2(input))\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "975362ac7b1f1522818fc87cf2505aedc087738d", "size": 3051, "name": "aoc2022", "license": "Apache License 2.0"}
{"path": "leetcode2/src/leetcode/TwoSumIITnputArrayIsSorted.kt", "owner": "hewking", "repo_id": 68515222, "is_fork": false, "languages_distribution": null, "content": "package leetcode\n\n/**\n * https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\n * 167. 两数之和 II - 输入有序数组\n * Created by test\n * Date 2019/6/16 10:31\n * Description\n * 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。\n\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。\n\n说明:\n\n返回的下标值（index1 和 index2）不是从零开始的。\n你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n示例:\n\n输入: numbers = [2, 7, 11, 15], target = 9\n输出: [1,2]\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n */\nobject TwoSumIITnputArrayIsSorted{\n\n    class Solution {\n        fun twoSum(numbers: IntArray, target: Int): IntArray {\n            // check param valid\n            val res = IntArray(2)\n            for (i in 0 until numbers.size - 1) {\n                for (j in (i + 1) until numbers.size) {\n                    if (numbers[i] + numbers[j] == target) {\n                        res[0] = i + 1\n                        res[1] = j + 1\n                        break\n                    }\n                }\n            }\n            return res\n        }\n\n        /**\n         * 思路:\n         * 傻逼了，没有利用起来有序数组这个特性\n         */\n        fun twoSum2(numbers: IntArray, target: Int): IntArray {\n            // check param valid\n            val res = IntArray(2)\n            var l = 0\n            var r = numbers.size - 1\n            while (l < r) {\n                if (numbers[l] + numbers[r] == target) {\n                    res[0] = l + 1\n                    res[1] = r + 1\n                    break\n                } else if (numbers[l] + numbers[r] < target)  {\n                    l ++\n                } else {\n                    r --\n                }\n            }\n            return res\n        }\n    }\n\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "a00a7aeff74e6beb67483d9a8ece9c1deae0267d", "size": 2185, "name": "leetcode", "license": "MIT License"}
{"path": "src/main/kotlin/adventofcode/year2020/Day22CrabCombat.kt", "owner": "pfolta", "repo_id": 573956675, "is_fork": false, "languages_distribution": "{\"Kotlin\": 199554, \"Dockerfile\": 227}", "content": "package adventofcode.year2020\n\nimport adventofcode.Puzzle\nimport adventofcode.PuzzleInput\n\nclass Day22CrabCombat(customInput: PuzzleInput? = null) : Puzzle(customInput) {\n    private val player1 by lazy { input.split(\"\\n\\n\").first().lines().drop(1).map(String::toInt) }\n    private val player2 by lazy { input.split(\"\\n\\n\").last().lines().drop(1).map(String::toInt) }\n\n    override fun partOne() = CrabCombatGame(player1.toMutableList(), player2.toMutableList()).playRegularGame()\n\n    override fun partTwo() = CrabCombatGame(player1.toMutableList(), player2.toMutableList()).playRecursiveGame(true)\n\n    companion object {\n        private data class CrabCombatGame(\n            val player1: MutableList<Int>,\n            val player2: MutableList<Int>\n        ) {\n            private fun computeScore() = (player1 + player2).reversed().mapIndexed { position, card -> card * (position + 1) }.sum()\n\n            fun playRegularGame(): Int {\n                while (player1.isNotEmpty() && player2.isNotEmpty()) {\n                    val card1 = player1.removeAt(0)\n                    val card2 = player2.removeAt(0)\n\n                    if (card1 > card2) {\n                        player1.addAll(listOf(card1, card2))\n                    } else {\n                        player2.addAll(listOf(card2, card1))\n                    }\n                }\n\n                return computeScore()\n            }\n\n            fun playRecursiveGame(startingGame: Boolean): Int {\n                val previousConfigurations = hashSetOf<CrabCombatGame>()\n\n                while (player1.isNotEmpty() && player2.isNotEmpty()) {\n                    if (previousConfigurations.contains(this)) {\n                        return 1\n                    }\n\n                    previousConfigurations.add(this)\n\n                    val card1 = player1.removeAt(0)\n                    val card2 = player2.removeAt(0)\n\n                    val winningPlayer = when {\n                        player1.size >= card1 && player2.size >= card2 ->\n                            CrabCombatGame(\n                                player1.take(card1).toMutableList(),\n                                player2.take(card2).toMutableList()\n                            ).playRecursiveGame(false)\n                        card1 > card2 -> 1\n                        else -> 2\n                    }\n\n                    if (winningPlayer == 1) {\n                        player1.addAll(listOf(card1, card2))\n                    } else {\n                        player2.addAll(listOf(card2, card1))\n                    }\n                }\n\n                return when (startingGame) {\n                    true -> computeScore()\n                    false -> if (player1.size > player2.size) 1 else 2\n                }\n            }\n        }\n    }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "72492c6a7d0c939b2388e13ffdcbf12b5a1cb838", "size": 2794, "name": "AdventOfCode", "license": "MIT License"}
{"path": "src/Day05.kt", "owner": "ChristianNavolskyi", "repo_id": 573154881, "is_fork": false, "languages_distribution": "{\"Kotlin\": 29804}", "content": "class Day05 : Challenge<String> {\n    override val name: String\n        get() = \"Day 05\"\n\n    override fun inputName(): String = \"Day05\"\n\n    override fun testInputName(): String = \"Day05_test\"\n\n    override fun testResult1(): String = \"CMZ\"\n\n    override fun testResult2(): String = \"MCD\"\n\n    override fun part1(input: String): String {\n        val challengeSetup = input.split(\"\\n\\n\")\n\n        val stacks = challengeSetup.first().split(\"\\n\").parseStacks()\n\n        challengeSetup[1]\n            .split(\"\\n\")\n            .filter { it.isNotBlank() }\n            .map { it.moves() }\n            .forEach { move -> stacks.applyMove9000(move) }\n\n        return stacks.evaluateChallenge()\n    }\n\n    override fun part2(input: String): String {\n        val challengeSetup = input.split(\"\\n\\n\")\n\n        val stacks = challengeSetup.first().split(\"\\n\").parseStacks()\n\n        challengeSetup[1]\n            .split(\"\\n\")\n            .filter { it.isNotBlank() }\n            .map { it.moves() }\n            .forEach { move -> stacks.applyMove9001(move) }\n\n        return stacks.evaluateChallenge()\n    }\n\n    private fun Map<Int, MutableList<Char>>.applyMove9001(move: Triple<Int, Int, Int>) {\n        val (amount, from, to) = move\n\n        this[to]?.addAll(\n            this[from]?.takeLast(amount)\n                ?: throw IndexOutOfBoundsException(\"Cannot move $amount crates from $from to $to of $this\")\n        )\n        repeat((1..amount).count()) { this[from]?.removeLastOrNull() }\n    }\n    private fun Map<Int, MutableList<Char>>.applyMove9000(move: Triple<Int, Int, Int>) {\n        val (amount, from, to) = move\n\n        this[to]?.addAll(\n            this[from]?.takeLast(amount)?.reversed()\n                ?: throw IndexOutOfBoundsException(\"Cannot move $amount crates from $from to $to of $this\")\n        )\n        repeat((1..amount).count()) { this[from]?.removeLastOrNull() }\n    }\n\n    private fun Map<Int, List<Char>>.evaluateChallenge(): String =\n        toSortedMap().mapNotNull { it.value.lastOrNull { c -> c.isLetter() } }.joinToString(\"\")\n\n\n    private fun String.moves(): Triple<Int, Int, Int> {\n        val parts = split(\" \")\n\n        return Triple(parts[1].toInt(), parts[3].toInt(), parts[5].toInt())\n    }\n\n    private fun List<String>.parseStacks(): Map<Int, MutableList<Char>> {\n        val numberOfStacks = last().split(regex = Regex(\"\\\\s\")).last { it.isNotBlank() }.toInt()\n        val result = (1..numberOfStacks).associateWith { mutableListOf<Char>() }\n\n        reversed().drop(1).forEach {\n            it.crates(numberOfStacks).forEachIndexed { index, c ->\n                if (c.isLetter()) {\n                    result[index + 1]?.add(c)\n                        ?: throw IndexOutOfBoundsException(\"Failed to insert $c at index $index into $result\")\n\n                }\n            }\n        }\n\n        return result\n    }\n\n    private fun String.crates(numberOfStacks: Int): List<Char> {\n        return substring(1).mapIndexedNotNull { index, c ->\n            if (index % 4 == 0) {\n                c\n            } else {\n                null\n            }\n        }\n    }\n}\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "222e25771039bdc5b447bf90583214bf26ced417", "size": 3099, "name": "advent-of-code-2022", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/algorithms/NumberGuessingGame.kt", "owner": "AgentKnopf", "repo_id": 240955745, "is_fork": false, "languages_distribution": null, "content": "package algorithms\n\n/**\n * I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower.\n * You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):\n */\ninternal data class NumberGuessingGame(val luckyNumber: Int) {\n    /**\n     * @return 0 if the given number is equal to [luckyNumber]; -1 if [luckyNumber] is lower than the given number;\n     * 1 if [luckyNumber] is higher than the given number.\n     */\n    private fun guess(guessedNumber: Int): Int {\n        return when {\n            guessedNumber == luckyNumber -> 0\n            guessedNumber > luckyNumber -> -1\n            else -> 1\n        }\n    }\n\n    /**\n     * Guesses the lucky number using binary search and the given maximum number. The limit for guessing is 1 to [maxNumber] (inclusive).\n     * @return the guessed number.\n     */\n    fun guessNumber(maxNumber: Int): Int {\n        //Binary search approach\n        var right = maxNumber\n        var left = 1\n        var pivot: Int\n        while (left <= right) {\n            pivot = left + (right - left) / 2\n            val guessResult = guess(pivot)\n            when (guessResult) {\n                0 -> //We're done\n                    return pivot\n                -1 -> //The target number is lower than the current pivot\n                    right = pivot\n                1 -> //The target number is higher than the current pivot\n                    left = pivot + 1\n            }\n        }\n        //This constitutes an error\n        return -1\n    }\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 1, "stars": 0, "commit_sha": "5367ce67e54633e53b2b951c2534bf7b2315c2d8", "size": 1595, "name": "technical-interview", "license": "MIT License"}
{"path": "src/questions/WildcardSearchDS.kt", "owner": "realpacific", "repo_id": 234499820, "is_fork": false, "languages_distribution": null, "content": "package questions\n\nimport _utils.UseCommentAsDocumentation\nimport kotlin.test.assertFalse\nimport kotlin.test.assertTrue\n\n/**\n * Design a data structure that supports adding new words and finding if a string matches any previously added string.\n * Your data structure should implement two methods\n * * `addWord(word)`- Adds word to the data structure\n * * `searchWorld(word)`- Returns true if there is any string in the data structure that matches word. Word may contain dots where a dot can be matched with any letter (a dot represents a wildcard).\n */\n@UseCommentAsDocumentation\nclass Trie {\n    var value: Char? = null\n\n    private val trieMap: MutableMap<Char, Trie> = mutableMapOf()\n\n    fun addWord(word: String) {\n        addWord(word, 0)\n    }\n\n    private fun addWord(word: String, index: Int) {\n        val letter = word.getOrNull(index) ?: return\n        if (letter !in trieMap) {\n            val newTrie = Trie()\n            trieMap[letter] = newTrie\n            newTrie.value = letter\n            newTrie.addWord(word, index + 1)\n        } else {\n            val trie = trieMap[letter]!!\n            trie.addWord(word, index + 1)\n        }\n    }\n\n    override fun toString(): String {\n        return \"Trie($value, ${trieMap.values})\"\n    }\n\n    private fun depthFirstTraversal(trie: Trie, current: String, word: MutableList<String>) {\n        if (trie.trieMap.isEmpty()) {\n            word.add(current)\n        }\n        trie.trieMap.forEach { (k, v) ->\n            depthFirstTraversal(v, current + k, word)\n        }\n    }\n\n    fun searchWord(word: String): Boolean {\n        return searchWord(word, 0)\n    }\n\n    private fun searchWord(word: String, index: Int): Boolean {\n        val letter = word.getOrNull(index) ?: return true\n        if (letter == '.') { // wildcard\n            // Ignore this and try to find any other node that matches next character\n            return trieMap.values.map {\n                it.searchWord(word, index + 1)\n            }.any { it }\n        } else {\n            val nextTrie = trieMap[letter] ?: return false\n            return nextTrie.searchWord(word, index + 1)\n        }\n    }\n\n\n    fun branches(): List<String> {\n        val words = mutableListOf<String>()\n        depthFirstTraversal(this, \"\", words)\n        println(words)\n        return words\n    }\n}\n\nfun main() {\n    run {\n        val trie = Trie()\n        trie.addWord(\"hello\")\n        trie.addWord(\"word\")\n        trie.addWord(\"woke\")\n        trie.addWord(\"world\")\n\n        assertTrue { trie.searchWord(\"hello\") }\n        assertTrue { trie.searchWord(\"word\") }\n        assertFalse { trie.searchWord(\"worry\") }\n        assertTrue { trie.searchWord(\"wo.d\") }\n        assertTrue { trie.searchWord(\"wor.d\") }\n\n        trie.addWord(\"wore\")\n        trie.addWord(\"wop\")\n        trie.addWord(\"won\")\n        trie.addWord(\"worst\")\n\n        assertTrue { trie.searchWord(\"wor.t\") }\n        assertFalse { trie.searchWord(\"wor.ts\") }\n        assertFalse { trie.searchWord(\"worm\") }\n        trie.addWord(\"worm\")\n        assertTrue { trie.searchWord(\"worm\") }\n        assertTrue { trie.searchWord(\"w.rm\") }\n        assertTrue { trie.searchWord(\"w..m\") }\n        assertTrue { trie.searchWord(\"...m\") }\n        assertFalse { trie.searchWord(\"...ms\") }\n        assertTrue { trie.searchWord(\"w...\") }\n    }\n\n    run {\n        val trie = Trie()\n        trie.addWord(\"egg\")\n        trie.addWord(\"eggplant\")\n        trie.addWord(\"eggshell\")\n        trie.addWord(\"elephant\")\n        trie.addWord(\"eleanor\")\n        trie.addWord(\"eleven\")\n        trie.addWord(\"elegant\")\n        trie.addWord(\"evil\")\n\n\n        assertTrue { trie.searchWord(\"egg\") }\n        assertTrue { trie.searchWord(\"eg.\") }\n        assertTrue { trie.searchWord(\"eg.p.a.t\") }\n        assertTrue { trie.searchWord(\"elep.a.t\") }\n        assertFalse { trie.searchWord(\"elope\") }\n        assertFalse { trie.searchWord(\"el.phat\") }\n        assertFalse { trie.searchWord(\"elev.ns\") }\n        assertFalse { trie.searchWord(\"elevens\") }\n        assertFalse { trie.searchWord(\"eleventh\") }\n        assertFalse { trie.searchWord(\"eleven.\") }\n\n        trie.addWord(\"watch\")\n        trie.addWord(\"witch\")\n        trie.addWord(\"with\")\n        trie.addWord(\"without\")\n        trie.addWord(\"withe\")\n        trie.addWord(\"wither\")\n        trie.addWord(\"wit\")\n        trie.addWord(\"withering\")\n        trie.branches()\n    }\n}", "issues": 4.0, "main_language": "Kotlin", "forks": 5, "stars": 93, "commit_sha": "22eef528ef1bea9b9831178b64ff2f5b1f61a51f", "size": 4365, "name": "algorithms", "license": "MIT License"}
{"path": "src/main/kotlin/Day01.kt", "owner": "zychu312", "repo_id": 573345747, "is_fork": false, "languages_distribution": "{\"Kotlin\": 15557}", "content": "interface Caloric {\n    val caloricIntake: Int\n}\n\ndata class Item(override val caloricIntake: Int) : Caloric\n\ndata class Elf(val id: Int, val items: List<Item>) {\n    val totalCalories = items.sumOf { it.caloricIntake }\n}\n\ntailrec fun parseInputToElves(input: List<String>, acc: List<Elf> = emptyList()): List<Elf> {\n\n    if (input.isEmpty()) {\n        return acc\n    }\n\n    val elf = input\n        .takeWhile(String::isNotBlank)\n        .map(String::toInt)\n        .map { calories -> Item(calories) }\n        .let { items -> Elf(id = acc.size + 1, items) }\n\n    return parseInputToElves(input.drop(elf.items.size + 1), acc + elf)\n\n}\n\nfun main() {\n\n    val elves = parseInputToElves(loadFile(\"Day01Input.txt\").readLines())\n\n    val maxCaloriesInInventory = elves.maxOf { elf -> elf.totalCalories }\n\n    println(\"Part 1: $maxCaloriesInInventory\")\n\n    val sumOfTopThreeMostCaloricInventories = elves\n        .map { it.totalCalories }\n        .sortedDescending()\n        .take(3)\n        .sum()\n\n    println(\"Part 2: $sumOfTopThreeMostCaloricInventories\")\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "3e49f2e3aafe53ca32dea5bce4c128d16472fee3", "size": 1056, "name": "advent-of-code-kt", "license": "Apache License 2.0"}
{"path": "src/Day05.kt", "owner": "slawa4s", "repo_id": 573050411, "is_fork": false, "languages_distribution": "{\"Kotlin\": 20679}", "content": "import java.util.Stack\n\nfun main() {\n    fun getInitialStacks(input: List<String>): List<ArrayDeque<Char>> {\n        val filteredInput = input.map { it.toList().filterIndexed { index, _ -> index % 4 == 1 } }\n        val stacks: List<ArrayDeque<Char>> = List(filteredInput[0].size) { ArrayDeque() }\n        for (indexOfLine in filteredInput.lastIndex - 1 downTo 0) {\n            for (indexOfStack in filteredInput[indexOfLine].indices) {\n                if (filteredInput[indexOfLine][indexOfStack] != ' ') stacks[indexOfStack].add(filteredInput[indexOfLine][indexOfStack])\n            }\n        }\n        return stacks\n    }\n\n    fun makeOneMoveOldVersion(howMany: Int, stackFromIndex: Int, stackToIndex: Int, stacks: List<ArrayDeque<Char>>) {\n        for (i in 1..howMany) {\n            stacks[stackToIndex].addLast(stacks[stackFromIndex].removeLastOrNull()!!)\n        }\n    }\n\n    fun makeOneMoveNewVersion(howMany: Int, stackFromIndex: Int, stackToIndex: Int, stacks: List<ArrayDeque<Char>>) {\n        val optionalStack: ArrayDeque<Char> = ArrayDeque()\n        for (i in 1..howMany) {\n            optionalStack.addLast(stacks[stackFromIndex].removeLastOrNull()!!)\n        }\n        for (i in 1..howMany) {\n            stacks[stackToIndex].addLast(optionalStack.removeLastOrNull()!!)\n        }\n    }\n\n    fun getAnswer(stacks: List<ArrayDeque<Char>>): String {\n        val answer = mutableListOf<Char>()\n        for (stack in stacks) {\n            answer.add(stack.last())\n        }\n        return answer.joinToString(separator = \"\")\n    }\n\n    fun splitInput(realInput: List<String>): Pair<List<String>, List<String>> {\n        var separator = 0\n        val groupedInput = realInput.groupBy {\n                if (it == \"\") separator += 1\n                separator\n            }\n            .values.toList()\n        return Pair(groupedInput[0], groupedInput[1].slice(1..groupedInput[1].lastIndex))\n    }\n\n    fun part1(stackInput: List<String>, moveInput: List<String>): String {\n        val stacks: List<ArrayDeque<Char>> = getInitialStacks(stackInput)\n        moveInput.forEach {\n            val args = it.split(\" \")\n            makeOneMoveOldVersion(Integer.parseInt(args[1]), Integer.parseInt(args[3]) - 1, Integer.parseInt(args[5]) - 1, stacks)\n        }\n        return getAnswer(stacks)\n    }\n\n    fun part2(stackInput: List<String>, moveInput: List<String>): String {\n        val stacks: List<ArrayDeque<Char>> = getInitialStacks(stackInput)\n        moveInput.forEach {\n            val args = it.split(\" \")\n            makeOneMoveNewVersion(Integer.parseInt(args[1]), Integer.parseInt(args[3]) - 1, Integer.parseInt(args[5]) - 1, stacks)\n        }\n        return getAnswer(stacks)\n    }\n\n    val (stackInput, moveInput) = splitInput(readInput(\"Day05\"))\n    println(part1(stackInput, moveInput))\n    println(part2(stackInput, moveInput))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "cd8bbbb3a710dc542c2832959a6a03a0d2516866", "size": 2848, "name": "aoc-2022-in-kotlin", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/g2301_2400/s2392_build_a_matrix_with_conditions/Solution.kt", "owner": "javadev", "repo_id": 190711550, "is_fork": false, "languages_distribution": "{\"Kotlin\": 4420233, \"TypeScript\": 50437, \"Python\": 3646, \"Shell\": 994}", "content": "package g2301_2400.s2392_build_a_matrix_with_conditions\n\n// #Hard #Array #Matrix #Graph #Topological_Sort\n// #2023_07_02_Time_706_ms_(100.00%)_Space_65.8_MB_(100.00%)\n\nimport java.util.LinkedList\nimport java.util.Queue\n\nclass Solution {\n    // Using topological sort to solve this problem\n    fun buildMatrix(k: Int, rowConditions: Array<IntArray>, colConditions: Array<IntArray>): Array<IntArray> {\n        // First, get the topo-sorted of row and col\n        val row = toposort(k, rowConditions)\n        val col = toposort(k, colConditions)\n        // base case: when the length of row or col is less than k, return empty.\n        // That is: there is a loop in established graph\n        if (row.size < k || col.size < k) {\n            return Array(0) { IntArray(0) }\n        }\n        val res = Array(k) { IntArray(k) }\n        val map: MutableMap<Int, Int> = HashMap()\n        for (i in 0 until k) {\n            // we record the number corresbonding to each column:\n            // [number, column index]\n            map[col[i]] = i\n        }\n        // col: 3 2 1\n        // row: 1 3 2\n        for (i in 0 until k) {\n            // For each row: we have number row.get(i). And we need to know\n            // which column we need to assign, which is from map.get(row.get(i))\n            // known by map.get()\n            res[i][map[row[i]]!!] = row[i]\n        }\n        return res\n    }\n\n    private fun toposort(k: Int, matrix: Array<IntArray>): List<Int> {\n        // need a int[] to record the indegree of each number [1, k]\n        val deg = IntArray(k + 1)\n        // need a list to record the order of each number, then return this list\n        val res: MutableList<Int> = ArrayList()\n        // need a 2-D list to be the graph, and fill the graph\n        val graph: MutableList<MutableList<Int>> = ArrayList()\n        for (i in 0 until k) {\n            graph.add(ArrayList())\n        }\n        // need a queue to do the BFS\n        val queue: Queue<Int> = LinkedList()\n        // First, we need to establish the graph, following the given matrix\n        for (a in matrix) {\n            val from = a[0]\n            val to = a[1]\n            graph[from - 1].add(to)\n            deg[to]++\n        }\n        // Second, after building a graph, we start the bfs,\n        // that is, traverse the node with 0 degree\n        for (i in 1..k) {\n            if (deg[i] == 0) {\n                queue.offer(i)\n                res.add(i)\n            }\n        }\n        // Third, start the topo sort\n        while (queue.isNotEmpty()) {\n            val node = queue.poll()\n            val list: List<Int> = graph[node - 1]\n            for (i in list) {\n                if (--deg[i] == 0) {\n                    queue.offer(i)\n                    res.add(i)\n                }\n            }\n        }\n        return res\n    }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 14, "stars": 24, "commit_sha": "fc95a0f4e1d629b71574909754ca216e7e1110d2", "size": 2821, "name": "LeetCode-in-Kotlin", "license": "MIT License"}
{"path": "src/Day02.kt", "owner": "sjgoebel", "repo_id": 573578579, "is_fork": false, "languages_distribution": "{\"Kotlin\": 21782}", "content": "fun main() {\n    fun scissors(move: Char): Int {\n        return when (move) {\n            'X' -> 1 + 6\n            'Y' -> 2 + 0\n            'Z' -> 3 + 3\n            else -> 0\n        }\n    }\n\n    fun rock(move: Char): Int {\n        return when (move) {\n            'X' -> 1 + 3\n            'Y' -> 2 + 6\n            'Z' -> 3 + 0\n            else -> 0\n        }\n    }\n\n    fun paper(move: Char): Int {\n        return when (move) {\n            'X' -> 1 + 0\n            'Y' -> 2 + 3\n            'Z' -> 3 + 6\n            else -> 0\n        }\n    }\n\n    fun part1(input: List<String>): Int {\n        var total = 0\n\n        for (line in input) {\n            when (line[0]) {\n                'C' -> total += scissors(line[2])\n                'A' -> total += rock(line[2])\n                'B' -> total += paper(line[2])\n            }\n        }\n\n        return total\n    }\n\n    fun win(input: Char): Int {\n        return when (input) {\n            'A' -> 6 + 2\n            'B' -> 6 + 3\n            'C' -> 6 + 1\n            else -> 0\n        }\n\n    }\n\n    fun lose(input: Char): Int {\n        return when (input) {\n            'A' -> 3\n            'B' -> 1\n            'C' -> 2\n            else -> 0\n        }\n\n    }\n\n    fun tie(input: Char): Int {\n        return when (input) {\n            'A' -> 3 + 1\n            'B' -> 3 + 2\n            'C' -> 3 + 3\n            else -> 0\n        }\n\n    }\n\n    fun part2(input: List<String>): Int {\n        var total = 0\n\n        for (line in input) {\n            when (line[2]) {\n                'X' -> total += lose(line[0])\n                'Y' -> total += tie(line[0])\n                'Z' -> total += win(line[0])\n            }\n        }\n\n        return total\n    }\n\n\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day02_test\")\n    check(part1(testInput) == 15)\n\n    val input = readInput(\"Day02\")\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "ae1588dbbb923dbcd4d19fd1495ec4ebe8f2593e", "size": 1939, "name": "advent-of-code-2022-kotlin", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/day15/main.kt", "owner": "janneri", "repo_id": 572969955, "is_fork": false, "languages_distribution": "{\"Kotlin\": 99028}", "content": "package day15\n\nimport util.readTestInput\nimport kotlin.math.abs\nimport kotlin.math.max\n\nprivate data class Coord(val x: Int, val y: Int) {\n    fun distanceTo(coord: Coord) = abs(x - coord.x) + abs(y - coord.y)\n}\n\nprivate data class Sensor(val sensorCoord: Coord, val beaconCoord: Coord) {\n    val range = sensorCoord.distanceTo(beaconCoord)\n    fun rangeAt(y: Int) = max(0, range - abs(sensorCoord.y - y))\n    fun isInRange(y: Int) = range >= abs(sensorCoord.y - y)\n    fun minXAtY(y: Int) = sensorCoord.x - rangeAt(y)\n    fun maxXAtY(y: Int) = sensorCoord.x + rangeAt(y)\n}\n\nprivate fun limit(num: Int, min: Int, max: Int): Int {\n    return when {\n        num < min -> min\n        num > max -> max\n        else -> num\n    }\n}\n\n// 1-3 a: abcde\nprivate val regex = Regex(\"\"\"Sensor at x=(-?\\d+), y=(-?\\d+): closest beacon is at x=(-?\\d+), y=(-?\\d+)\"\"\")\nprivate fun parseSensor(line: String): Sensor =\n    regex.matchEntire(line)!!\n        .destructured\n        .let { (sensorX, sensorY, beaconX, beaconY) ->\n            Sensor(Coord(sensorX.toInt(), sensorY.toInt()), Coord(beaconX.toInt(), beaconY.toInt()))\n        }\n\nfun part1(inputLines: List<String>, y: Int): Int {\n    val sensors = inputLines.map { parseSensor(it) }\n    val beaconXCoordsAtY = sensors.filter { it.beaconCoord.y == y }.map { it.beaconCoord.x }.toSet()\n\n    val coveredXCoords = sensors.fold(mutableSetOf<Int>()) { acc, sensor ->\n        if (sensor.isInRange(y)) {\n            acc.addAll(sensor.minXAtY(y) .. sensor.maxXAtY(y))\n        }\n        acc\n    }\n\n    return coveredXCoords.filter { !beaconXCoordsAtY.contains(it) }.size\n}\n\nprivate fun findCoveredXRanges(y: Int, sensors: List<Sensor>, maxXAndY: Int): Set<IntRange> =\n    sensors.fold(mutableSetOf()) { acc, sensor ->\n        if (sensor.isInRange(y)) {\n            val minX = limit(sensor.minXAtY(y), 0, maxXAndY)\n            val maxX = limit(sensor.maxXAtY(y), 0, maxXAndY)\n            acc.add(IntRange(minX, maxX))\n        }\n        acc\n    }\n\nfun merge(range1: IntRange, range2: IntRange): IntRange? {\n    return when {\n        range1.first >= range2.first && range1.last <= range2.last -> range2 // ...2...1...1...2..\n        range2.first >= range1.first && range2.last <= range1.last -> range1 // ...1...2...2...1..\n        range1.first < range2.first && range1.last >= range2.first -> IntRange(range1.first, max(range1.last, range2.last)) // ...1...2...1...2..\n        range2.first < range1.first && range2.last >= range1.first -> IntRange(range2.first, max(range1.last, range2.last)) // ...2...1...2...1..\n        else -> null // range1 is fully before or fully after range2\n    }\n}\n\nfun part2(inputLines: List<String>, maxXAndY: Int): ULong {\n    val sensors = inputLines.map { parseSensor(it) }\n\n    fun findUncoveredCoord(): Coord? {\n        for (currentY in 0 until maxXAndY) {\n            val coveredRanges = findCoveredXRanges(currentY, sensors, maxXAndY).sortedBy { it.first }\n\n            var currentRange = coveredRanges.first()\n            for (range in coveredRanges) {\n                val mergedRange = merge(currentRange, range)\n\n                // merge returns null when ranges are not overlapping, which means we have found the gap\n                if (mergedRange == null) {\n                    return Coord(currentRange.last + 1, currentY)\n                }\n\n                currentRange = mergedRange\n            }\n        }\n        return null\n    }\n\n    val distressBeaconCoord = findUncoveredCoord()\n    return distressBeaconCoord!!.x.toULong() * 4000000.toULong() + distressBeaconCoord.y.toULong()\n}\n\nfun main() {\n    val inputLines = readTestInput(\"day15\")\n    println(part1(inputLines, 10))\n    println(part2(inputLines, 4000000))\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "1de6781b4d48852f4a6c44943cc25f9c864a4906", "size": 3691, "name": "advent-of-code-2022", "license": "MIT License"}
{"path": "src/main/kotlin/kr/co/programmers/P42861.kt", "owner": "antop-dev", "repo_id": 229558170, "is_fork": false, "languages_distribution": "{\"Kotlin\": 695315, \"Java\": 213000}", "content": "package kr.co.programmers\n\n// https://github.com/antop-dev/algorithm/issues/530\nclass P42861 {\n\n    fun solution(n: Int, costs: Array<IntArray>): Int {\n        // 건설 비용이 낮은 순으로 정렬\n        costs.sortBy { (_, _, cost) -> cost }\n        // Union-Find\n        val root = IntArray(n) { it }\n        var ans = 0\n        var count = 0\n        for ((from, to, cost) in costs) {\n            // 두 정점의 부모 정점이 같다면 패스 (루프)\n            if (root.find(from) == root.find(to)) continue\n            // 비용 누적\n            ans += cost\n            // 부모를 합쳐준다.\n            root.union(from, to)\n            // 간선은 (N-1)개가 만들어진다.\n            if (count++ >= n) break\n        }\n        return ans\n    }\n\n    private fun IntArray.find(x: Int): Int = if (this[x] == x) x else find(this[x])\n\n    private fun IntArray.union(x: Int, y: Int) {\n        this[find(y)] = find(x)\n    }\n\n}\n", "issues": 1.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "9a3e762af93b078a2abd0d97543123a06e327164", "size": 951, "name": "algorithm", "license": "MIT License"}
{"path": "src/main/kotlin/dp/LargestPattern.kt", "owner": "yx-z", "repo_id": 106589674, "is_fork": false, "languages_distribution": null, "content": "package dp\n\nimport math.isPrime\nimport util.*\n\n// given a bitmap as a 2d array, identify the largest rectangular pattern that appear more than once\n// the copies of a pattern may overlap but cannot coincide\n// report its size\nfun main(args: Array<String>) {\n\tval bitmap = arrayOf(\n\t\t\tintArrayOf(0, 1, 0, 0, 0),\n\t\t\tintArrayOf(1, 0, 1, 0, 0),\n\t\t\tintArrayOf(0, 1, 0, 1, 0),\n\t\t\tintArrayOf(0, 0, 1, 0, 1),\n\t\t\tintArrayOf(0, 0, 0, 1, 0))\n\n//\tprintln(bitmap.largestPattern())\n\tprintln(bitmap.map { it.toOneArray() }.toOneArray().largestPattern())\n}\n\nfun OneArray<OneArray<Int>>.largestPattern(): Int {\n\tval M = this\n\tval n = size\n\n\t// dp(i, j, p, q, h): max width w : h * w subarrays are identical\n\t// memoization structure: 5d array dp[1..n, 1..n, 1..n, 1..n, 1..n]\n\tval dp = OneArray(n + 1) { OneArray(n + 1) { OneArray(n + 1) { OneArray(n + 1) { OneArray(n) { 0 } } } } }\n\t// space complexity: O(n^5)\n\n\tvar max = 0\n\t// evaluation order: h has to be 1 to n since entries in h - 1 are required\n\t// there is no specific evaluation order for i, j, p, q\n\tfor (h in 1..n) {\n\t\tfor (i in 1..n) {\n\t\t\tfor (j in 1..n + 1) {\n\t\t\t\tfor (p in 1..n) {\n\t\t\t\t\tfor (q in 1..n + 1) {\n\t\t\t\t\t\t// different cases\n\t\t\t\t\t\tval curr = when {\n\t\t\t\t\t\t\ti == p && j == q -> N_INF\n\t\t\t\t\t\t\tj > n || q > n -> 0\n\t\t\t\t\t\t\tM[i, j] != M[p, q] -> 0\n\t\t\t\t\t\t\th == 1 -> 1 + dp[i, j + 1, p, q + 1, 1]\n\t\t\t\t\t\t\telse -> min(dp[i, j, p, q, 1], dp[i + 1, j, p + 1, q, h - 1])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i, j, p, q, h] = curr\n\n\t\t\t\t\t\t// maintain a max here\n\t\t\t\t\t\tif (curr > 0) {\n\t\t\t\t\t\t\tmax = max(max, curr * h)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// time complexity: O(n^5)\n\treturn max\n}\n\nfun Array<IntArray>.largestPattern(): Int {\n\tval rows = size\n\tval cols = this[0].size\n\n\tval primes = Array(rows) { IntArray(cols) }\n\tval primesFlat = primes(rows * cols)\n\tfor (row in 0 until rows) {\n\t\tfor (col in 0 until cols) {\n\t\t\tprimes[row, col] = primesFlat[cols * row + col]\n\t\t}\n\t}\n\n\tval dp = Array(rows) { Array(cols) { Array(rows) { IntArray(cols) { 1 } } } }\n\tval dpFlat = Array(rows * rows * cols * cols) { 0 to (0 to (0 to (0 to 1))) }\n\tvar dpFlatIdx = 0\n\tfor (i in 0 until rows) {\n\t\tfor (j in 0 until cols) {\n\t\t\tfor (p in i until rows) {\n\t\t\t\tfor (q in j until cols) {\n\t\t\t\t\tdp[i, j, p, q] = if (this[p, q] == 1) {\n\t\t\t\t\t\tprimes[p - i, q - j]\n\t\t\t\t\t} else {\n\t\t\t\t\t\t1\n\t\t\t\t\t}\n\n\t\t\t\t\tif (p - 1 >= 0 && q - 1 >= 0) {\n\t\t\t\t\t\tdp[i, j, p, q] *= dp[i, j, p - 1, q] * dp[i, j, p, q - 1] / dp[i, j, p - 1, q - 1]\n\t\t\t\t\t} else if (p - 1 >= 0) {\n\t\t\t\t\t\tdp[i, j, p, q] *= dp[i, j, p - 1, q]\n\t\t\t\t\t} else if (q - 1 >= 0) {\n\t\t\t\t\t\tdp[i, j, p, q] *= dp[i, j, p, q - 1]\n\t\t\t\t\t}\n\n\t\t\t\t\tdpFlat[dpFlatIdx] = i to (j to (p to (q to dp[i, j, p, q])))\n\t\t\t\t\tdpFlatIdx++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdpFlat.sortBy { it.second.second.second.second }\n\tvar maxSize = Int.MIN_VALUE\n\t(1 until dpFlat.size).asSequence()\n\t\t\t.filter { dpFlat[it].second.second.second.second == dpFlat[it - 1].second.second.second.second }\n\t\t\t.forEach { maxSize = max(maxSize, (dpFlat[it].second.second.first - dpFlat[it].first + 1) * (dpFlat[it].second.second.second.first - dpFlat[it].second.first + 1)) }\n\n\treturn maxSize\n}\n\n// return the first `n` prime numbers\nfun primes(n: Int): IntArray {\n\tval ans = IntArray(n)\n\tvar num = 2\n\tfor (i in 0 until n) {\n\t\twhile (!num.isPrime()) {\n\t\t\tnum++\n\t\t}\n\t\tans[i] = num\n\t\tnum++\n\t}\n\treturn ans\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "15494d3dba5e5aa825ffa760107d60c297fb5206", "size": 3286, "name": "AlgoKt", "license": "MIT License"}
{"path": "src/main/kotlin/dayone/DayOne.kt", "owner": "pauliancu97", "repo_id": 619525509, "is_fork": false, "languages_distribution": null, "content": "package dayone\n\nimport getLines\n\nprivate fun getElvesCalories(strings: List<String>): List<List<Int>> {\n    val separatorIndices = listOf(-1) +\n            strings.withIndex().mapNotNull { (index, string) -> if (string.isEmpty()) index else null } +\n            listOf(strings.size)\n    return separatorIndices.zipWithNext { start, end ->\n        val stringsSublist = strings.subList(start + 1, end)\n        stringsSublist.map { it.toInt() }\n    }\n}\n\nprivate fun getMaxCaloriesForElf(elves: List<List<Int>>): Int =\n    elves.maxOf { calories -> calories.sum() }\n\nprivate fun getCaloriesOfTopElves(elves: List<List<Int>>): Int =\n    elves\n        .map { calories -> calories.sum() }\n        .sortedDescending()\n        .take(3)\n        .sum()\n\nprivate fun solvePartOne() {\n    val strings = getLines(\"day_1.txt\")\n    val elves = getElvesCalories(strings)\n    println(getMaxCaloriesForElf(elves))\n}\n\nprivate fun solvePartTwo() {\n    val strings = getLines(\"day_1.txt\")\n    val elves = getElvesCalories(strings)\n    println(getCaloriesOfTopElves(elves))\n}\n\nfun main() {\n    solvePartTwo()\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "78af929252f094a34fe7989984a30724fdb81498", "size": 1087, "name": "advent-of-code-2022", "license": "MIT License"}
{"path": "src/Day04.kt", "owner": "JaydenPease", "repo_id": 574590496, "is_fork": false, "languages_distribution": "{\"Kotlin\": 11645}", "content": "fun main() {\n//    fun part1(input: List<String>): Int {\n//        return input.size\n//    }\n//\n//    fun part2(input: List<String>): Int {\n//        return input.size\n//    }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day04_test\")\n    //println(Day04_part1(testInput))\n    //println(Day04_part2(testInput))\n\n    val input = readInput(\"Day04\")\n    //println(Day04_part1(input))\n    println(Day04_part2(input))\n\n}\n\n\n\n\n\n\nfun Day04_part1(input: List<String>): Int {\n\n    var count: Int = 0\n\n    for(i in input.indices) {\n        val sections = input[i].split(\",\")\n        val first = sections[0].split(\"-\")\n        val second = sections[1].split(\"-\")\n\n        if((first[0].toInt() - second[0].toInt() <= 0 && first[1].toInt() - second[1].toInt() >= 0) || (first[0].toInt() - second[0].toInt() >= 0 && first[1].toInt() - second[1].toInt() <= 0)) {\n            count++\n        }\n    }\n\n    return count\n\n}\n\nfun Day04_part2(input: List<String>): Int {\n\n    var count: Int = 0\n\n    for(i in input.indices) {\n        val sections = input[i].split(\",\")\n        val first = sections[0].split(\"-\")\n        val second = sections[1].split(\"-\")\n\n        if(second[0].toInt() - first[1].toInt() <= 0 && second[1].toInt() - first[0].toInt() >= 0) {\n            count++\n        }\n    }\n\n    return count\n\n}\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "0a5fa22b3653c4b44a716927e2293fc4b2ed9eb7", "size": 1353, "name": "AdventOfCode-2022", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/sortingandsearching/MedianOfTwoSortedArrays.kt", "owner": "e-freiman", "repo_id": 471473372, "is_fork": false, "languages_distribution": "{\"Kotlin\": 78010}", "content": "package sortingandsearching\n\n// O(log(min(m, n)))\nfun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n    val a = if (nums1.size < nums2.size) nums1 else nums2\n    val b = if (nums1.size < nums2.size) nums2 else nums1\n\n    var l = 0\n    var r = a.size\n    var i: Int\n    var j: Int\n    var found: Boolean\n    do {\n        i = (l + r) / 2\n        j = (a.size + b.size) / 2 - i\n        found = true\n\n        if (i > 0 && i <= a.size && j >= 0 && j < b.size && a[i - 1] > b[j]) {\n            r = i - 1\n            found = false\n        }\n\n        if (i >= 0 && i < a.size && j > 0 && j <= b.size && b[j - 1] > a[i]) {\n            l = i + 1\n            found = false\n        }\n    } while (!found)\n\n    val left = maxOf(\n        if (i > 0 && i <= a.size) a[i - 1] else Int.MIN_VALUE,\n        if (j > 0 && j <= b.size) b[j - 1] else Int.MIN_VALUE)\n\n    val right =  minOf(\n        if (i >= 0 && i < a.size) a[i] else Int.MAX_VALUE,\n        if (j >= 0 && j < b.size) b[j] else Int.MAX_VALUE)\n\n    return if ((a.size + b.size) % 2 == 0)\n        (left + right) / 2.0\n    else\n        right / 1.0\n}\n\n\nfun main() {\n    println(findMedianSortedArrays(intArrayOf(2,3,4,5,6,7), intArrayOf(1)))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "fab7f275fbbafeeb79c520622995216f6c7d8642", "size": 1202, "name": "LeetcodeGoogleInterview", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/aoc2022/Day07.kt", "owner": "w8mr", "repo_id": 572700604, "is_fork": false, "languages_distribution": "{\"Kotlin\": 140954}", "content": "package aoc2022\n\nimport aoc.*\nimport aoc.parser.*\n\n\nclass Day07() {\n    sealed interface Node {\n        val size: Int\n        val subNodes: List<Node>\n    }\n\n    data class FileNode(override val size: Int, val name: String) : Node {\n        override val subNodes: List<Node>\n            get() = emptyList()\n    }\n\n    data class DirNode(val name: String, override val subNodes: List<Node> = emptyList()) : Node {\n        override val size: Int\n            get() = subNodes.sumOf { it.size }\n    }\n\n    val fileEntry = seq(number() followedBy \" \", regex(\"[a-zA-Z./]+\") followedBy \"\\n\", ::FileNode)\n    val dirEntry = \"dir \" followedBy regex(\"[a-zA-Z./]+\") followedBy \"\\n\" asValue null\n    val fileDirEntry = dirEntry or fileEntry\n    val entry: Parser<Node?> = ref(::dirListing) or fileDirEntry\n    val entries = oneOrMore(entry) map { it.filterNotNull() }\n    val dirListing = seq(\n        \"\\$ cd \" followedBy regex(\"[a-zA-Z/]+\"),\n        \"\\n\\$ ls\\n\" followedBy entries, ::DirNode) followedBy (eoF() or literal(\"\\$ cd ..\\n\"))\n\n\n    fun part1(input: String): Int {\n        val tree = dirListing.parse(input)\n        val r = foldTree(tree, Node::subNodes, 0) { acc, node ->\n            acc + if (node is DirNode && node.size < 100000) node.size else 0\n        }\n        return r\n    }\n\n    fun part2(input: String): Int {\n        val minimum = 30000000 - 21618835\n        val tree = dirListing.parse(input)\n        val r = foldTree(tree, Node::subNodes, null) { acc: Node?, node: Node ->\n            if (node is DirNode && node.size >= minimum && node.size < (acc?.size ?: Int.MAX_VALUE)) node else acc\n        }\n        return r?.size ?: 0\n    }\n}\n\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "e9bd07770ccf8949f718a02db8d09daf5804273d", "size": 1649, "name": "aoc-kotlin", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/com/hj/leetcode/kotlin/problem1572/Solution.kt", "owner": "hj-core", "repo_id": 534054064, "is_fork": false, "languages_distribution": "{\"Kotlin\": 619841}", "content": "package com.hj.leetcode.kotlin.problem1572\n\n/**\n * LeetCode page: [1572. Matrix Diagonal Sum](https://leetcode.com/problems/matrix-diagonal-sum/);\n */\nclass Solution {\n    /* Complexity:\n     * Time O(N) and Space O(1) where N is the number of rows(columns) of mat;\n     */\n    fun diagonalSum(mat: Array<IntArray>): Int {\n        return sumPrimaryDiagonal(mat) + sumSecondaryDiagonal(mat) - sharedCenterValue(mat)\n    }\n\n    private fun sumPrimaryDiagonal(mat: Array<IntArray>): Int {\n        var sum = 0\n        for (index in mat.indices) {\n            sum += mat[index][index]\n        }\n        return sum\n    }\n\n    private fun sumSecondaryDiagonal(mat: Array<IntArray>): Int {\n        var sum = 0\n        for (index in mat.indices) {\n            sum += mat[mat.lastIndex - index][index]\n        }\n        return sum\n    }\n\n    private fun sharedCenterValue(mat: Array<IntArray>): Int {\n        val noSharedElement = mat.size.isEven()\n        if (noSharedElement) return 0\n\n        val center = mat.size / 2\n        return mat[center][center]\n    }\n\n    private fun Int.isEven(): Boolean = this and 1 == 0\n}", "issues": 1.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "14c033f2bf43d1c4148633a222c133d76986029c", "size": 1111, "name": "hj-leetcode-kotlin", "license": "Apache License 2.0"}
{"path": "src/Day10.kt", "owner": "djleeds", "repo_id": 572720298, "is_fork": false, "languages_distribution": "{\"Kotlin\": 43505}", "content": "sealed class Instruction(val cycles: Int, val operation: (previousX: Int) -> Int) {\n    class NoOp : Instruction(1, { it })\n    class AddX(private val amount: Int) : Instruction(2, { it + amount })\n    companion object {\n        fun parse(line: String) = when {\n            line == \"noop\"          -> NoOp()\n            line.startsWith(\"addx\") -> AddX(line.substringAfter(\" \").toInt())\n            else                    -> throw IllegalArgumentException()\n        }\n    }\n}\n\nclass CPU {\n    val history: MutableList<Int> = mutableListOf(1)\n    private val x: Int get() = history.last()\n    private fun tick(value: Int = x) = history.add(value)\n\n    fun execute(program: List<Instruction>) = program.forEach { instruction ->\n        repeat(instruction.cycles - 1) { tick() }\n        tick(instruction.operation(x))\n    }\n}\n\nclass Sprite(width: Int, position: Int) {\n    private val reach = (width - 1) / 2\n    val occupiedPixels: IntRange = (position - reach)..(position + reach)\n}\n\nclass CRT(private val width: Int, height: Int) {\n    private val pixels: MutableList<Boolean> = MutableList((width * height) + 1) { false }\n\n    fun tick(cycle: Int, sprite: Sprite) {\n        val renderingAt = cycle.rem(width)\n        pixels[cycle] = renderingAt in sprite.occupiedPixels\n    }\n\n    fun render(on: String = \"#\", off: String = \".\") =\n        pixels.joinToString(\"\") { if (it) on else off }.chunked(40).forEach(::println)\n}\n\nfun main() {\n    fun part1(instructions: List<String>): Int {\n        val cpu = CPU().apply { execute(instructions.map(Instruction::parse)) }\n        return listOf(20, 60, 100, 140, 180, 220).sumOf { cpu.history[it - 1] * it }\n    }\n\n    fun part2(instructions: List<String>) {\n        val crt = CRT(40, 6)\n\n        CPU()\n            .apply { execute(instructions.map(Instruction::parse)) }\n            .history\n            .forEachIndexed { cycle, x -> crt.tick(cycle, Sprite(3, x)) }\n\n        crt.render()\n    }\n\n    val testInput = readInput(\"Day10_test\")\n    println(part1(testInput))\n    println(part2(testInput))\n\n    val input = readInput(\"Day10\")\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 4, "commit_sha": "98946a517c5ab8cbb337439565f9eb35e0ce1c72", "size": 2131, "name": "advent-of-code-in-kotlin-2022", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/day14/CountProjection.kt", "owner": "Ostkontentitan", "repo_id": 434500914, "is_fork": false, "languages_distribution": "{\"Kotlin\": 73563}", "content": "package day14\n\nclass CountProjection {\n    fun perform(steps: Int, inputs: List<String>): Long {\n        val instructions = extractInstructionMap(inputs)\n        val polyCount = initialPolyPairCount(inputs.first())\n        val polyTail = inputs.first().last().toString()\n        val countForChars = growPolyCountBySteps(steps, polyCount, instructions, polyTail)\n        val counts = countForChars.values.sorted()\n        return counts.maxOf { it } - counts.minOf { it }\n    }\n\n    private tailrec fun growPolyCountBySteps(\n        steps: Int,\n        polyCount: Map<String, Long>,\n        instructions: Map<String, String>,\n        tail: String\n    ): Map<String, Long> = if (steps == 0) {\n        polyCount.keys.fold(mapOf(tail to 1)) { acc, item ->\n            val first = item.first().toString()\n            val count = polyCount[item]!!\n            acc + (first to (acc[first] ?: 0L) + count)\n        }\n    } else {\n        val new = growPolyCountByStep(polyCount, instructions)\n        growPolyCountBySteps(steps - 1, new, instructions, tail)\n    }\n\n    private fun growPolyCountByStep(\n        polyCount: Map<String, Long>,\n        instructions: Map<String, String>\n    ): Map<String, Long> {\n        val updated = mutableMapOf<String, Long>()\n        polyCount.forEach { item ->\n            val insertion = instructions[item.key]\n            if (insertion != null) {\n                val keyOne = \"${item.key[0]}${insertion}\"\n                val keyTwo = \"${insertion}${item.key[1]}\"\n                val itemCount = item.value\n                updated.addToValue(keyOne, itemCount)\n                updated.addToValue(keyTwo, itemCount)\n            }\n        }\n        return updated.filterValues { it > 0L }\n    }\n\n    private fun MutableMap<String, Long>.addToValue(key: String, itemCount: Long) {\n        this += (key to ((this[key] ?: 0) + itemCount))\n    }\n\n    private fun initialPolyPairCount(input: String): Map<String, Long> =\n        input.windowed(size = 2, partialWindows = true).fold(emptyMap()) { acc, item ->\n            acc + (item to (acc[item] ?: 0L) + 1L)\n        }\n\n    private fun extractInstructionMap(inputs: List<String>): Map<String, String> =\n        inputs.subList(2, inputs.size).associate {\n            val (target, replace) = it.split(\" -> \")\n            target to replace\n        }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "e0e5022238747e4b934cac0f6235b92831ca8ac7", "size": 2319, "name": "advent-of-kotlin-2021", "license": "Apache License 2.0"}
{"path": "src/Day14.kt", "owner": "dakr0013", "repo_id": 572861855, "is_fork": false, "languages_distribution": "{\"Kotlin\": 105418}", "content": "import Material.*\nimport java.awt.Point\nimport kotlin.test.assertEquals\n\nfun main() {\n  fun part1(input: List<String>): Int {\n    val cave = Cave.parse(input) // .also { println(it) }\n    val sandSource = Point(500, 0)\n    var steps = 0\n    while (cave.pourSand(sandSource)) {\n      steps++\n    }\n    return steps\n  }\n\n  fun part2(input: List<String>): Int {\n    val cave = Cave.parse(input, true) // .also { println(it) }\n    val sandSource = Point(500, 0)\n    var steps = 0\n    while (cave.pourSand(sandSource)) {\n      steps++\n    }\n    return steps\n  }\n\n  // test if implementation meets criteria from the description, like:\n  val testInput = readInput(\"Day14_test\")\n  assertEquals(24, part1(testInput))\n  assertEquals(93, part2(testInput))\n\n  val input = readInput(\"Day14\")\n  println(part1(input))\n  println(part2(input))\n}\n\nprivate enum class Material(val isSolid: Boolean) {\n  SAND(true),\n  ROCK(true),\n  AIR(false);\n\n  override fun toString() =\n      when (this) {\n        SAND -> \"o\"\n        ROCK -> \"#\"\n        AIR -> \".\"\n      }\n}\n\nprivate data class Structure(val material: Material, val path: List<Point>)\n\nprivate class Line(a: Point, b: Point) : Iterable<Point> {\n  val start: Point = if (a.x < b.x || a.y < b.y) a else b\n  val end: Point = if (a.x < b.x || a.y < b.y) b else a\n\n  init {\n    require(start.x == end.x || start.y == end.y) {\n      \"Points must represent a horizontal or vertical line\"\n    }\n  }\n\n  override fun iterator(): Iterator<Point> = PointByPointIterator()\n\n  private inner class PointByPointIterator : Iterator<Point> {\n    val isHorizontalLine = start.y == end.y\n    var currentOffset = 0\n    override fun hasNext(): Boolean {\n      return if (isHorizontalLine) {\n        start.x + currentOffset <= end.x\n      } else {\n        start.y + currentOffset <= end.y\n      }\n    }\n\n    override fun next(): Point {\n      if (!hasNext())\n          throw NoSuchElementException(\"No further points on line: end of line already reached.\")\n      return if (isHorizontalLine) {\n        Point(start.x + currentOffset++, start.y)\n      } else {\n        Point(start.x, start.y + currentOffset++)\n      }\n    }\n  }\n}\n\nprivate class Cave(val map: Array<Array<Material>>) {\n\n  /** @return true if sand comes to rest and source is not blocked */\n  fun pourSand(source: Point): Boolean {\n    val isSourceBlocked = map[source.x][source.y].isSolid\n    if (isSourceBlocked) return false\n\n    val restPoint = simulateFallingMaterial(source)\n    if (restPoint != null) {\n      map[restPoint.x][restPoint.y] = SAND\n    }\n    return restPoint != null\n  }\n\n  /** @return point where falling material comes to rest or null if it falls into void */\n  private fun simulateFallingMaterial(source: Point): Point? {\n    for (y in source.y..map[source.x].lastIndex) {\n      if (map[source.x][y].isSolid) {\n        return when {\n          !map[source.x - 1][y].isSolid -> simulateFallingMaterial(Point(source.x - 1, y))\n          !map[source.x + 1][y].isSolid -> simulateFallingMaterial(Point(source.x + 1, y))\n          else -> Point(source.x, y - 1)\n        }\n      }\n    }\n    return null\n  }\n\n  private fun add(structures: List<Structure>) {\n    for (structure in structures) {\n      for (i in 0 until structure.path.lastIndex) {\n        val line = Line(structure.path[i], structure.path[i + 1])\n        for (point in line) {\n          map[point.x][point.y] = structure.material\n        }\n      }\n    }\n  }\n\n  override fun toString() = buildString {\n    for (y in map[0].indices) {\n      for (x in 490..510) {\n        append(map[x][y])\n      }\n      appendLine()\n    }\n  }\n\n  companion object {\n    fun parse(input: List<String>, withFloor: Boolean = false): Cave {\n      val structures =\n          input\n              .map { line ->\n                line.split(\" -> \").map { xyPair ->\n                  Point(\n                      xyPair.split(\",\").first().toInt(),\n                      xyPair.split(\",\").last().toInt(),\n                  )\n                }\n              }\n              .map { points -> Structure(ROCK, points) }\n\n      val yOfLowestStructure = structures.flatMap { it.path }.maxOf { it.y }\n      val xOfMostRightStructure = structures.flatMap { it.path }.maxOf { it.x }\n      val floor =\n          Structure(\n              ROCK,\n              listOf(\n                  Point(0, yOfLowestStructure + 2),\n                  Point(xOfMostRightStructure * 2, yOfLowestStructure + 2)),\n          )\n      val map = Array(xOfMostRightStructure * 2 + 1) { Array(yOfLowestStructure + 2 + 1) { AIR } }\n\n      return Cave(map).apply {\n        add(structures)\n        if (withFloor) add(listOf(floor))\n      }\n    }\n  }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "6b3adb09f10f10baae36284ac19c29896d9993d9", "size": 4638, "name": "aoc2022", "license": "Apache License 2.0"}
{"path": "kotlin/src/main/kotlin/be/swsb/aoc2023/day3/Schematic.kt", "owner": "Sch3lp", "repo_id": 724797927, "is_fork": false, "languages_distribution": "{\"Kotlin\": 44815, \"Rust\": 14075}", "content": "package be.swsb.aoc2023.day3\n\nimport be.swsb.aoc2023.Point\n\nfun String.parse() =\n    Schematic(lines().flatMapIndexed { y, line ->\n        line.mapIndexed { x, char ->\n            Point(x, y) to char\n        }\n    }.toMap())\ntypealias Gear = Pair<Point, Set<Int>>\n\nval Gear.ratio get() = this.second.map { it.toLong() }.reduce(Long::times)\n\nclass Schematic(private val points: Map<Point, Char>) {\n\n    fun allGears(): List<Gear> {\n        val numbersNextToAsterisks = allNumbersAdjacentToSymbol('*').toMap()\n        val allAsterisks = points.filterValues { it == '*' }.keys\n        return allAsterisks.map { asterisk ->\n            asterisk to numbersNextToAsterisks.filterValues { points -> points.any { point -> point in asterisk.neighbours } }.keys\n        }.filter { (_,numbers) -> numbers.size == 2 }\n    }\n\n    fun allNumbersAdjacentToSymbol(symbol: Char? = null): List<Pair<Int, List<Point>>> =\n        allNumbers().filter { (_, points) ->\n            points.any { point -> point.isAdjacentToASymbol(symbol) }\n        }\n\n    private fun Point.isAdjacentToASymbol(symbol: Char? = null) =\n        neighbours.any { neighbour ->\n            neighbour in this@Schematic.points.filterValues {\n                if (symbol == null) !it.isDigit() && it != '.'\n                else it == symbol\n            }.keys\n        }\n\n    fun allNumbers(): List<Pair<Int, List<Point>>> {\n        val maxX = points.maxOf { (k, _) -> k.x }\n        val maxY = points.maxOf { (k, _) -> k.y }\n        val numbers = mutableListOf<Pair<Int, List<Point>>>()\n\n        (0..maxY).forEach { y ->\n            (0..maxX).forEach { x ->\n                val point = Point(x, y)\n                if (point !in numbers.flatMap { it.second } && points[point]?.isDigit() == true) {\n                    var curNumber = \"${points[point]}\"\n                    val curPoints = mutableListOf(point)\n                    var curPoint = point\n                    while (curPoint.searchRight { p -> points[p]?.isDigit() == true } != null) {\n                        val rightNeighbour = curPoint.searchRight { p -> points[p]?.isDigit() == true }\n                        curNumber += \"${points[rightNeighbour]}\"\n                        curPoints += rightNeighbour!!\n                        curPoint = rightNeighbour!!\n                    }\n                    numbers += curNumber.toInt() to curPoints\n                }\n            }\n        }\n        return numbers\n    }\n}\n\nfun solve(string: String) = string.parse().allNumbersAdjacentToSymbol().sumOf { (n, _) -> n }\nfun solve2(string: String) = string.parse().allGears().sumOf { it.ratio }", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "dec9331d3c0976b4de09ce16fb8f3462e6f54f6e", "size": 2596, "name": "Advent-of-Code-2023", "license": "MIT License"}
{"path": "src/main/kotlin/days/Day14.kt", "owner": "poqueque", "repo_id": 430806840, "is_fork": false, "languages_distribution": "{\"Kotlin\": 101024}", "content": "package days\n\nimport kotlin.math.min\n\nclass Day14 : Day(14) {\n\n    override fun partOne(): Any {\n        var data = inputList[0]\n        val rules = mutableMapOf<String,String>()\n\n        inputList.forEach {\n            if (it.contains(\"->\")){\n                val (a,b) = it.split(\" -> \")\n                rules[a] = b\n            }\n        }\n\n        for (i in 1..10) {\n            var newData = \"\"\n            for  (c in data) {\n                if (newData.isNotEmpty()) {\n                    val r = \"\"+newData.last()+c\n                    val c2 = rules[r]\n                    if (c2 != null)\n                        newData += c2\n\n                }\n                newData += c\n            }\n            data = newData\n        }\n        val totals = mutableMapOf<Char, Long>()\n        for (c in data) {\n            totals[c] = (totals[c] ?: 0) + 1\n        }\n        var maxC = ' '\n        var minC = ' '\n        var max = 0L\n        var min = 100000000L\n        for (t  in totals.keys) {\n            if (totals[t]!! > max) {\n                max = totals[t]!!\n                maxC = t\n            }\n            if (totals[t]!! < min) {\n                min = totals[t]!!\n                minC = t\n            }\n        }\n        return max - min\n    }\n\n    override fun partTwo(): Any {\n        val data = inputList[0]\n        val rules = mutableMapOf<String,String>()\n        var pairs = mutableMapOf<String,Long>()\n        var chars = mutableMapOf<Char,Long>()\n\n        var pC = ' '\n        for (d in data) {\n            if (pC != ' ') {\n                pairs[\"\"+pC+d] = (pairs[\"\"+pC+d] ?: 0) +1\n            }\n            pC = d\n            chars[d] = (chars[d] ?: 0) +1\n        }\n\n        inputList.forEach {\n            if (it.contains(\"->\")){\n                val (a,b) = it.split(\" -> \")\n                rules[a] = b\n            }\n        }\n\n        for (i in 1..40) {\n            val newPairs: MutableMap<String, Long> = mutableMapOf()\n            pairs.forEach {\n                val r = rules[it.key]!!\n                newPairs[\"\"+it.key[0]+r] = (newPairs[\"\"+it.key[0]+r] ?: 0) + it.value\n                newPairs[\"\"+r+it.key[1]] = (newPairs[\"\"+r+it.key[1]] ?: 0) + it.value\n                chars[r[0]] = (chars[r[0]] ?: 0) + it.value\n            }\n            pairs = newPairs\n        }\n\n        var maxC = ' '\n        var minC = ' '\n        var max = 0L\n        var min = 1000000000000L\n        for (t  in chars.keys) {\n            if (chars[t]!! > max) {\n                max = chars[t]!!\n                maxC = t\n            }\n            if (chars[t]!! < min) {\n                min = chars[t]!!\n                minC = t\n            }\n        }\n        println(\"$maxC -> $max\")\n        println(\"$minC -> $min\")\n        return max - min\n    }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "4fa363be46ca5cfcfb271a37564af15233f2a141", "size": 2755, "name": "adventofcode2021", "license": "MIT License"}
{"path": "src/main/kotlin/dev/shtanko/algorithms/leetcode/SmallestSufficientTeam.kt", "owner": "ashtanko", "repo_id": 203993092, "is_fork": false, "languages_distribution": "{\"Kotlin\": 5856223, \"Shell\": 1168, \"Makefile\": 917}", "content": "/*\n * Copyright 2022 <NAME>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dev.shtanko.algorithms.leetcode\n\n/**\n * 1125. Smallest Sufficient Team\n * @see <a href=\"https://leetcode.com/problems/smallest-sufficient-team/\">Source</a>\n */\nfun interface SmallestSufficientTeam {\n    operator fun invoke(reqSkills: Array<String>, people: List<List<String>>): IntArray\n}\n\nclass SmallestSufficientTeamDFS : SmallestSufficientTeam {\n    private var sol: MutableList<Int> = ArrayList()\n\n    override operator fun invoke(reqSkills: Array<String>, people: List<List<String>>): IntArray {\n        val idx: MutableMap<String, Int> = HashMap()\n        var n = 0\n        for (s in reqSkills) idx[s] = n++ // skills are represented by 0, 1, 2....\n\n        val pe = IntArray(people.size)\n        for (i in pe.indices) {\n            for (p in people[i]) {\n                val skill = idx[p]!!\n                pe[i] += 1 shl skill\n            }\n        } // each person is transferred to a number, of which the bits of 1 means the guy has the skill\n\n        search(0, pe, ArrayList(), n)\n        val ans = IntArray(sol.size)\n        for (i in sol.indices) ans[i] = sol[i]\n        return ans\n    }\n\n    fun search(cur: Int, pe: IntArray, onesol: MutableList<Int>, n: Int) {\n        // when all bits are 1, all skills are covered\n        if (cur == (1 shl n) - 1) {\n            if (sol.isEmpty() || onesol.size < sol.size) {\n                sol = ArrayList(onesol)\n            }\n            return\n        }\n        if (sol.isNotEmpty() && onesol.size >= sol.size) {\n            return\n        }\n        var zeroBit = 0\n        while (cur shr zeroBit and 1 == 1) zeroBit++\n        for (i in pe.indices) {\n            val per = pe[i]\n            if (per shr zeroBit and 1 == 1) {\n                onesol.add(i) // when a person can cover a zero bit in the current number, we can add him\n                search(cur or per, pe, onesol, n)\n                onesol.removeAt(onesol.size - 1) // search in a backtracking way\n            }\n        }\n    }\n}\n", "issues": 4.0, "main_language": "Kotlin", "forks": 0, "stars": 19, "commit_sha": "776159de0b80f0bdc92a9d057c852b8b80147c11", "size": 2560, "name": "kotlab", "license": "Apache License 2.0"}
{"path": "src/Day02.kt", "owner": "robotfooder", "repo_id": 573164789, "is_fork": false, "languages_distribution": "{\"Kotlin\": 25811}", "content": "import Shape.*\nimport Result.*\nimport java.lang.IllegalArgumentException\n\nenum class Shape(val points: Int) { ROCK(1), PAPER(2), SCISSORS(3) }\nenum class Result(val points: Int) { WIN(6), DRAW(3), LOOSE(0) }\n\n\nfun main() {\n\n    fun mapToShape(shape: String): Shape {\n        return when (shape) {\n            \"X\", \"A\" -> ROCK\n            \"Y\", \"B\" -> PAPER\n            \"Z\", \"C\" -> SCISSORS\n            else -> {\n                throw IllegalArgumentException(\"Could not convert $shape to a shape\")\n            }\n        }\n    }\n\n    fun mapToResult(result: String): Result {\n        return when (result) {\n            \"X\" -> LOOSE\n            \"Y\" -> DRAW\n            \"Z\" -> WIN\n            else -> {\n                throw IllegalArgumentException(\"Could not convert $result to a result\")\n            }\n        }\n    }\n\n    fun calculateResult(theirHand: Shape, myHand: Shape): Result {\n\n        if (theirHand == myHand) {\n            return DRAW\n        }\n\n        return when (myHand) {\n            ROCK -> if (theirHand == SCISSORS) WIN else LOOSE\n            PAPER -> if (theirHand == ROCK) WIN else LOOSE\n            SCISSORS -> if (theirHand == PAPER) WIN else LOOSE\n        }\n\n    }\n\n    fun calculate(play: Pair<Shape, Shape>): Int {\n        val (theirGesture, myGesture) = play\n        val result = calculateResult(theirGesture, myGesture)\n\n        return myGesture.points + result.points\n\n    }\n\n\n\n\n    fun getShapeToMatchResult(strategy: Pair<Shape, Result>): Pair<Shape, Shape> {\n\n        val (theirShape, expectedResult) = strategy\n        val myShape = Shape.values().find { calculateResult(theirShape, it) == expectedResult }!!\n\n        return theirShape to myShape\n\n    }\n\n    fun part1(input: List<String>): Int {\n\n        return input\n            .map { it.split(\" \") }\n            .map { mapToShape(it[0]) to mapToShape(it[1]) }\n            .sumOf { calculate(it) }\n\n    }\n\n    fun part2(input: List<String>): Int {\n        return input\n            .map { it.split(\" \") }\n            .map { mapToShape(it[0]) to mapToResult(it[1]) }\n            .map { getShapeToMatchResult(it) }\n            .sumOf { calculate(it) }\n\n    }\n\n    fun runTest(expected: Int, day: String, testFunction: (List<String>) -> Int) {\n        val actual = testFunction(readInput(\"Day${day}_test\"))\n        check(expected == actual)\n        {\n            \"Failing for day $day, ${testFunction}. \" +\n                    \"Expected $expected but got $actual\"\n        }\n    }\n\n\n    val day = \"02\"\n\n    // test if implementation meets criteria from the description, like:\n    runTest(15, day, ::part1)\n    runTest(12, day, ::part2)\n\n\n    val input = readInput(\"Day$day\")\n    println(part1(input))\n    println(part2(input))\n}\n\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "9876a52ef9288353d64685f294a899a58b2de9b5", "size": 2711, "name": "aoc2022", "license": "Apache License 2.0"}
{"path": "src/leetcode_study_badge/algorithm/Day2.kt", "owner": "faniabdullah", "repo_id": 382893751, "is_fork": false, "languages_distribution": null, "content": "package leetcode_study_badge.algorithm\n\nclass Day2 {\n    fun sortedSquares(nums: IntArray): IntArray {\n        var right = nums.size - 1\n        var left = 0\n        val resultArray = IntArray(nums.size)\n        var insertPosition = nums.size - 1\n\n        while (left < right) {\n            val leftValue = nums[left] * nums[left]\n            val rightValue = nums[right] * nums[right]\n            if (leftValue > rightValue) {\n                resultArray[insertPosition] = leftValue\n                insertPosition--\n                left++\n            } else if (rightValue > leftValue) {\n                resultArray[insertPosition] = rightValue\n                insertPosition--\n                right--\n            } else if (rightValue == leftValue) {\n                resultArray[insertPosition] = rightValue\n                insertPosition--\n                resultArray[insertPosition] = leftValue\n                insertPosition--\n                right--\n                left++\n            }\n        }\n        println(resultArray.contentToString())\n        if (left == right) {\n            resultArray[insertPosition] = nums[left] * nums[left]\n        }\n\n        return resultArray\n    }\n\n    fun rotate(nums: IntArray, k: Int) {\n        for (i in 0 until k) {\n            var temp = nums[0]\n            nums[0] = nums[nums.size - 1]\n            for (a in 1 until nums.size) {\n                var swap = nums[a]\n                nums[a] = temp\n                temp = swap\n            }\n        }\n    }\n\n    fun rotateTwoPointer(nums: IntArray, k: Int) {\n\n        fun reverse(i: Int, j: Int) {\n            var i = i; var j = j\n\n            while (i < j) {\n                nums[i] = nums[j].also { nums[j] = nums[i] }\n                i++; j--\n            }\n        }\n\n        val N = nums.size\n        val k = k % N\n\n        reverse(0, N - 1)\n        reverse(0, k - 1)\n        reverse(k, N - 1)\n    }\n\n\n\n}\n\nfun main() {\n    println(Day2().sortedSquares(intArrayOf(-7, -3, 2, 3, 11)).contentToString())\n    val rotateArray = intArrayOf(1, 2, 3, 4, 5, 6, 7)\n    println(rotateArray.contentToString())\n    Day2().rotateTwoPointer(rotateArray, 3)\n    println(rotateArray.contentToString())\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 6, "commit_sha": "ecf14fe132824e944818fda1123f1c7796c30532", "size": 2185, "name": "dsa-kotlin", "license": "MIT License"}
{"path": "kotlin/2306-naming-a-company.kt", "owner": "neetcode-gh", "repo_id": 331360188, "is_fork": false, "languages_distribution": "{\"JavaScript\": 473974, \"Kotlin\": 418778, \"Java\": 372274, \"C++\": 353616, \"C\": 254169, \"Python\": 207536, \"C#\": 188620, \"Rust\": 155910, \"TypeScript\": 144641, \"Go\": 131749, \"Swift\": 111061, \"Ruby\": 44099, \"Scala\": 26287, \"Dart\": 9750}", "content": "class Solution {\n    fun distinctNames(ideas: Array<String>): Long {\n        \n        val firstToSuffix = Array(26) { hashSetOf<String>() }\n        var res = 0L\n\n        ideas.forEach { \n            firstToSuffix[it[0] - 'a'].add(it.substring(1, it.length))\n        }\n\n        for (i in 0 until 26) {\n            for (j in i until 26) {\n                val common = firstToSuffix[i].intersect(firstToSuffix[j]).size\n                val mapI = firstToSuffix[i].size - common\n                val mapJ = firstToSuffix[j].size - common\n                res += (mapI * mapJ) * 2\n            }\n        }\n\n        return res\n    }\n}\n\n// without using kotlins intersect() funtions\nclass Solution {\n    fun distinctNames(ideas: Array<String>): Long {\n        \n        val firstToSuffix = Array(26) { hashSetOf<String>() }\n        var res = 0L\n\n        ideas.forEach { \n            firstToSuffix[it[0] - 'a'].add(it.substring(1, it.length))\n        }\n\n        for (i in 0 until 26) {\n            for (j in i until 26) {\n\n                var common = 0\n                for(wordA in firstToSuffix[i]) {\n                    if(wordA in firstToSuffix[j]) common++\n                }\n                val mapI = firstToSuffix[i].size - common\n                val mapJ = firstToSuffix[j].size - common\n                res += (mapI * mapJ) * 2\n            }\n        }\n\n        return res\n    }\n}\n", "issues": 337.0, "main_language": "JavaScript", "forks": 2004, "stars": 4367, "commit_sha": "0cf38f0d05cd76f9e96f08da22e063353af86224", "size": 1376, "name": "leetcode", "license": "MIT License"}
{"path": "src/main/kotlin/days/Day07.kt", "owner": "julia-kim", "repo_id": 569976303, "is_fork": false, "languages_distribution": null, "content": "package days\n\nimport readInput\n\nfun main() {\n    tailrec fun sumFiles(\n        filesystem: MutableList<Directory>,\n        children: List<String>,\n        sum: Long\n    ): Long {\n        var total = sum\n        if (children.isEmpty()) return total\n        val dirs = children.map { child ->\n            filesystem.first { it.name == child }\n        }\n        dirs.forEach { dir ->\n            total += dir.files.sumOf { it.size }\n            sumFiles(filesystem, dir.childrenDirectories, total)\n        }\n        return total\n    }\n\n\n    fun part1(input: List<String>): Long {\n        val filesystem: MutableList<Directory> = mutableListOf()\n        var currentDirectory = \"\"\n        input.forEach {\n            when {\n                it.startsWith(\"$ ls\") -> return@forEach\n                it.startsWith(\"$ cd\") -> {\n                    val dir = it.split(\" \").last()\n                    if (dir == \"/\" && filesystem.firstOrNull() == null) filesystem.add(\n                        Directory(\n                            \"/\",\n                            parentDirectory = \"/\",\n                            isHomeDirectory = true\n                        )\n                    )\n                    val i = filesystem.indexOfFirst { it.name == currentDirectory }\n                    currentDirectory = if (dir == \"..\") filesystem[i].parentDirectory else dir\n                }\n\n                it.startsWith(\"dir\") -> {\n                    val directoryName = it.split(\" \").last()\n                    val current = filesystem.first { it.name == currentDirectory }\n                    current.childrenDirectories.add(directoryName)\n                    val i = filesystem.indexOfFirst { it.name == directoryName }\n                    if (i == -1) {\n                        filesystem.add(Directory(directoryName, parentDirectory = currentDirectory))\n                    } else {\n                        filesystem[i]\n                    }\n                }\n\n                else -> {\n                    val i = filesystem.indexOfFirst { it.name == currentDirectory }\n                    val dir = filesystem[i]\n                    val (size, name) = it.split(\" \")\n                    dir.files.add(File(name, size.toLong()))\n                }\n            }\n        }\n        filesystem.forEach { d ->\n            d.totalSize = sumFiles(\n                filesystem,\n                d.childrenDirectories,\n                d.files.sumOf { it.size })\n        }\n        println(filesystem)\n        return filesystem.filter { it.totalSize <= 100000 }.sumOf { it.totalSize }\n    }\n\n    fun part2(input: List<String>): Int {\n        return 0\n    }\n\n    val testInput = readInput(\"Day07_test\")\n    check(part1(testInput) == 95437L)\n    check(part2(testInput) == 0)\n\n    val input = readInput(\"Day07\")\n    println(part1(input))\n    println(part2(input))\n}\n\ndata class File(var name: String? = null, var size: Long = 0)\ndata class Directory(\n    var name: String = \"\",\n    var files: MutableList<File> = mutableListOf(),\n    var parentDirectory: String = \"\",\n    var childrenDirectories: MutableList<String> = mutableListOf(),\n    var isHomeDirectory: Boolean = false,\n    var totalSize: Long = 0L\n)", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "65188040b3b37c7cb73ef5f2c7422587528d61a4", "size": 3182, "name": "advent-of-code-2022", "license": "Apache License 2.0"}
{"path": "src/Day05.kt", "owner": "kuolemax", "repo_id": 573740719, "is_fork": false, "languages_distribution": "{\"Kotlin\": 21104}", "content": "import java.util.*\nimport kotlin.collections.ArrayList\n\nfun main() {\n\n    fun part1(input: List<String>): String {\n        val (startRow, stackList) = parseStacks(input)\n        val moveRows = input.subList(startRow, input.size)\n        return moveCargo(moveRows, stackList)\n    }\n\n    fun part2(input: List<String>): String {\n        val (startRow, stackList) = parseStacks(input)\n        val moveRows = input.subList(startRow, input.size)\n        return multiMoveCargo(moveRows, stackList)\n    }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day05_test\")\n    check(part1(testInput) == \"CMZ\")\n    check(part2(testInput) == \"MCD\")\n\n    val input = readInput(\"Day05\")\n    println(part1(input))\n    println(part2(input))\n}\n\nprivate fun parseStacks(input: List<String>): Pair<Int, MutableList<MutableList<String>>> {\n    // 找到 move 所在行，索引即 Cargo 所在行数\n    val moveRow = input.first { it -> it.startsWith(\"move\") }\n    val moveIndex = input.indexOf(moveRow)\n\n    // 前 moveIndex - 2 是矩阵\n    val columNumOfRow = moveIndex - 2\n    val matrix = input.subList(0, columNumOfRow)\n\n    // 找到 move 前倒数第二行，提取数字，数字个数即 Stack 数\n    val columnNumStr = input[columNumOfRow]\n    val stackNum = (columnNumStr.length + 2) / 4\n\n    // 每行第 2 + (col - 1) * 4 个数字即 Cargo 存储的值\n    val stackList = ArrayList<Stack<String>>()\n\n    (0 until stackNum).forEach { col ->\n        matrix.forEach { row ->\n            val index = 2 + col * 4\n            val cargoValue = row.substring(index - 1, index)\n\n            if (cargoValue.isNotBlank()) {\n                if (stackList.isEmpty() || stackList.size < col + 1) {\n                    stackList.add(Stack())\n                }\n                stackList[col].add(0, cargoValue)\n            }\n        }\n    }\n\n    return moveIndex to stackList.toMutableList()\n}\n\nprivate fun moveCargo(moveList: List<String>, stacks: MutableList<MutableList<String>>): String {\n    // 提取移动的起始点和个数\n    val moveOperationList = parseMoveOperations(moveList)\n    moveOperationList.forEach { (moveNum, popIndex, addIndex) ->\n        (0 until moveNum).forEach { _ ->\n            val popValue = stacks[popIndex - 1].removeLast()\n            stacks[addIndex - 1].add(popValue)\n        }\n    }\n\n    return stacks.joinToString(\"\") { it.last() }\n}\n\nprivate fun multiMoveCargo(moveList: List<String>, stacks: MutableList<MutableList<String>>): String {\n    // 提取移动的起始点和个数\n    val moveOperationList = parseMoveOperations(moveList)\n    moveOperationList.forEach { (moveNum, popIndex, addIndex) ->\n        val popStack = stacks[popIndex - 1]\n        val popCargos = popStack.subList(popStack.size - moveNum, popStack.size)\n        stacks[addIndex - 1].addAll(popCargos)\n        stacks[popIndex - 1] = popStack.subList(0, popStack.size - moveNum)\n    }\n\n    return stacks.joinToString(\"\") { it.last() }\n}\n\nprivate fun parseMoveOperations(moveList: List<String>): List<Triple<Int, Int, Int>> {\n    val regexPattern = Regex(\"move (\\\\d+) from (\\\\d+) to (\\\\d+)\")\n    val moveOperationList = moveList.map { row ->\n        val find = regexPattern.find(row)\n        Triple(find!!.groupValues[1].toInt(), find.groupValues[2].toInt(), find.groupValues[3].toInt())\n    }\n    return moveOperationList\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "3045f307e24b6ca557b84dac18197334b8a8a9bf", "size": 3370, "name": "aoc2022--kotlin", "license": "Apache License 2.0"}
{"path": "src/day9/puzzle09.kt", "owner": "brendencapps", "repo_id": 572821792, "is_fork": false, "languages_distribution": "{\"Kotlin\": 70597}", "content": "package day9\n\nimport Puzzle\nimport PuzzleInput\nimport java.io.File\nimport kotlin.math.abs\n\nfun day9Puzzle() {\n\n    Day9PuzzleSolution().solve(Day9PuzzleInput(\"inputs/day9/example.txt\", 2, 13))\n    Day9PuzzleSolution().solve(Day9PuzzleInput(\"inputs/day9/input.txt\", 2, 6271))\n    Day9PuzzleSolution().solve(Day9PuzzleInput(\"inputs/day9/example.txt\", 10, 1))\n    Day9PuzzleSolution().solve(Day9PuzzleInput(\"inputs/day9/example2.txt\", 10, 36))\n    Day9PuzzleSolution().solve(Day9PuzzleInput(\"inputs/day9/input.txt\", 10, 2458))\n}\n\nclass Day9PuzzleInput(val input: String, numKnots: Int, expectedResult: Int? = null) : PuzzleInput<Int>(expectedResult) {\n    val moves = File(input).readLines()\n    val pointsVisited = HashMap<Pair<Int, Int>, Boolean>()\n    private val knots = Array(numKnots) {\n        Pair(0, 0)\n    }\n\n    private fun getKnot(head: Pair<Int, Int>, tail: Pair<Int, Int>): Pair<Int, Int> {\n        val x = head.first - tail.first\n        val y = head.second - tail.second\n        if(abs(x) > 1 || abs(y) > 1) {\n            return Pair(tail.first + x.coerceIn(-1, 1), tail.second + y.coerceIn(-1, 1))\n        }\n        return tail\n    }\n\n    private fun moveHead(newHead: Pair<Int, Int>) {\n        knots[0] = newHead\n        for(i in 1 until knots.size) {\n            knots[i] = getKnot(knots[i-1], knots[i])\n        }\n        pointsVisited[knots.last()] = true\n    }\n    fun moveHead(xOffset: Int, yOffset: Int, amount: Int) {\n        for(move in 1 .. amount) {\n            moveHead(Pair(knots[0].first + xOffset, knots[0].second + yOffset))\n        }\n    }\n}\n\nclass Day9PuzzleSolution : Puzzle<Int, Day9PuzzleInput>() {\n    override fun solution(input: Day9PuzzleInput): Int {\n        input.pointsVisited[Pair(0, 0)] = true\n        input.moves.forEach { move ->\n            val moveParts = move.split(\" \")\n            val direction = moveParts[0]\n            val amount = moveParts[1].toInt()\n            when(direction) {\n                \"U\" -> input.moveHead(0, 1, amount)\n                \"D\" -> input.moveHead(0, -1, amount)\n                \"L\" -> input.moveHead(-1, 0, amount)\n                \"R\" -> input.moveHead(1, 0, amount)\n            }\n        }\n\n        return input.pointsVisited.size\n    }\n\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "00e9bd960f8bcf6d4ca1c87cb6e8807707fa28f3", "size": 2283, "name": "aoc_2022", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/com/hopkins/aoc/day21/main.kt", "owner": "edenrox", "repo_id": 726934488, "is_fork": false, "languages_distribution": "{\"Kotlin\": 88215}", "content": "package com.hopkins.aoc.day21\n\nimport com.hopkins.aoc.day17.Point\nimport java.io.File\n\nconst val debug = true\nconst val part = 1\n\n/** Advent of Code 2023: Day 21 */\nfun main() {\n    // Step 1: Read the file input\n    val lines: List<String> = File(\"input/input21-ex1.txt\").readLines()\n    if (debug) {\n        println(\"Step 1: Read file\")\n        println(\"=======\")\n        println(\"  num lines: ${lines.size}\")\n    }\n\n    // Step 2: Build the map\n    var startPoint: Point = Point.of(-1, -1)\n    val mapHeight = lines.size\n    val mapWidth = lines[0].length\n    val mapSize = Point.of(mapWidth, mapHeight)\n    val rocks: Set<Point> = lines.flatMapIndexed {y, line ->\n        line.mapIndexedNotNull { x, c ->\n            if (c == '#') {\n                Point.of(x, y)\n            } else {\n                if (c == 'S') {\n                    startPoint = Point.of(x, y)\n                }\n                null\n            }\n        }\n    }.toSet()\n    require(startPoint.x >= 0)\n    require(startPoint.y >= 0)\n\n    if (debug) {\n        println(\"Step 2: Build the map\")\n        println(\"=======\")\n        println(\"  map size: $mapSize\")\n        println(\"  start: $startPoint\")\n        println(\"  num rocks: ${rocks.size}\")\n    }\n\n    var current = setOf(startPoint)\n    for (i in 1..50) {\n        val next =\n            current.flatMap { point ->\n                directions.map { direction ->\n                    point.add(direction) }}\n                .map { point ->\n                    if (point.x == -1) {\n                        Point.of(point.x + mapWidth, point.y)\n                    } else if (point.y == -1) {\n                        Point.of(point.x, point.y + mapWidth)\n                    } else if (point.x == mapWidth) {\n                        Point.of(0, point.y)\n                    } else if (point.y == mapHeight) {\n                        Point.of(point.x, 0)\n                    } else {\n                        point\n                    }\n                }\n                .filterNot { point -> rocks.contains(point) }\n                .toSet()\n        println(\"Step $i:\")\n        printMap(mapSize, rocks, next)\n        current = next\n    }\n    println(\"Num Plots: ${current.size}\")\n}\n\nfun printMap(mapSize: Point, rocks: Set<Point>, current: Set<Point>) {\n    for (y in 0 until mapSize.y) {\n        for (x in 0 until mapSize.x) {\n            val point = Point.of(x, y)\n            if (rocks.contains(point)) {\n                print(\"#\")\n            } else if (current.contains(point)) {\n                print(\"O\")\n            } else {\n                print(\".\")\n            }\n        }\n        println()\n    }\n}\n\nval directions = listOf(\n    Point.of(-1, 0),\n    Point.of(1, 0),\n    Point.of(0, -1),\n    Point.of(0, 1)\n)\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "45dce3d76bf3bf140d7336c4767e74971e827c35", "size": 2741, "name": "aoc2023", "license": "MIT License"}
{"path": "src/main/kotlin/aoc2023/day16/day16Solver.kt", "owner": "Advent-of-Code-Netcompany-Unions", "repo_id": 726531711, "is_fork": false, "languages_distribution": "{\"Kotlin\": 94973}", "content": "package aoc2023.day16\n\nimport lib.*\n\nsuspend fun main() {\n    setupChallenge().solveChallenge()\n}\n\nfun setupChallenge(): Challenge<Array<Array<Char>>> {\n    return setup {\n        day(16)\n        year(2023)\n\n        //input(\"example.txt\")\n\n        parser {\n            it.readLines().get2DArrayOfColumns()\n        }\n\n        partOne {\n            val res = it.traceBeam(Beam(0 to 0, CardinalDirection.East))\n            res.distinctBy { it.pos }.size.toString()\n        }\n\n        partTwo {\n            val dimensions = it.size - 1 to it.first().size - 1\n            val verticalRes = it.indices.flatMap {\n                listOf(\n                    Beam(it to 0, CardinalDirection.South),\n                    Beam(it to dimensions.second, CardinalDirection.North)\n                )\n            }\n            val horizontalRes = it.first().indices.flatMap {\n                listOf(\n                    Beam(0 to it, CardinalDirection.East),\n                    Beam(dimensions.first to it, CardinalDirection.West)\n                )\n            }\n            (verticalRes + horizontalRes).maxOf { beam -> it.traceBeam(beam).distinctBy { it.pos }.size }.toString()\n        }\n    }\n}\n\ndata class Beam(var pos: Pair<Int, Int>, var direction: CardinalDirection)\n\nfun Beam.move(): Beam {\n    return Beam(pos.adjacent(this.direction), this.direction)\n}\n\nfun Beam.withDirection(direction: CardinalDirection): Beam {\n    return Beam(this.pos, direction)\n}\n\nfun Beam.key(): String {\n    return \"${this.pos.first}:${this.pos.second}-${this.direction}\"\n}\n\nval solutions = mutableMapOf<String, Set<Beam>>()\n\nfun Array<Array<Char>>.traceBeam(beam: Beam): Set<Beam> {\n    val toVisit = mutableSetOf(beam)\n    val res = mutableSetOf<Beam>()\n    while (toVisit.isNotEmpty()) {\n\n        val next = toVisit.first()\n        toVisit.remove(next)\n\n        /*if (solutions.containsKey(next.key())) {\n            res.addAll(solutions[next.key()]!!)\n        } else*/ if (isValidCoord(next.pos) && next !in res) {\n            res.add(next)\n\n            when (this[next.pos.first][next.pos.second]) {\n                '.' -> toVisit.add(next.move())\n                '\\\\' -> {\n                    next.direction = when (next.direction) {\n                        CardinalDirection.North -> CardinalDirection.West\n                        CardinalDirection.East -> CardinalDirection.South\n                        CardinalDirection.West -> CardinalDirection.North\n                        CardinalDirection.South -> CardinalDirection.East\n                    }\n                    toVisit.add(next.move())\n                }\n\n                '/' -> {\n                    next.direction = when (next.direction) {\n                        CardinalDirection.North -> CardinalDirection.East\n                        CardinalDirection.West -> CardinalDirection.South\n                        CardinalDirection.East -> CardinalDirection.North\n                        CardinalDirection.South -> CardinalDirection.West\n                    }\n                    toVisit.add(next.move())\n                }\n\n                '|' -> {\n                    when (next.direction) {\n                        CardinalDirection.West, CardinalDirection.East -> {\n                            toVisit.add(next.withDirection(CardinalDirection.North))\n                            toVisit.add(next.withDirection(CardinalDirection.South))\n                        }\n\n                        else -> toVisit.add(next.move())\n                    }\n                }\n\n                '-' -> {\n                    when (next.direction) {\n                        CardinalDirection.South, CardinalDirection.North -> {\n                            toVisit.add(next.withDirection(CardinalDirection.East))\n                            toVisit.add(next.withDirection(CardinalDirection.West))\n                        }\n\n                        else -> toVisit.add(next.move())\n                    }\n                }\n            }\n        }\n    }\n    //solutions[beam.key()] = res\n    return res\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "a77584ee012d5b1b0d28501ae42d7b10d28bf070", "size": 4018, "name": "AoC-2023-DDJ", "license": "MIT License"}
{"path": "src/Day14.kt", "owner": "frozbiz", "repo_id": 573457870, "is_fork": false, "languages_distribution": "{\"Kotlin\": 124645}", "content": "const val rock = 1\nconst val sand = 2\n\nval Grid.maxY: Int get() {\n    return this.grid.keys.max()\n}\n\nfun main() {\n\n    fun Grid.addSandAt(point: Point, limit: Int? = null, limitIsFloor: Boolean = false): Boolean {\n        if (this[point] != 0) return false\n        var x = point.x\n        var lastY = (limit ?: maxY) - 1\n        for (y in (point.y..lastY)) {\n            val nextY = y + 1\n            if (this[x,nextY] == 0) continue\n            if (this[x-1,nextY] == 0) {\n                x=x-1\n                continue\n            }\n            if (this[x+1,nextY] == 0){\n                x=x+1\n                continue\n            }\n            this[x,y] = sand\n            return true\n        }\n\n        if (limitIsFloor) {\n            this[x,lastY] = sand\n            return true\n        }\n        return false\n    }\n\n    fun part1(input: List<String>): Int {\n        val cave = Grid()\n        for (line in input) {\n            val points = line.split(\"->\").map { Point.fromString(it) }\n            for (ix in 1 until points.size) {\n                val (pt1, pt2) = points.subList(ix-1, ix+1)\n                (pt1 to pt2).forEach { cave[it] = rock }\n            }\n        }\n\n        var count = 0\n        val limit = cave.maxY\n        while (cave.addSandAt(Point(500,0),limit)) ++count\n\n        return count\n    }\n\n    fun part2(input: List<String>): Int {\n        val cave = Grid()\n        for (line in input) {\n            val points = line.split(\"->\").map { Point.fromString(it) }\n            for (ix in 1 until points.size) {\n                val (pt1, pt2) = points.subList(ix-1, ix+1)\n                (pt1 to pt2).forEach { cave[it] = rock }\n            }\n        }\n\n        var count = 0\n        val limit = cave.maxY + 2\n        while (cave.addSandAt(Point(500,0), limit, true)) ++count\n\n        return count\n    }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = listOf(\n        \"498,4 -> 498,6 -> 496,6\\n\",\n        \"503,4 -> 502,4 -> 502,9 -> 494,9\\n\",\n    )\n\n    check(part1(testInput) == 24)\n    check(part2(testInput) == 93)\n\n    val input = readInput(\"day14\")\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "4feef3fa7cd5f3cea1957bed1d1ab5d1eb2bc388", "size": 2176, "name": "2022-aoc-kotlin", "license": "Apache License 2.0"}
{"path": "src/Day02.kt", "owner": "0xBuro", "repo_id": 572308139, "is_fork": false, "languages_distribution": "{\"Kotlin\": 4929}", "content": "fun main() {\n\n    fun encryptedStrategyGuide(input: String): List<List<String>> {\n        return input.replace(\" \", \"\").split(\"\\n\")\n            .map { it.lines() }\n    }\n\n    fun getShapeWeight(shape: Char): Int {\n        if(shape == 'X') {\n            return 1 //rock\n        }\n        if(shape == 'Y') {\n            return 2 //paper\n        }\n        if(shape == 'Z') {\n            return 3 //scissors\n        }\n        return 0\n    }\n\n    fun part1(combination: String): Int {\n        val pairs = encryptedStrategyGuide(combination)\n        var combinedCases = arrayOf<Int>()\n\n        for (i in pairs) {\n            if (i.contains(\"BX\") || i.contains(\"CY\") || i.contains(\"AZ\")) {\n                combinedCases += (0 + getShapeWeight(i[0][1])) //lose + shape weight\n            }\n            if (i.contains(\"AX\") || i.contains(\"BY\") || i.contains(\"CZ\")) {\n                combinedCases += (3 + getShapeWeight(i[0][1])) //draw + shape weight\n            }\n            if (i.contains(\"CX\") || i.contains(\"AY\") || i.contains(\"BZ\")) {\n                combinedCases += (6 + getShapeWeight(i[0][1])) //win + shape weight\n            }\n        }\n        return combinedCases.sum()\n    }\n\n\n    fun getCounterWeight(pair: String): Int {\n        if(pair == \"AY\" || pair == \"BX\" || pair == \"CZ\") {\n            return 1 //rock\n        }\n        if(pair == \"AZ\" || pair == \"BY\" || pair == \"CX\") {\n            return 2 //paper\n        }\n        if(pair == \"AX\" || pair == \"BZ\" || pair == \"CY\") {\n            return 3 //scissors\n        }\n        return 0\n    }\n\n    fun part2(combination: String): Int {\n        val pairs = encryptedStrategyGuide(combination)\n        var combinedCases = arrayOf<Int>()\n\n        for (i in pairs) {\n            if (i.contains(\"AX\") || i.contains(\"BX\") || i.contains(\"CX\")) {\n                combinedCases += (0 + getCounterWeight(i[0])) //counter shape to lose\n            }\n            if (i.contains(\"AY\") || i.contains(\"BY\") || i.contains(\"CY\")) {\n                combinedCases += (3 + getCounterWeight(i[0])) //counter shape to draw\n            }\n            if (i.contains(\"AZ\") || i.contains(\"BZ\") || i.contains(\"CZ\")) {\n                combinedCases += (6 + getCounterWeight(i[0])) //counter shape to win\n            }\n        }\n        return combinedCases.sum()\n    }\n\n        //val testInput = readInput(\"esg\")\n        //check(combinationOfCases(testInput) == 15)\n        //check(indicatedCase(testInput) == 12)\n\n        val input = readInput(\"esg\")\n        println(part1(input))\n        println(part2(input))\n    }", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "c05c4db78e24fc36f6f112bc1e8cf24ad5fd7698", "size": 2545, "name": "Advent-of-Kotlin", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/Day13.kt", "owner": "chjaeggi", "repo_id": 728738815, "is_fork": false, "languages_distribution": "{\"Kotlin\": 87254}", "content": "import utils.Stack\nimport utils.execFileByLineIndexed\nimport utils.numberOfLinesPerFile\nimport utils.stackOf\n\nclass Day13 {\n\n    fun solveFirst(): Int {\n        // could have used kotlin.collections.ArrayDeque instead of my own Stack implementation :/\n        // with:\n        // Stack.push = addLast()\n        // Stack.pop = removeLast()\n        val (patternRows, patternCols) = createInput()\n\n        var rowSolution = 0\n        var colSolution = 0\n\n        patternRows.forEach { rowPattern ->\n            var stackRow = Stack<String>()\n            var searchIndexRow = -1\n            var possibleFindRow: Int? = null\n            var isPushingRow = true\n            for (p in rowPattern) {\n                searchIndexRow++\n                if (stackRow.peek() == p) {\n                    stackRow.pop()\n                    if (possibleFindRow == null) {\n                        possibleFindRow = searchIndexRow\n                    }\n                    isPushingRow = false\n                    if (stackRow.isEmpty) {\n                        searchIndexRow = possibleFindRow\n                        break\n                    }\n                } else {\n                    if (!isPushingRow) {\n                        stackRow = stackOf()\n                        possibleFindRow = null\n                    }\n                    stackRow.push(p)\n                    isPushingRow = true\n                }\n            }\n            if (!isPushingRow) {\n                rowSolution += (possibleFindRow ?: searchIndexRow) * 100\n            }\n        }\n\n        patternCols.forEach { patternCol ->\n            var stackCol = Stack<String>()\n            var searchIndexCol = -1\n            var possibleFindCol: Int? = null\n            var isPushingCol = true\n            for (p in patternCol) {\n                searchIndexCol++\n                if (stackCol.peek() == p) {\n                    stackCol.pop()\n                    if (possibleFindCol == null) {\n                        possibleFindCol = searchIndexCol\n                    }\n                    isPushingCol = false\n                    if (stackCol.isEmpty) {\n                        searchIndexCol = possibleFindCol\n                        break\n                    }\n                } else {\n                    if (!isPushingCol) {\n                        stackCol = stackOf()\n                        possibleFindCol = null\n                    }\n                    stackCol.push(p)\n                    isPushingCol = true\n                }\n            }\n            if (!isPushingCol) {\n                colSolution += possibleFindCol ?: searchIndexCol\n            }\n        }\n        return rowSolution + colSolution\n    }\n\n    fun solveSecond(): Int {\n        val (patternRows, patternCols) = createInput()\n        var rowSolution = 0\n        var colSolution = 0\n\n        patternRows.forEach { rowPattern ->\n            rowSolution += findMirror(rowPattern) * 100\n        }\n\n        patternCols.forEach { colPattern ->\n            colSolution += findMirror(colPattern)\n        }\n\n        return rowSolution + colSolution\n    }\n\n    private fun findMirror(pattern: List<String>): Int {\n        val maxNumber = pattern.size / 2 + 1\n\n        // from top to bottom\n        for (i in 1..maxNumber) {\n            val arr1 = pattern.take(i)\n            val endIndex = if (2 * i >= pattern.size - 1) {\n                pattern.size - 1\n            } else {\n                2 * i\n            }\n            val arr2 = pattern.subList(i, endIndex).reversed()\n            if (diffBy(arr1, arr2) == 1) {\n                return i\n            }\n        }\n\n        for (i in 1..maxNumber) {\n            val arr1 = pattern.reversed().take(i)\n            val endIndex = if (2 * i >= pattern.size - 1) {\n                pattern.size - 1\n            } else {\n                2 * i\n            }\n            val arr2 = pattern.reversed().subList(i, endIndex).reversed()\n            if (diffBy(arr1, arr2) == 1) {\n                return (pattern.size - i)\n            }\n        }\n        return 0\n    }\n\n    private fun diffBy(arr1: List<String>, arr2: List<String>): Int {\n        var res = 0\n        for (i in 0..arr2.lastIndex) {\n            res += unCommonChars(arr1[i], arr2[i])\n        }\n        return res\n    }\n\n    private fun unCommonChars(s1: String, s2: String): Int {\n        var count = 0\n        for (i in s1.indices) {\n            count += if (s1[i] == s2[i]) 1 else 0\n        }\n        return s1.length - count\n    }\n}\n\nprivate fun createInput(): Pair<List<List<String>>, List<List<String>>> {\n    val patternRows = mutableListOf<List<String>>()\n    val patternCols = mutableListOf<List<String>>()\n    val pattern = mutableListOf<String>()\n    execFileByLineIndexed(13) { it, index ->\n        if (it == \"\") {\n            patternRows.add(pattern.toList())\n            pattern.clear()\n        } else {\n            pattern.add(it)\n        }\n        if (index >= (numberOfLinesPerFile(13) - 1)) {\n            patternRows.add(pattern.toList())\n            pattern.clear()\n        }\n    }\n    for (p in patternRows) {\n        val tempList = mutableListOf<String>()\n        for (letterIndex in 0..p[0].lastIndex) {\n            val temp = mutableListOf<Char>()\n            for (word in p) {\n                temp.add(word[letterIndex])\n            }\n            tempList.add(String(temp.toCharArray()))\n        }\n        patternCols.add(tempList)\n    }\n    return Pair(patternRows, patternCols)\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 1, "stars": 1, "commit_sha": "a6522b7b8dc55bfc03d8105086facde1e338086a", "size": 5441, "name": "aoc2023", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/io/github/trustedshops_public/spring_boot_starter_keycloak_path_based_resolver/configuration/holder.kt", "owner": "trustedshops-public", "repo_id": 524078409, "is_fork": false, "languages_distribution": "{\"Kotlin\": 22803}", "content": "package io.github.trustedshops_public.spring_boot_starter_keycloak_path_based_resolver.configuration\n\nimport org.keycloak.adapters.KeycloakDeployment\nimport java.lang.IllegalArgumentException\n\nclass MatcherConfiguration(\n    private val parent: KeycloakPathContextConfigurationHolder,\n    private val antPatterns: Array<out String>\n) {\n    /**\n     * Configure keycloak deployment for the given antPatterns\n     *\n     * @see org.keycloak.adapters.KeycloakDeployment\n     */\n    fun useKeycloakDeployment(keycloakDeployment: KeycloakDeployment): KeycloakPathContextConfigurationHolder {\n        antPatterns\n            .associateWith { keycloakDeployment }\n            .forEach { (pattern, deployment) ->\n                if (parent.mapping.containsKey(pattern)) {\n                    throw IllegalArgumentException(\"pattern '${pattern}' can not be assigned twice\")\n                }\n\n                parent.mapping[pattern] = deployment\n            }\n        parent.mapping.putAll(antPatterns.associateWith { keycloakDeployment })\n        return parent\n    }\n}\n\n/**\n * Configuration allowing to map given ant patterns to keycloak deployments\n */\nclass KeycloakPathContextConfigurationHolder {\n    /**\n     * Mapping, sorted by the longest string being the first in the map, so iteration always uses the most specific\n     * matcher first\n     */\n    internal val mapping = sortedMapOf<String, KeycloakDeployment>(compareBy<String> { -it.length }.thenBy { it })\n\n    /**\n     * Configure context for given ant path matcher\n     *\n     * For more information check AntPathMatcher\n     * @see org.springframework.util.AntPathMatcher\n     */\n    fun antMatchers(vararg antPatterns: String): MatcherConfiguration = MatcherConfiguration(this, antPatterns)\n}\n", "issues": 2.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "451885d836f596ae1423b78d9a7a873552b42e18", "size": 1752, "name": "spring-boot-starter-keycloak-path-based-resolver", "license": "MIT License"}
{"path": "src/main/kotlin/io/tree/RearrangeTree.kt", "owner": "jffiorillo", "repo_id": 138075067, "is_fork": false, "languages_distribution": "{\"Kotlin\": 434399, \"Java\": 14529, \"Shell\": 465}", "content": "package io.tree\n\nimport io.models.TreeNode\nimport io.utils.runTests\nimport java.util.*\n\n// https://leetcode.com/problems/increasing-order-search-tree/\nclass RearrangeTree {\n\n  fun executeRecursive(input: TreeNode?, acc: TreeNode? = null): TreeNode? = when (input) {\n    null -> acc\n    else -> {\n      executeRecursive(input.right, executeRecursive(input.left, acc)?.also {\n        var current = it\n        while (current.right != null) current = current.right!!\n        current.right = TreeNode(input.`val`)\n      } ?: TreeNode(input.`val`))\n    }\n  }\n\n  fun executeIterative(input: TreeNode?): TreeNode? {\n    var root: TreeNode? = null\n    var current = input\n    var last: TreeNode? = null\n    val stack = LinkedList<TreeNode>()\n    while (current != null || stack.isNotEmpty()) {\n      while (current != null) {\n        stack.push(current)\n        current = current.left\n      }\n      if (stack.isNotEmpty()) {\n        val item = stack.pop()\n        TreeNode(item.`val`).let { newNode ->\n          if (last == null) {\n            root = newNode\n            last = newNode\n          } else {\n            last!!.right = newNode\n            last = newNode\n          }\n        }\n        current = item?.right\n      }\n    }\n    return root\n  }\n}\n\nfun main() {\n  runTests(\n      listOf(\n          Pair(TreeNode(5,\n              left = TreeNode(3,\n                  left = TreeNode(2, left = TreeNode(1)),\n                  right = TreeNode(4)),\n              right = TreeNode(6,\n                  right = TreeNode(8, left = TreeNode(7), right = TreeNode(9)))),\n              TreeNode(1,\n                  right = TreeNode(2,\n                      right = TreeNode(3,\n                          right = TreeNode(4,\n                              right = TreeNode(5,\n                                  right = TreeNode(6,\n                                      right = TreeNode(7,\n                                          right = TreeNode(8,\n                                              right = TreeNode(9)))))))))\n          )\n      )\n  ) { (input, value) -> Pair(value, RearrangeTree().executeRecursive(input)) }\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "f093c2c19cd76c85fab87605ae4a3ea157325d43", "size": 2110, "name": "coding", "license": "MIT License"}
{"path": "src/twentytwentytwo/day16/Day16.kt", "owner": "colinmarsch", "repo_id": 571723956, "is_fork": false, "languages_distribution": "{\"Kotlin\": 65403, \"Python\": 6148}", "content": "package twentytwentytwo.day16\n\nimport twentytwentytwo.day12.Graph\nimport readInput\n\nfun main() {\n    data class ValveNode(\n        val id: String,\n        val flowRate: Int,\n        val neighbours: MutableSet<Pair<String, Int>>,\n    )\n\n    val graph = mutableMapOf<String, ValveNode>()\n    var availableMinutes = 30\n    val startValve by lazy { graph[\"AA\"]!! }\n\n    fun createGraph(input: List<String>): ValveNode {\n        input\n            .sortedBy { it.split(\" \")[1] }\n            .forEach {\n                val id = it.split(\" \")[1]\n                val flowRate = it.split(\" \")[4].dropLast(1).split(\"=\")[1].toInt()\n                val neighbours =\n                    it.split(\" to \")[1].split(\" \").drop(1).map { it.replace(\",\", \"\") }\n                        .map { Pair(it, 1) }.toMutableSet()\n                val valveNode = ValveNode(id, flowRate, neighbours)\n                graph[id] = valveNode\n            }\n\n        val weights = mutableMapOf<Pair<String, String>, Int>()\n        graph.values.forEach { node ->\n            node.neighbours.forEach { neighbour ->\n                weights[Pair(node.id, neighbour.first)] = 1\n            }\n        }\n\n        val dijkstraGraph = Graph(\n            vertices = graph.values.map { it.id }.toMutableSet(),\n            edges = graph.values.map { it.id }\n                .associateWith { graph[it]!!.neighbours.map { it.first }.toSet() }.toMutableMap(),\n            weights = weights,\n        )\n\n        graph.keys.forEach { id ->\n            val currNode = graph[id]!!\n            val otherNodes = graph.values.toSet() - currNode.neighbours.map { graph[it.first]!! }\n                .toSet() - currNode\n            val shortestPathTree = dijkstra(dijkstraGraph, currNode.id)\n            otherNodes.forEach { other ->\n                currNode.neighbours.removeIf { it.first == other.id }\n                if (other.flowRate > 0) {\n                    val path = shortestPath(shortestPathTree, currNode.id, other.id)\n                    currNode.neighbours.add(Pair(other.id, path.size - 1))\n                }\n            }\n        }\n\n        return graph[\"AA\"]!!\n    }\n\n    var maxPressureReleased = 0\n\n    fun findMaxPath(\n        releasedPressure: Int,\n        position: ValveNode,\n        visited: Set<ValveNode>,\n        minute: Int,\n        elephant: Boolean\n    ) {\n        maxPressureReleased = maxOf(releasedPressure, maxPressureReleased)\n\n        position.neighbours.filter { graph[it.first]!!.flowRate > 0 }.forEach { (id, distance) ->\n            val newMinute = minute + distance + 1\n            val candidate = graph[id]!!\n            if (newMinute < availableMinutes && candidate !in visited) {\n                findMaxPath(\n                    releasedPressure = releasedPressure + (availableMinutes - newMinute) * candidate.flowRate,\n                    position = candidate,\n                    visited = visited + candidate,\n                    minute = newMinute,\n                    elephant = elephant,\n                )\n            }\n        }\n        if (elephant) {\n            findMaxPath(\n                releasedPressure = releasedPressure,\n                position = startValve,\n                visited = visited,\n                minute = 0,\n                elephant = false,\n            )\n        }\n    }\n\n    fun part1(input: List<String>): Int {\n        val root = createGraph(input)\n        maxPressureReleased = 0\n        availableMinutes = 30\n        findMaxPath(0, root, emptySet(), 0, false)\n        return maxPressureReleased\n    }\n\n    fun part2(input: List<String>): Int {\n        val root = createGraph(input)\n        maxPressureReleased = 0\n        availableMinutes = 26\n        findMaxPath(0, root, emptySet(), 0, true)\n        return maxPressureReleased\n    }\n\n    val input = readInput(\"day16\", \"Day16_input\")\n    println(part1(input))\n    println(part2(input))\n}\n\nprivate fun <T> dijkstra(graph: Graph<T>, start: T): Map<T, T?> {\n    val vertexSet: MutableSet<T> =\n        mutableSetOf() // a subset of vertices, for which we know the true distance\n\n    val delta = graph.vertices.associateWith { 100000 }.toMutableMap()\n    delta[start] = 0\n\n    val previous: MutableMap<T, T?> = graph.vertices.associateWith { null }.toMutableMap()\n\n    while (vertexSet != graph.vertices) {\n        val v: T = delta\n            .filter { !vertexSet.contains(it.key) }\n            .minBy { it.value }\n            .key\n\n        graph.edges.getValue(v).minus(vertexSet).forEach { neighbor ->\n            val newPath = delta.getValue(v) + graph.weights.getValue(Pair(v, neighbor))\n\n            if (newPath < delta.getValue(neighbor)) {\n                delta[neighbor] = newPath\n                previous[neighbor] = v\n            }\n        }\n\n        vertexSet.add(v)\n    }\n\n    return previous.toMap()\n}\n\nprivate fun <T> shortestPath(shortestPathTree: Map<T, T?>, start: T, end: T): List<T> {\n    fun pathTo(start: T, end: T): List<T> {\n        if (shortestPathTree[end] == null) return listOf(end)\n        return listOf(pathTo(start, shortestPathTree[end]!!), listOf(end)).flatten()\n    }\n\n    return pathTo(start, end)\n}\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "bcd7a08494e6db8140478b5f0a5f26ac1585ad76", "size": 5102, "name": "advent-of-code", "license": "Apache License 2.0"}
{"path": "src/day18/Day18.kt", "owner": "crmitchelmore", "repo_id": 576065911, "is_fork": false, "languages_distribution": "{\"Kotlin\": 115199}", "content": "package day18\n\nimport helpers.ReadFile\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\n\nclass Day18 {\n    val rlines = ReadFile.named(\"src/day18/input.txt\")\n    val tlines = listOf(\n        \"2,2,2\",\n        \"1,2,2\",\n        \"3,2,2\",\n        \"2,1,2\",\n        \"2,3,2\",\n        \"2,2,1\",//\n        \"2,2,3\",\n        \"2,2,4\",\n        \"2,2,6\",\n        \"1,2,5\",\n        \"3,2,5\",\n        \"2,1,5\",\n        \"2,3,5\",\n    )\n    val blines = listOf(\n        \"1,1,1\",\n        \"2,1,1\",\n    )\n    val lines = rlines.map {\n        val point = it.split(\",\").map { it.toInt() }\n        Triple(point[0], point[1], point[2])\n    }\n\n    var exposedFaces = mutableMapOf<Triple<Int,Int,Int>, MutableSet<String>>()\n    fun tr(t: Triple<Int,Int, Int>, direction: String, index: Int) : Int {\n        if (direction == \"z\") {\n            when (index) {\n                1 -> return t.first\n                2 -> return t.second\n                3 -> return t.third\n            }\n        } else if (direction == \"y\") {\n            when (index) {\n                1 -> return t.first\n                2 -> return t.third\n                3 -> return t.second\n            }\n        } else {\n            when (index) {\n                1 -> return t.third\n                2 -> return t.second\n                3 -> return t.first\n            }\n        }\n        throw Exception(\"Bad\")\n    }\n    fun sweep(direction: String) : Int {\n        var mappedLines = mutableMapOf<Int, List<Triple<Int,Int, Int>>>()\n        lines.forEach { mappedLines[tr(it, direction, 3)] = mappedLines.getOrDefault(tr(it, direction, 3), listOf()) + it }\n        var numPairedFaces = 0\n        val keys = mappedLines.keys.sorted()\n        for (i in 1 until keys.size) {\n            if (keys[i] - keys[i-1] == 1) {\n                for (cube1 in mappedLines[keys[i-1]]!!) {\n                    for (cube2 in mappedLines[keys[i]]!!) {\n                        if (tr(cube1, direction, 1) == tr(cube2, direction, 1) && tr(cube1, direction, 2) == tr(cube2, direction, 2)) {\n\n                            exposedFaces[cube1]!!.remove(if (direction == \"z\") \"Top\" else if (direction == \"y\") \"Back\" else \"Right\")\n                            exposedFaces[cube2]!!.remove(if (direction == \"z\") \"Bottom\" else if (direction == \"y\") \"Front\" else \"Left\")\n                            numPairedFaces++\n                        }\n                    }\n                }\n            }\n        }\n        return numPairedFaces\n    }\n    fun sharesEdge(cube1: Triple<Int,Int,Int>, cube2: Triple<Int,Int,Int>) : Boolean {\n        return (( abs(cube1.first - cube2.first) == 1 && cube1.second == cube2.second && cube1.third == cube2.third ) ||\n               ( cube1.first == cube2.first && abs(cube1.second - cube2.second) == 1 && cube1.third == cube2.third ) ||\n               ( cube1.first == cube2.first && cube1.second == cube2.second && abs(cube1.third - cube2.third) == 1 )) ||\n               (( abs(cube1.first - cube2.first) == 1 && abs(cube1.second - cube2.second) == 1  && cube1.third == cube2.third ) ||\n                ( cube1.first == cube2.first && abs(cube1.second - cube2.second) == 1 && abs(cube1.third - cube2.third) == 1 ) ||\n                ( abs(cube1.first - cube2.first) == 1  && cube1.second == cube2.second && abs(cube1.third - cube2.third) == 1 ) )\n\n    }\n    fun buildSurfaces(surfaceFaces: Set<Triple<Int, Int, Int>>) : Map<Int, List<Triple<Int,Int,Int>>> {\n        var surfaceIndex = 0\n        var cubeToSurfaceNum = mutableMapOf<Triple<Int,Int,Int>, Int>()\n        var surfaceNumToCubs = mutableMapOf<Int, List<Triple<Int,Int,Int>>>()\n        for (cube in surfaceFaces) {\n            var foundExistingSurface = false\n            // Check if this cube shares an edge with any existing surface\n            for (surface in surfaceNumToCubs.keys) {\n                for (surfaceCube in surfaceNumToCubs[surface]!!) {\n                    if (sharesEdge(cube, surfaceCube)) {\n                        cubeToSurfaceNum[cube] = surface\n                        surfaceNumToCubs[surface] = surfaceNumToCubs[surface]!! + cube\n                        foundExistingSurface = true\n                        break\n                    }\n                }\n                if (foundExistingSurface) {\n                    break\n                }\n            }\n            // If not, create a new surface\n            if (!foundExistingSurface) {\n                surfaceIndex++\n                cubeToSurfaceNum[cube] = surfaceIndex\n                surfaceNumToCubs[surfaceIndex] = listOf(cube)\n            }\n        }\n        // Merge surfaces\n        var merged = true\n        while (merged) {\n            merged = false\n\n            for (surface1 in surfaceNumToCubs.keys) {\n                for (surface2 in surfaceNumToCubs.keys) {\n                    if (surface1 != surface2) {\n                        for (cube1 in surfaceNumToCubs[surface1]!!) {\n                            for (cube2 in surfaceNumToCubs[surface2]!!) {\n                                if (sharesEdge(cube1, cube2)) {\n                                    // Merge surface2 into surface1\n                                    for (cube in surfaceNumToCubs[surface2]!!) {\n                                        cubeToSurfaceNum[cube] = surface1\n                                    }\n                                    surfaceNumToCubs[surface1] = surfaceNumToCubs[surface1]!! + surfaceNumToCubs[surface2]!!\n                                    surfaceNumToCubs.remove(surface2)\n                                    merged = true\n                                    break\n                                }\n                            }\n                            if (merged) {\n                                break\n                            }\n                        }\n                        if (merged) {\n                            break\n                        }\n                    }\n                }\n                if (merged) {\n                    break\n                }\n            }\n        }\n        // Now merge in to true surfaces\n\n        return surfaceNumToCubs\n    }\n\n    fun fill(lavas: Set<Triple<Int, Int, Int>>, x: Pair<Int, Int>, y: Pair<Int, Int>, z: Pair<Int, Int>) : Set<Triple<Int, Int, Int>> {\n        var waters = mutableSetOf(Triple(x.first - 1, y.first - 1, z.first - 1))\n\n        for (i in 1..4) {\n            for (i in x.first - 1..x.second + 1) {\n                for (j in y.first - 1..y.second + 1) {\n                    for (k in z.first - 1..z.second + 1) {\n                        if (lavas.contains(Triple(i, j, k))) {\n                            continue\n                        }\n                        val neigh = listOf(\n                            Triple(i + 1, j, k),\n                            Triple(i - 1, j, k),\n                            Triple(i, j + 1, k),\n                            Triple(i, j - 1, k),\n                            Triple(i, j, k + 1),\n                            Triple(i, j, k - 1)\n                        )\n                        if (neigh.any { waters.contains(it) }) {\n                            waters.add(Triple(i, j, k))\n                        } else {\n                            println(\"cave\")\n                        }\n                    }\n                }\n            }\n        }\n        return waters\n }\n    var numlavas = 0\n    fun fild(lavas: Set<Triple<Int, Int, Int>>, x: Pair<Int, Int>, y: Pair<Int, Int>, z: Pair<Int, Int>) : Set<Triple<Int, Int, Int>> {\n        var waters = mutableSetOf(Triple(x.first - 1, y.first - 1, z.first - 1))\n        var items = mutableListOf(waters.first())\n\n        while (items.size > 0) {\n            val item = items.removeAt(0)\n\n            val neigh = listOf(\n                Triple(item.first + 1, item.second, item.third),\n                Triple(item.first - 1, item.second, item.third),\n                Triple(item.first, item.second + 1, item.third),\n                Triple(item.first, item.second - 1, item.third),\n                Triple(item.first, item.second, item.third + 1),\n                Triple(item.first, item.second, item.third - 1)\n            )\n            for (n in neigh) {\n                if (lavas.contains(n) ) {\n                    numlavas += 1\n                } else {\n                    if (waters.contains(n) || n.first < x.first - 1 || n.first > x.second + 1 || n.second < y.first - 1 || n.second > y.second + 1 || n.third < z.first - 1 || n.third > z.second + 1) {\n                        continue\n                    }\n                    items.add(n)\n                    waters.add(n)\n                }\n            }\n        }\n        return waters\n    }\n\n    fun flood(lava: List<Triple<Int, Int, Int>>) : Set<Triple<Int,Int,Int>> {\n        var minMaxX: Pair<Int, Int> = Pair(Int.MAX_VALUE, Int.MIN_VALUE)\n        var minMaxY: Pair<Int, Int> = Pair(Int.MAX_VALUE, Int.MIN_VALUE)\n        var minMaxZ: Pair<Int, Int> = Pair(Int.MAX_VALUE, Int.MIN_VALUE)\n        for (cube in lava) {\n            minMaxX = Pair(min(minMaxX.first, cube.first), max(minMaxX.second, cube.first))\n            minMaxY = Pair(min(minMaxY.first, cube.second), max(minMaxY.second, cube.second))\n            minMaxZ = Pair(min(minMaxZ.first, cube.third), max(minMaxZ.second, cube.third))\n        }\n        // Be cautious about edges\n        minMaxX = Pair(minMaxX.first, minMaxX.second)\n        minMaxY = Pair(minMaxY.first, minMaxY.second)\n        minMaxZ = Pair(minMaxZ.first, minMaxZ.second)\n        val a = fild(lava.toSet(), minMaxX, minMaxY, minMaxZ)\n        val b = fill(lava.toSet(), minMaxX, minMaxY, minMaxZ)\n        print(\"Lavas $numlavas\")\n        return a\n    }\n    fun invertSurface(surface: List<Triple<Int, Int, Int>>): Set<Triple<Int, Int, Int>> {\n\n        var minMaxX: Pair<Int, Int> = Pair(Int.MAX_VALUE, Int.MIN_VALUE)\n        var minMaxY: Pair<Int, Int> = Pair(Int.MAX_VALUE, Int.MIN_VALUE)\n        var minMaxZ: Pair<Int, Int> = Pair(Int.MAX_VALUE, Int.MIN_VALUE)\n        for (cube in surface) {\n            minMaxX = Pair(min(minMaxX.first, cube.first), max(minMaxX.second, cube.first))\n            minMaxY = Pair(min(minMaxY.first, cube.second), max(minMaxY.second, cube.second))\n            minMaxZ = Pair(min(minMaxZ.first, cube.third), max(minMaxZ.second, cube.third))\n        }\n        // Be cautious about edges\n        minMaxX = Pair(minMaxX.first, minMaxX.second)\n        minMaxY = Pair(minMaxY.first, minMaxY.second + 1)\n        minMaxZ = Pair(minMaxZ.first, minMaxZ.second + 1)\n        var allCubes = mutableSetOf<Triple<Int, Int, Int>>()\n        for (x in minMaxX.first until minMaxX.second) {\n            for (y in minMaxY.first until minMaxY.second) {\n                for (z in minMaxZ.first until minMaxZ.second) {\n                    allCubes.add(Triple(x, y, z))\n                }\n            }\n        }\n        allCubes.removeAll(surface.toSet())\n        return allCubes\n    }\n    fun result1() {\n        for (line in lines) {\n            exposedFaces[line] = mutableSetOf(\"Top\", \"Bottom\", \"Left\", \"Right\", \"Front\", \"Back\")\n        }\n\n        val joinedFaces = sweep(\"x\") + sweep(\"y\") + sweep(\"z\")\n        val surfaceArea = lines.size * 6 - joinedFaces * 2\n        println(\"Surface $surfaceArea\")\n\n        val water = flood(lines)\n        var touchingWater = 0\n        var tw = mutableListOf<Triple<Int, Int, Int>>()\n        for (cube in lines) {\n            val neigh = listOf(\n                Triple(cube.first + 1, cube.second, cube.third),\n                Triple(cube.first - 1, cube.second, cube.third),\n                Triple(cube.first, cube.second + 1, cube.third),\n                Triple(cube.first, cube.second - 1, cube.third),\n                Triple(cube.first, cube.second, cube.third + 1),\n                Triple(cube.first, cube.second, cube.third - 1),\n            )\n            val t = water.intersect(neigh)\n            tw.addAll(t)\n\n\n        }\n        println(\"tw: $tw\")\n        println(\"Touching water $touchingWater\")\n//        val surfaceFaces = exposedFaces.filter { it.value.size > 0 }.keys\n//        val allSurfaces = buildSurfaces(surfaceFaces)\n//        for (surfaceNum in allSurfaces.keys) {\n//            val surface = allSurfaces[surfaceNum]!!\n//            val bubbles = buildSurfaces(invertSurface(surface))\n//            if (bubbles.size > 1) {\n//                println(\"Bubble ${bubbles}\")\n//            }\n//        }\n//        print(buildSurfaces(surfaceFaces))\n    }\n}\n// 2181 low\n// 2512 low", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "fd644d442b5ff0d2f05fbf6317c61ee9ce7b4470", "size": 12410, "name": "adventofcode2022", "license": "MIT License"}
{"path": "src/main/java/dev/haenara/mailprogramming/solution/y2020/m02/d23/Solution200223.kt", "owner": "HaenaraShin", "repo_id": 226032186, "is_fork": false, "languages_distribution": null, "content": "package dev.haenara.mailprogramming.solution.y2020.m02.d23\n\nimport dev.haenara.mailprogramming.solution.Solution\n\n/**\n * 매일프로그래밍 2020. 02. 23\n *\n * M x N 크기의 양의 정수 매트릭스와 비용(cost)가 주어졌을 때,\n * 주어진 비용으로 매트릭스의 시작 위치 (0, 0)에서 마지막 위치 (M-1, N-1)까지 도달하는 경로의 수를 구하시오.\n * 매트릭스에서 이동한 경로의 비용은 거쳐간 셀 값의 합이다.\n * 매트릭스에서는 오직 오른쪽 한 칸 또는 아래쪽 한 칸으로만 이동할 수 있다.\n * 즉, 셀 (i, j)에서는 (i, j+1) 또는 (i+1, j)로 이동할 수 있다.\n *\n * Input\n * [[4, 7, 1, 6],\n *  [5, 7, 3, 9],\n *  [3, 2, 1, 2],\n *  [7, 1, 6, 3]]\n * cost = 25\n *\n * Output\n * 2 (두 가지 경로는 4-7-1-3-1-6-3, 4-5-7-3-1-2-3)\n *\n * 풀이\n *\n */\n\nclass Solution200223 : Solution<Solution200223.Input, Int>{\n    private var count = 0\n    private lateinit var map : Array<Array<Int>>\n    private var cost = 0\n\n    override fun solution(input : Input) : Int {\n        map = input.map\n        cost = input.cost\n        return goRightOrDown(0, 0)\n    }\n\n     private fun goRightOrDown(x : Int, y : Int, costSum : Int = 0) : Int {\n         val sum = costSum + map[y][x]\n         if (x == map[y].lastIndex && y == map.lastIndex) {\n             return if (sum == cost) {\n                 1\n             } else {\n                 0\n             }\n         } else if (x == map[y].lastIndex) {\n             // move down\n             return goRightOrDown(x, y + 1, sum)\n         } else if (y == map.lastIndex) {\n             // move right\n             return goRightOrDown(x + 1, y, sum)\n         } else {\n             // move right and down\n             return goRightOrDown(x + 1, y, sum) + goRightOrDown(x, y + 1, sum)\n         }\n     }\n\n    class Input(val map : Array<Array<Int>>, val cost : Int)\n}\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 7, "commit_sha": "b5e50907b8a7af5db2055a99461bff9cc0268293", "size": 1891, "name": "MailProgramming", "license": "MIT License"}
{"path": "src/main/kotlin/com/manalili/advent/Day05.kt", "owner": "maines-pet", "repo_id": 162116190, "is_fork": false, "languages_distribution": null, "content": "package com.manalili.advent\n\nclass Day05(val input: String) {\n    fun react(polymerInput: String = input): Int {\n        var polymer = polymerInput\n        var index = 0\n\n        while (true) {\n            if (index >= polymer.length - 1) break\n            if (polymer[index] same polymer[index + 1]) {\n                polymer = polymer.removeRange(index..index + 1)\n                if (index != 0) index--\n            } else {\n                index++\n            }\n        }\n\n        return polymer.length\n    }\n\n    fun fullyReact(): Int{\n        val units = input.toCharArray().distinctBy { it.toLowerCase() }\n\n        return units.map { testUnit ->  input.filterNot { testUnit.toLowerCase() == it || testUnit.toUpperCase() == it } }\n            .map { react(it) }\n            .min()!!\n    }\n\n\n    private infix fun Char.same(other: Char) : Boolean {\n        return when {\n            this.isLowerCase() -> this.toUpperCase() == other\n            this.isUpperCase() -> this.toLowerCase() == other\n            else -> false\n        }\n    }\n\n}\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "25a01e13b0e3374c4abb6d00cd9b8d7873ea6c25", "size": 1046, "name": "adventOfCode2018", "license": "MIT License"}
{"path": "src/Day06.kt", "owner": "kipwoker", "repo_id": 572884607, "is_fork": false, "languages_distribution": null, "content": "\nfun main() {\n    fun getDiffIndex(input: List<String>, diffCount: Int): Int {\n        val line = input[0].toCharArray()\n\n        for (i in 0..line.size - diffCount) {\n            if (line.slice(i until i + diffCount).toSet().size == diffCount) {\n                return i + diffCount\n            }\n        }\n\n        return -1\n    }\n\n    fun part1(input: List<String>): Int {\n        return getDiffIndex(input, 4)\n    }\n\n    fun part2(input: List<String>): Int {\n        return getDiffIndex(input, 14)\n    }\n\n    assert(part1(readInput(\"Day06_test_1\")), 7)\n    assert(part1(readInput(\"Day06_test_2\")), 5)\n    assert(part1(readInput(\"Day06_test_3\")), 11)\n\n    assert(part2(readInput(\"Day06_test_1\")), 19)\n    assert(part2(readInput(\"Day06_test_2\")), 23)\n    assert(part2(readInput(\"Day06_test_3\")), 26)\n\n    val input = readInput(\"Day06\")\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "d8aeea88d1ab3dc4a07b2ff5b071df0715202af2", "size": 892, "name": "aoc2022", "license": "Apache License 2.0"}
{"path": "src/Day05.kt", "owner": "ChenJiaJian96", "repo_id": 576533624, "is_fork": false, "languages_distribution": "{\"Kotlin\": 11529}", "content": "fun main() {\n\n    fun MutableList<MutableList<Char>>.addOriginChars(originData: String) {\n        originData.forEachIndexed { index, c ->\n            if (c == '[') {\n                this[index / 4].add(originData[index + 1])\n            }\n        }\n    }\n\n    fun MutableList<MutableList<Char>>.execAction(moveActions: MoveAction, needReverse: Boolean) {\n        val newList = this[moveActions.startIndex].subList(0, moveActions.quantity)\n        if (needReverse) {\n            newList.reverse()\n        }\n        this[moveActions.endIndex].addAll(0, newList)\n        IntRange(0, moveActions.quantity - 1).reversed().forEach {\n            this[moveActions.startIndex].removeAt(it)\n        }\n    }\n\n    fun extracMoveActions(\n        input: List<String>,\n        moveActionStartIndex: Int\n    ): List<MoveAction> {\n        val moveActions = input.subList(moveActionStartIndex, input.size).map {\n            it.split(\" \").run {\n                MoveAction(\n                    quantity = get(1).toInt(),\n                    startIndex = get(3).toInt() - 1, // change to index\n                    endIndex = get(5).toInt() - 1, // change to index\n                )\n            }\n        }\n        return moveActions\n    }\n\n    fun extractOriginalData(input: List<String>): MutableList<MutableList<Char>> {\n        val emptyLineIndex = input.indexOf(\"\")\n\n        val numLineIndex = emptyLineIndex - 1\n        val totalSize = input[numLineIndex].length / 4 + 1\n\n        val originalData: MutableList<MutableList<Char>> = MutableList(totalSize) { mutableListOf() }\n        input.subList(0, numLineIndex).forEach {\n            originalData.addOriginChars(it)\n        }\n        return originalData\n    }\n\n    fun part1(input: List<String>): String {\n        val emptyLineIndex = input.indexOf(\"\")\n        val originalData = extractOriginalData(input)\n        val moveActions = extracMoveActions(input, emptyLineIndex + 1)\n        moveActions.forEach {\n            originalData.execAction(it, true)\n        }\n\n        return originalData.map {\n            it.first()\n        }.joinToString(\"\") { it.toString() }\n    }\n\n    fun part2(input: List<String>): String {\n        val emptyLineIndex = input.indexOf(\"\")\n        val originalData = extractOriginalData(input)\n        val moveActions = extracMoveActions(input, emptyLineIndex + 1)\n        moveActions.forEach {\n            originalData.execAction(it, false)\n        }\n\n        return originalData.map {\n            it.first()\n        }.joinToString(\"\") { it.toString() }\n    }\n\n    val testInput = readInput(\"05\", true)\n    check(part1(testInput) == \"CMZ\")\n    check(part2(testInput) == \"MCD\")\n\n    val input = readInput(\"05\")\n    part1(input).println()\n    part2(input).println()\n}\n\ndata class MoveAction(\n    val quantity: Int,\n    val startIndex: Int, // start from 0\n    val endIndex: Int, // max is last_index\n)", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "b1a88f437aee756548ac5ba422e2adf2a43dce9f", "size": 2861, "name": "Advent-Code-2022", "license": "Apache License 2.0"}
{"path": "src/problems/1006-clumsy.kt", "owner": "w1374720640", "repo_id": 352006409, "is_fork": false, "languages_distribution": null, "content": "package problems\n\n\n/**\n * 1006.笨阶乘 https://leetcode-cn.com/problems/clumsy-factorial/\n *\n * 解：以N=10为例，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n *                            = (10 * 9 / 8) + (7) + (-6 * 5 / 4) + (3) + (-2 * 1)\n * 以每个括号内的值为单位，不停累加即可得出最终值\n */\nfun clumsy(N: Int): Int {\n    require(N >= 0)\n    var result = 0\n    var i = 0\n    while (i < N) {\n        val pair = getValue(N, i)\n        result += pair.first\n        // 需要在这里更新索引\n        i = pair.second\n    }\n    return result\n}\n\nprivate fun getValue(N: Int, i: Int): Pair<Int, Int> {\n    require(i >= 0)\n    var value = N - i\n    if (i % 4 == 3) return value to i + 1\n    check(i % 4 == 0)\n    if (i < N - 1) {\n        value *= N - i - 1\n        if (i < N - 2) {\n            value /= N - i - 2\n        }\n    }\n    return if (i == 0) {\n        // 只有i==0时返回正数，其他都返回负数\n        value to 3\n    } else {\n        value * -1 to i + 3\n    }\n}\n\nfun main() {\n    check(clumsy(0) == 0)\n    check(clumsy(1) == 1)\n    check(clumsy(2) == 2)\n    check(clumsy(3) == 6)\n    check(clumsy(4) == 7)\n    check(clumsy(10) == 12)\n    println(\"check succeed.\")\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "21c96a75d13030009943474e2495f1fc5a7716ad", "size": 1222, "name": "LeetCode", "license": "MIT License"}
{"path": "src/Day08.kt", "owner": "dmarmelo", "repo_id": 573485455, "is_fork": false, "languages_distribution": "{\"Kotlin\": 28178}", "content": "fun main() {\n    fun List<String>.parseInput() = map {\n        it.map { c -> c.digitToInt() }\n    }\n\n    fun <T> List<List<T>>.viewFrom(rowIndex: Int, columnIndex: Int): Sequence<List<T>> = sequence {\n        yield((rowIndex - 1 downTo 0).map { this@viewFrom[it][columnIndex] }) // Top\n        yield((columnIndex - 1 downTo 0).map { this@viewFrom[rowIndex][it] }) // Right\n        yield((rowIndex + 1 until this@viewFrom.size).map { this@viewFrom[it][columnIndex] }) // Bottom\n        yield((columnIndex + 1 until this@viewFrom[0].size).map { this@viewFrom[rowIndex][it] }) // Left\n    }\n\n    fun part1(input: List<List<Int>>): Int {\n        var visibleTreeCount = 0\n        visibleTreeCount += input.size * 2 + input[0].size * 2 - 4\n\n        for (rowIndex in 1 until input.lastIndex) {\n            val row = input[rowIndex]\n            for (columnIndex in 1 until row.lastIndex) {\n                val currentHeight = row[columnIndex]\n\n                val isVisible = input.viewFrom(rowIndex, columnIndex).any { direction ->\n                    direction.all { it < currentHeight }\n                }\n                if (isVisible) {\n                    visibleTreeCount++\n                }\n            }\n        }\n\n        return visibleTreeCount\n    }\n\n    fun <T> Iterable<T>.takeUntil(predicate: (T) -> Boolean): List<T> {\n        val list = ArrayList<T>()\n        for (item in this) {\n            list.add(item)\n            if (!predicate(item))\n                break\n        }\n        return list\n    }\n\n    fun part2(input: List<List<Int>>): Int {\n        var scenicScore = 0\n\n        for ((rowIndex, row) in input.withIndex()) {\n            for ((columnIndex, _) in row.withIndex()) {\n                val currentHeight = row[columnIndex]\n\n                val score = input.viewFrom(rowIndex, columnIndex).map { direction ->\n                    direction.takeUntil { it < currentHeight }.count()\n                }.product()\n                if (score > scenicScore) {\n                    scenicScore = score\n                }\n            }\n        }\n\n        return scenicScore\n    }\n\n    // test if implementation meets criteria from the description, like:\n    val testInput = readInput(\"Day08_test\").parseInput()\n    check(part1(testInput) == 21)\n    check(part2(testInput) == 8)\n\n    val input = readInput(\"Day08\").parseInput()\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "5d3cbd227f950693b813d2a5dc3220463ea9f0e4", "size": 2390, "name": "advent-of-code-2022", "license": "Apache License 2.0"}
{"path": "src/array/TwoSums.kt", "owner": "develNerd", "repo_id": 456702818, "is_fork": false, "languages_distribution": "{\"Kotlin\": 37635, \"Java\": 5892}", "content": "/*\n*\n*\n*\n*\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n\n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n\n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\nAccepted\n5,872,105\nSubmissions\n12,180,827\n*\n*\n*\n*\n*\n*\n*\n* */\n\n\n\n/**\n*\nSolution\n*\n Summary : Given the array and the target we find the complement of each integer in the\n array and add it to a key value pair data structure. We will be using a map in this tutorial.\n We store the complement as a key and it's index as the value. As we iterate through the loop\n we check through the list of keys to see if our current number exists. If it exits then we can return\n the required indexes.\n *\n *\n 1. Corner Case - if @param[nums] we return an integer array of 00\n 2. Create a key-value pair to hold the complement, and it's index\n 3. As we Iterate, we calculate the current complement\n 4. Check if the current value @param[nums[i]] exists in the complements(keys)\n 5. Return the value of the complement (index) and the current index if \"step 4\" is true\n 6. We then add if \"Step 4\" is false\n 7. Return an intArrayOf (0,0) if we did not find the target indexes.\n\n*\n* */\n\nfun main(){\n\n    println(twoSum(intArrayOf(2,7,11,15),9).asList())\n\n    \n}\n\nfun twoSum(nums: IntArray, target: Int): IntArray {\n\n\n\n    /**\n     * Corner Case\n     * if  @param[nums] we return intArrayOf(0,0)\n     * */\n    //1\n    if (nums.isEmpty()) return intArrayOf(0,0)\n\n    //2\n    val complements = mutableMapOf<Int,Int>()\n    for(i in nums.indices){\n        //3\n        var complement = target.minus(nums[i])\n\n        //4\n        if(nums[i] in complements.keys ){\n            //5\n            return intArrayOf(complements.get(nums[i])!!,i)\n        }\n\n        //6\n        complements.put(complement,i)\n\n    }\n    //7\n    return intArrayOf(0,0)\n\n}\n\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "4e6cc8b4bee83361057c8e1bbeb427a43622b511", "size": 2351, "name": "Blind75InKotlin", "license": "MIT License"}
{"path": "2016/main/day_01/Main.kt", "owner": "Bluesy1", "repo_id": 572214020, "is_fork": false, "languages_distribution": "{\"Rust\": 280861, \"Kotlin\": 94178, \"Shell\": 996}", "content": "package day_01_2016\n\nimport java.io.File\nimport kotlin.math.abs\n\nenum class Facing {\n    NORTH, EAST, SOUTH, WEST\n}\n\nfun part1(input: List<String>) {\n    var horizontalPos =0\n    var verticalPos = 0\n    var facing = Facing.NORTH\n    for ((direction, distance) in input.map { Pair(it[0], it.substring(1).toInt()) }) {\n        when (direction) {\n            'R' -> facing = when (facing) {\n                Facing.NORTH -> Facing.EAST\n                Facing.EAST -> Facing.SOUTH\n                Facing.SOUTH -> Facing.WEST\n                Facing.WEST -> Facing.NORTH\n            }\n            'L' -> facing = when (facing) {\n                Facing.NORTH -> Facing.WEST\n                Facing.WEST -> Facing.SOUTH\n                Facing.SOUTH -> Facing.EAST\n                Facing.EAST -> Facing.NORTH\n            }\n        }\n        when (facing) {\n            Facing.NORTH -> verticalPos += distance\n            Facing.SOUTH -> verticalPos -= distance\n            Facing.EAST -> horizontalPos += distance\n            Facing.WEST -> horizontalPos -= distance\n        }\n    }\n    print(\"Distance: ${Math.abs(horizontalPos) + Math.abs(verticalPos)}\")\n}\n\n\nfun part2(input: List<String>) {\n    var horizontalPos = 0\n    var verticalPos = 0\n    var facing = Facing.NORTH\n    val visited = mutableMapOf<Pair<Int,Int>, Byte>()\n    for ((direction, distance) in input.map { Pair(it[0], it.substring(1).toInt()) }) {\n        when (direction) {\n            'R' -> facing = when (facing) {\n                Facing.NORTH -> Facing.EAST\n                Facing.EAST -> Facing.SOUTH\n                Facing.SOUTH -> Facing.WEST\n                Facing.WEST -> Facing.NORTH\n            }\n            'L' -> facing = when (facing) {\n                Facing.NORTH -> Facing.WEST\n                Facing.WEST -> Facing.SOUTH\n                Facing.SOUTH -> Facing.EAST\n                Facing.EAST -> Facing.NORTH\n            }\n        }\n        when (facing) {\n            Facing.NORTH -> {\n                for (j in 1..distance) {\n                    verticalPos++\n                    if (visited.containsKey(Pair(horizontalPos, verticalPos))) {\n                        print(\"Distance: ${abs(horizontalPos) + abs(verticalPos)}\")\n                        return\n                    }\n                    visited[Pair(horizontalPos, verticalPos)] = 1\n                }\n            }\n            Facing.SOUTH -> {\n                for (j in 1..distance) {\n                    verticalPos--\n                    if (visited.containsKey(Pair(horizontalPos, verticalPos))) {\n                        print(\"Distance: ${abs(horizontalPos) + abs(verticalPos)}\")\n                        return\n                    }\n                    visited[Pair(horizontalPos, verticalPos)] = 1\n                }\n            }\n            Facing.EAST -> {\n                for (j in 1..distance) {\n                    horizontalPos++\n                    if (visited.containsKey(Pair(horizontalPos, verticalPos))) {\n                        print(\"Distance: ${abs(horizontalPos) + abs(verticalPos)}\")\n                        return\n                    }\n                    visited[Pair(horizontalPos, verticalPos)] = 1\n                }\n            }\n            Facing.WEST -> {\n                for (j in 1..distance) {\n                    horizontalPos--\n                    if (visited.containsKey(Pair(horizontalPos, verticalPos))) {\n                        print(\"Distance: ${abs(horizontalPos) + abs(verticalPos)}\")\n                        return\n                    }\n                    visited[Pair(horizontalPos, verticalPos)] = 1\n                }\n            }\n        }\n    }\n}\n\nfun main(){\n    val inputFile = File(\"2016/inputs/Day_01.txt\")\n    print(\"\\n----- Part 1 -----\\n\")\n    part1(inputFile.readLines()[0].split(\", \"))\n    print(\"\\n----- Part 2 -----\\n\")\n    part2(inputFile.readLines()[0].split(\", \"))\n}", "issues": 0.0, "main_language": "Rust", "forks": 0, "stars": 0, "commit_sha": "537497bdb2fc0c75f7281186abe52985b600cbfb", "size": 3871, "name": "AdventofCode", "license": "MIT License"}
{"path": "src/main/kotlin/se/saidaspen/aoc/aoc2016/Day11.kt", "owner": "saidaspen", "repo_id": 354930478, "is_fork": false, "languages_distribution": "{\"Kotlin\": 301372, \"CSS\": 530}", "content": "package se.saidaspen.aoc.aoc2016\n\nimport se.saidaspen.aoc.util.Day\nimport se.saidaspen.aoc.util.bfs\nimport se.saidaspen.aoc.util.pairWise\n\nfun main() = Day11.run()\n\nobject Day11 : Day(2016, 11) {\n\n    private val itemsLocs = input.lines().map {\n        it.substring(it.indexOf(\"contains\") + 8)\n            .split(\",|and\".toRegex())\n            .map { e -> e.replace(\" a \", \"\").replace(\" and\", \"\").replace(\".\", \"\").trim() }\n            .filter { e -> e != \"nothing relevant\" }\n            .filter { e -> e.isNotEmpty() }\n            .map { e -> e.split(\" \")[0][0].uppercase() + e.split(\" \")[0][1] + e.split(\" \")[1][0].uppercase() }\n            .toSet()\n    }.toList()\n\n    private val next: (State) -> Iterable<State> = { (floor, items) ->\n        val nextStates = mutableListOf<Triple<Boolean, MutableList<String>, State>>()\n        val pairWiseItems = items[floor].pairWise().map { mutableListOf(it.first, it.second) }\n        val singleItems = items[floor].map { mutableListOf(it) }\n        val possibleMoves = pairWiseItems.union(singleItems)\n        val possibleFloors = mutableListOf(floor - 1, floor + 1).filter { it in 0..3 }\n        for (move in possibleMoves) {\n            for (nextFloor in possibleFloors) {\n                val nextItems = mutableListOf(\n                    items[0].toMutableSet(),\n                    items[1].toMutableSet(),\n                    items[2].toMutableSet(),\n                    items[3].toMutableSet()\n                )\n                nextItems[floor].removeAll(move.toSet())\n                nextItems[nextFloor].addAll(move)\n                val nextState = State(nextFloor, nextItems)\n\n                if (nextState.isValid()) {\n                    nextStates.add(Triple(nextFloor > floor, move, nextState))\n                }\n            }\n        }\n        val hasMoveTwoUp = (nextStates.any { it.first && it.second.size == 2 })\n        val hasMoveOneDown = (nextStates.any { !it.first && it.second.size == 1 })\n        nextStates\n            .filter { it.third.emptyFloorOptimization(items) } // If floors below are empty, don't move stuff back down to them\n            .filter { !hasMoveTwoUp || (!it.first || it.second.size == 2) } // If can move 2 up, then don't bother moving one up\n            .filter { !hasMoveOneDown || (it.first || it.second.size == 1) } // If can move 1 down, then don't bother moving two down\n            .map { it.third }\n    }\n\n    data class State(val floor: Int, val items: List<Set<String>>) {\n        fun isValid(): Boolean {\n            for (its in items) {\n                val chips = its.filter { it.endsWith(\"M\") }\n                if (chips.isNotEmpty() && its.any { it.endsWith(\"G\") })\n                    if (!chips.all { its.contains(it.substring(0, 2) + \"G\") }) {\n                        return false\n                    }\n            }\n            return true\n        }\n\n        fun emptyFloorOptimization(itemsPrev : List<Set<String>>): Boolean {\n            val firstNonEmptyFloorPrev = itemsPrev.withIndex().first { it.value.isNotEmpty() }.index\n            val firstNonEmptyFloorNext = items.withIndex().first { it.value.isNotEmpty() }.index\n            if (firstNonEmptyFloorNext < firstNonEmptyFloorPrev) {\n                return false\n            }\n            return true\n        }\n    }\n\n    override fun part1(): Any {\n        val isEnd: (State) -> Boolean = { it.items[3].size == itemsLocs.flatten().size } // End state is that all items are at level 3\n        val bfs = bfs(State(0, itemsLocs), isEnd, next)\n        return if (bfs.first != null) bfs.second else \"N/A\"\n    }\n\n    override fun part2(): Any {\n        val extendedItems = itemsLocs.toMutableList()\n        val itemsF1 = extendedItems[0].toMutableSet()\n        itemsF1.addAll(setOf(\"ElG\", \"ElM\", \"DiG\", \"DiM\"))\n        extendedItems[0] = itemsF1\n        val isEnd: (State) -> Boolean = { it.items[3].size == extendedItems.flatten().size } // End state is that all items are at level 3\n        val bfs = bfs(State(0, extendedItems), isEnd, next)\n        return if (bfs.first != null) bfs.second else \"N/A\"\n    }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "be120257fbce5eda9b51d3d7b63b121824c6e877", "size": 4077, "name": "adventofkotlin", "license": "MIT License"}
{"path": "src/main/kotlin/g2501_2600/s2561_rearranging_fruits/Solution.kt", "owner": "javadev", "repo_id": 190711550, "is_fork": false, "languages_distribution": "{\"Kotlin\": 4420233, \"TypeScript\": 50437, \"Python\": 3646, \"Shell\": 994}", "content": "package g2501_2600.s2561_rearranging_fruits\n\n// #Hard #Array #Hash_Table #Greedy #2023_07_07_Time_746_ms_(100.00%)_Space_60.5_MB_(100.00%)\n\nclass Solution {\n    fun minCost(basket1: IntArray, basket2: IntArray): Long {\n        val n = basket1.size\n        val map1: MutableMap<Int, Int> = HashMap()\n        val map2: MutableMap<Int, Int> = HashMap()\n        var minVal = Int.MAX_VALUE // Use on indirect swap\n\n        // Counting the basket's number to each HashMap\n        for (i in 0 until n) {\n            map1[basket1[i]] = map1.getOrDefault(basket1[i], 0) + 1\n            map2[basket2[i]] = map2.getOrDefault(basket2[i], 0) + 1\n            minVal = minVal.coerceAtMost(basket1[i])\n            minVal = minVal.coerceAtMost(basket2[i])\n        }\n\n        // build swap list, if any number is too more, add numbers to prepare swap list\n        val swapList1: MutableList<Int> = ArrayList()\n        for (key in map1.keys) {\n            val c1 = map1[key]!!\n            val c2 = map2.getOrDefault(key, 0)\n            if ((c1 + c2) % 2 == 1) return -1\n            if (c1 > c2) {\n                var addCnt = (c1 - c2) / 2\n                while (addCnt-- > 0) {\n                    swapList1.add(key)\n                }\n            }\n        }\n        val swapList2: MutableList<Int> = ArrayList()\n        for (key in map2.keys) {\n            val c1 = map1.getOrDefault(key, 0)\n            val c2 = map2[key]!!\n            if ((c1 + c2) % 2 == 1) return -1\n            if (c2 > c1) {\n                var addCnt = (c2 - c1) / 2\n                while (addCnt-- > 0) {\n                    swapList2.add(key)\n                }\n            }\n        }\n\n        // Sorting\n        swapList1.sort()\n        swapList2.sortWith { a: Int, b: Int -> b - a }\n\n        // visite swap list\n        var res: Long = 0\n        for (i in swapList1.indices) {\n            // Two choices to swap, direct swap or indirect swap\n            res += (2 * minVal).coerceAtMost(swapList1[i].coerceAtMost(swapList2[i])).toLong()\n        }\n        return res\n    }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 14, "stars": 24, "commit_sha": "fc95a0f4e1d629b71574909754ca216e7e1110d2", "size": 2035, "name": "LeetCode-in-Kotlin", "license": "MIT License"}
{"path": "src/main/kotlin/se/saidaspen/aoc/aoc2021/Day10.kt", "owner": "saidaspen", "repo_id": 354930478, "is_fork": false, "languages_distribution": "{\"Kotlin\": 301372, \"CSS\": 530}", "content": "package se.saidaspen.aoc.aoc2021\n\nimport se.saidaspen.aoc.util.*\n\nfun main() = Day10.run()\n\nobject Day10 : Day(2021, 10) {\n\n    private var chunkDelims = mapOf('(' to ')', '{' to '}', '[' to ']', '<' to '>')\n    private var scoreErrorChar = mapOf(')' to 3, '}' to 1197, ']' to 57, '>' to 25137)\n    private var scoreClosings = mapOf(')' to 1, '}' to 3, ']' to 2, '>' to 4)\n\n    override fun part1() =  input.lines().map { check(it) }.sumOf { scoreErrorChar.getOrDefault(it.first, 0) }\n    override fun part2(): Any {\n        val sortedScores = input.lines()\n            .map { check(it) }\n            .filter { it.first == null }\n            .map { scoreOfEnding(it.second) }\n            .sortedDescending()\n        return sortedScores[sortedScores.size/2]\n    }\n\n    private fun check(s: String): P<Char?, List<Char>> {\n        val chunkOrder = mutableListOf<Char>()\n        for (c in s.toCharArray().toList()) {\n            if (chunkDelims.keys.contains(c)) {\n                chunkOrder.add(c)\n            } else {\n                val lastChunkOpen = chunkOrder.removeLast()\n                if (c != chunkDelims[lastChunkOpen]) {\n                    return P(c, chunkOrder.map { chunkDelims[it]!! }.reversed())\n                }\n            }\n        }\n        return P(null, chunkOrder.map { chunkDelims[it]!! }.reversed())\n    }\n\n    private fun scoreOfEnding(delims: List<Char>) =  delims.fold(0L) { acc, e -> acc * 5 + scoreClosings.getOrDefault(e, 0) }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 1, "commit_sha": "be120257fbce5eda9b51d3d7b63b121824c6e877", "size": 1474, "name": "adventofkotlin", "license": "MIT License"}
{"path": "Hyperskill/Numeric-Matrix-Processor/Main.kt", "owner": "Alphabeater", "repo_id": 435048407, "is_fork": false, "languages_distribution": "{\"Kotlin\": 69566, \"Python\": 5974}", "content": "package processor\n\nimport java.util.*\n\nval s = Scanner(System.`in`)\n\nfun main() {\n    loop@ do {\n        print(\"\"\"\n            1. Add matrices\n            2. Multiply matrix by a constant\n            3. Multiply matrices\n            4. Transpose matrix\n            5. Calculate a determinant\n            6. Inverse matrix\n            0. Exit\n            Your choice: \n        \"\"\".trimIndent())\n        val option = s.nextInt()\n        try {\n            when (option) {\n                0 -> break@loop\n                1 -> printMatrix(sumMatrix(\n                    readMatrix(\"first \"), readMatrix(\"second \")))\n                2 -> printMatrix(multiplyMatrixConst(\n                    readMatrix(\"\"), readConst()))\n                3 -> printMatrix(multiplyMatrix(\n                    readMatrix(\"first \"), readMatrix(\"second \")\n                ))\n                4 -> printMatrix(transposeMatrix())\n                5 -> println(calculateDeterminant(readMatrix(\"\")))\n                6 -> readMatrix(\"\").let { printMatrix(inverseMatrix(\n                    it, recursiveDeterminant(it))) }\n                else -> throw Exception(\"Invalid option.\")\n            }\n        } catch (e: Exception) {\n            println(e.message)\n            continue@loop\n        }\n    } while (true)\n}\n\nfun sumMatrix(a: Array<Array<Double>>, b: Array<Array<Double>>):\n        Array<Array<Double>> {\n    if (a.size == b.size && a[0].size == b[0].size) {\n        val c = Array(a.size) { Array(a[0].size) { 0.0 } }\n        for (i in a.indices) {\n            for (j in a[0].indices) {\n                c[i][j] = a[i][j] + b[i][j]\n            }\n        }\n        return c\n    } else throw Exception(\"The operation cannot be performed.\")\n}\n\nfun multiplyMatrixConst(m: Array<Array<Double>>, const: Double):\n        Array<Array<Double>> {\n    val c = Array(m.size) { Array(m[0].size) { 0.0 } }\n    for (i in m.indices) {\n        for (j in m[0].indices) {\n            c[i][j] = m[i][j] * const\n        }\n    }\n    return c\n}\n\nfun multiplyMatrix(a: Array<Array<Double>>, b: Array<Array<Double>>):\n        Array<Array<Double>> {\n    if (a[0].size == b.size) {\n        val c = Array(a.size) { Array(b[0].size) { 0.0 } }\n        for (i in c.indices) {\n            for (j in c[0].indices) {\n                var r = 0.0\n                for (k in a[0].indices){\n                    r += a[i][k] * b[k][j]\n                }\n                c[i][j] = r\n            }\n        }\n        return c\n    } else throw Exception(\"The operation cannot be performed.\")\n}\n\nfun transposeMatrix(): Array<Array<Double>> {\n    print(\"\"\"\n        1. Main diagonal\n        2. Side diagonal\n        3. Vertical line\n        4. Horizontal line\n        Your choice: \n    \"\"\".trimIndent())\n    val option = s.nextInt()\n    val m = readMatrix(\"\")\n    return when (option) {\n        1 -> tMainDiagonal(m)\n        2 -> tSideDiagonal(m)\n        3 -> tVerticalLine(m)\n        4 -> tHorizontalLine(m)\n        else -> throw Exception(\"Invalid option.\")\n    }\n}\n\nfun tMainDiagonal(m: Array<Array<Double>>): Array<Array<Double>> {\n    val r = Array(m[0].size) { Array(m.size) { 0.0 } }\n    for (i in m.indices) {\n        for (j in m[0].indices) {\n            r[j][i] = m[i][j]\n        }\n    }\n    return r\n}\n\nfun tSideDiagonal(m: Array<Array<Double>>): Array<Array<Double>> {\n    val r = Array(m[0].size) { Array(m.size) { 0.0 } }\n    for (i in m.size - 1 downTo 0) {\n        for (j in m[0].size - 1 downTo 0) {\n            r[i][j] = m[m[0].size - 1 - j][m.size - 1 - i]\n        }\n    }\n    return r\n}\n\nfun tVerticalLine(m: Array<Array<Double>>): Array<Array<Double>> {\n    val r = Array(m[0].size) { Array(m.size) { 0.0 } }\n    for (i in m.indices) {\n        for (j in m[0].indices) {\n            r[i][j] = m[i][m[0].size - 1 - j]\n        }\n    }\n    return r\n}\n\nfun tHorizontalLine(m: Array<Array<Double>>): Array<Array<Double>> {\n    val r = Array(m[0].size) { Array(m.size) { 0.0 } }\n    for (i in m.indices) {\n        for (j in m[0].indices) {\n            r[i][j] = m[m.size - 1 - i][j]\n        }\n    }\n    return r\n}\n\nfun calculateDeterminant(m: Array<Array<Double>>): Double {\n    if (m.size == m[0].size) {\n        return recursiveDeterminant(m)\n    } else throw Exception(\"The operation cannot be performed.\")\n}\n\nfun recursiveDeterminant(m: Array<Array<Double>>): Double {\n    return if (m.size == 2) {\n        m[0][0] * m[1][1] - m[0][1] * m[1][0]\n    } else {\n        var res = 0.0\n        for (j in m[0].indices) {\n            val n = getMinor(m, j)\n            val sign = if ( j % 2 == 0) 1.0 else -1.0\n            res += sign * m[0][j] * recursiveDeterminant(n)\n        }\n        res\n    }\n}\n\nfun getMinor(m: Array<Array<Double>>, x: Int): Array<Array<Double>> {\n    val r = Array(m[0].size - 1) { Array(m.size - 1) { 0.0 } }\n    var k = 0\n    for (i in 1 until m.size) {\n        for (j in m[0].indices) {\n            if (x != j) {\n                r[i - 1][k++] = m[i][j]\n            }\n        }\n        k = 0\n    }\n    return r\n}\n\nfun getAdjointMatrix(m: Array<Array<Double>>): Array<Array<Double>> {\n    val r = Array(m[0].size) { Array(m.size) { 0.0 } }\n    for (i in m.indices) {\n        for (j in m[i].indices) {\n            var t =  Array(m[0].size) { Array(m[0].size) { 0.0 } }\n            for (k in m.indices) {\n                t[k] = m[k].filterIndexed { id, _ -> id != j }.toTypedArray()\n            }\n            t = t.filterIndexed { id, _ -> id != i }.toTypedArray()\n            val sign = if ( (i + j) % 2 == 0) 1.0 else -1.0\n            r[i][j] = sign * recursiveDeterminant(t)\n        }\n    }\n    return tMainDiagonal(r)\n}\n\nfun inverseMatrix(m: Array<Array<Double>>, det: Double): Array<Array<Double>> {\n    if (det != 0.0) {\n        return multiplyMatrixConst(getAdjointMatrix(m), 1.0 / det)\n    } else throw Exception(\"This matrix doesn't have an inverse.\")\n}\n\nfun readMatrix(str: String): Array<Array<Double>> {\n    print(\"Enter size of ${str}matrix: \")\n    val (row, col) = Array(2) { s.nextInt() }\n    print(\"Enter ${str}matrix:\\n\")\n    return Array(row) { Array(col) { s.nextDouble() } }\n}\n\nfun printMatrix(c: Array<Array<Double>>) {\n    println(\"The result is:\")\n    for (i in c.indices) {\n        for (j in c[0].indices) {\n            print(\"${c[i][j]} \")\n        }\n        println()\n    }\n}\n\nfun readConst(): Double{\n    print(\"Enter constant: \")\n    return s.nextDouble()\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "05c8d4614e025ed2f26fef2e5b1581630201adf0", "size": 6344, "name": "Archive", "license": "MIT License"}
{"path": "src/main/kotlin/day8.kt", "owner": "gautemo", "repo_id": 433582833, "is_fork": false, "languages_distribution": "{\"Kotlin\": 91784}", "content": "import shared.getLines\n\nfun findNumbers(input: List<String>): Int{\n    var one = 0\n    var four = 0\n    var seven = 0\n    var eight = 0\n    for(line in input){\n        val output = line.split(\"|\").last().trim().split(\" \")\n        one += output.count { it.length == 2 }\n        four += output.count { it.length == 4 }\n        seven += output.count { it.length == 3 }\n        eight += output.count { it.length == 7 }\n    }\n    return one + four + seven + eight\n}\n\nfun findOutputSum(input: List<String>): Int{\n    var sum = 0\n    for (line in input){\n        val (patterns, output) = line.split(\"|\").map { it.trim().split(\" \") }\n        sum += outputValue(patterns, output)\n    }\n    return sum\n}\n\nfun outputValue(patterns: List<String>, output: List<String>): Int{\n    val map = mutableMapOf(\n        Pair('a', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('b', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('c', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('d', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('e', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('f', mutableListOf('a','b','c','d','e','f','g')),\n        Pair('g', mutableListOf('a','b','c','d','e','f','g')),\n    )\n    while(!map.values.all { it.size == 1 }){\n        val foundOne = map['c']!!.size <= 2 && map['f']!!.size <= 2\n        for(pattern in patterns){\n            when{\n                pattern.length == 2 -> {\n                    map['c']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                    map['f']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                }\n                pattern.length == 3 && foundOne -> {\n                    val a = pattern.filterNot { map['c']!!.contains(it) || map['f']!!.contains(it) }\n                    map['a']!!.removeIf { !a.contains(it) }\n                }\n                pattern.length == 4 && map['d']!!.size == 1 && foundOne -> {\n                    val b = pattern.filterNot { map['d']!!.contains(it) || map['c']!!.contains(it) || map['f']!!.contains(it) }\n                    map['b']!!.removeIf { !b.contains(it) }\n                }\n                pattern.length == 4 -> {\n                    map['b']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                    map['c']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                    map['d']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                    map['f']!!.removeIf { possibility -> pattern.none { it == possibility } }\n                }\n                pattern.length == 5 && foundOne -> {\n                    if(map['a']!!.size == 1){\n                        val dg = pattern.filterNot { map['a']!!.contains(it) || map['c']!!.contains(it) || map['f']!!.contains(it) }\n                        map['d']!!.removeIf { !dg.contains(it) }\n                        map['g']!!.removeIf { !dg.contains(it) }\n                    }\n                    if(map['b']!!.size == 1 && pattern.contains(map['b']!!.first())){\n                        map['f']!!.removeIf { !pattern.contains(it) }\n                    }\n                }\n            }\n        }\n        for(option in map){\n            if(option.value.size == 1){\n                map.filter { it.key != option.key }.forEach { (_, value) -> value.removeIf { it == option.value.first() } }\n            }\n        }\n    }\n    return output.map {\n        val a = it.contains(map['a']!!.first())\n        val b = it.contains(map['b']!!.first())\n        val c = it.contains(map['c']!!.first())\n        val d = it.contains(map['d']!!.first())\n        val e = it.contains(map['e']!!.first())\n        val f = it.contains(map['f']!!.first())\n        val g = it.contains(map['g']!!.first())\n        if(a && b && c && !d && e && f && g) return@map '0'\n        if(!a && !b && c && !d && !e && f && !g) return@map '1'\n        if(a && !b && c && d && e && !f && g) return@map '2'\n        if(a && !b && c && d && !e && f && g) return@map '3'\n        if(!a && b && c && d && !e && f && !g) return@map '4'\n        if(a && b && !c && d && !e && f && g) return@map '5'\n        if(a && b && !c && d && e && f && g) return@map '6'\n        if(a && !b && c && !d && !e && f && !g) return@map '7'\n        if(a && b && c && d && e && f && g) return@map '8'\n        '9'\n    }.joinToString(\"\").toInt()\n}\n\nfun main(){\n    val input = getLines(\"day8.txt\")\n    val task1 = findNumbers(input)\n    println(task1)\n    val task2 = findOutputSum(input)\n    println(task2)\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "c50d872601ba52474fcf9451a78e3e1bcfa476f7", "size": 4543, "name": "AdventOfCode2021", "license": "MIT License"}
{"path": "src/main/kotlin/adventofcode2023/day17/day17.kt", "owner": "dzkoirn", "repo_id": 725682258, "is_fork": false, "languages_distribution": "{\"Kotlin\": 133478}", "content": "package adventofcode2023.day17\n\nimport adventofcode2023.Point\nimport adventofcode2023.pointsAround\n\nfun main() {\n    val input = listOf(\n        intArrayOf(1, 2, 3),\n        intArrayOf(4, 5, 6),\n        intArrayOf(7, 8, 9)\n    )\n\n    val minSumPath = findMinSumPath(input)\n}\n\nfun prepareInput(input: List<String>): List<IntArray> =\n    input.map { l -> l.map { c -> \"$c\".toInt() }.toIntArray() }\n\nfun sumPath(input: List<IntArray>, path: List<Point>): Int =\n    path.sumOf { (line, row) -> input[line][row] }\n\nfun visualize(input: List<IntArray>, path: List<Point>): String {\n    val a = input.map { arr -> arr.joinToString(\"\") { it.toString() }.toCharArray() }\n    path.forEach { (line, row) -> a[line][row] = '#' }\n    return a.map { it.joinToString(\"\") { \"$it\" } }.joinToString(\"\\n\") { it }\n}\n\nfun isValidMove(x: Int, y: Int, rows: Int, cols: Int): Boolean {\n    return x in 0 until rows && y in 0 until cols\n}\n\nfun findMinSumPath(input: List<IntArray>): List<Point> {\n    val rows = input.size\n    val cols = input[0].size\n    val directions = listOf(Point(0, 1), Point(1, 0), Point(0, -1), Point(-1, 0))\n\n    fun dfs(x: Int, y: Int, visited: Set<Point>, currentPath: List<Point>): List<Point> {\n        if (x == rows - 1 && y == cols - 1) {\n            return currentPath\n        }\n\n        var minPath: List<Point>? = null\n        for (dir in directions) {\n            val newX = x + dir.first\n            val newY = y + dir.second\n\n            if (isValidMove(newX, newY, rows, cols) && Point(newX, newY) !in visited) {\n                val newPath = currentPath + Point(newX, newY)\n                val newVisited = visited + Point(newX, newY)\n\n                val resultPath = dfs(newX, newY, newVisited, newPath)\n                println(resultPath)\n\n                if (minPath == null || getPathSum(input, resultPath) < getPathSum(input, minPath)) {\n                    minPath = resultPath\n                }\n            }\n        }\n\n        return minPath ?: emptyList()\n    }\n\n    return dfs(0, 0, setOf(Point(0, 0)), listOf(Point(0, 0)))\n}\n\nfun getPathSum(input: List<IntArray>, path: List<Point>): Int {\n    return path.sumBy { (x, y) -> input[x][y] }\n}\n\n\n\n//fun findMinSumPath(input: List<IntArray>): List<Point> {\n//    val rows = input.size\n//    val cols = input[0].size\n//\n//    // Initialize a 2D array to store the minimum sum values\n//    val minSum = Array(rows) { IntArray(cols) }\n//\n//    // Initialize the first cell with its own value\n//    minSum[0][0] = input[0][0]\n//\n//    // Initialize the first row and column\n//    for (i in 1 until rows) {\n//        minSum[i][0] = minSum[i - 1][0] + input[i][0]\n//    }\n//    for (j in 1 until cols) {\n//        minSum[0][j] = minSum[0][j - 1] + input[0][j]\n//    }\n//\n//    // Fill the rest of the minSum array\n//    for (i in 1 until rows) {\n//        for (j in 1 until cols) {\n//            minSum[i][j] = input[i][j] + minOf(minSum[i - 1][j], minSum[i][j - 1])\n//        }\n//    }\n//\n//    // Reconstruct the path\n//    val path = mutableListOf<Point>()\n//    var i = rows - 1\n//    var j = cols - 1\n//\n//    while (i > 0 || j > 0) {\n//        path.add(Point(i, j))\n//        if (i == 0) {\n//            j--\n//        } else if (j == 0) {\n//            i--\n//        } else {\n//            if (minSum[i - 1][j] < minSum[i][j - 1]) {\n//                i--\n//            } else {\n//                j--\n//            }\n//        }\n//    }\n//\n//    path.add(Point(0, 0))\n//    path.reverse()\n//\n//    return path\n//}\n\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "8f248fcdcd84176ab0875969822b3f2b02d8dea6", "size": 3486, "name": "adventofcode2023", "license": "MIT License"}
{"path": "src/main/kotlin/recursion/WordSearchII.kt", "owner": "e-freiman", "repo_id": 471473372, "is_fork": false, "languages_distribution": "{\"Kotlin\": 78010}", "content": "package recursion\n\nclass WordSearchII {\n    class TrieNode {\n        val children = HashMap<Char, TrieNode>()\n        var isLeaf = false\n    }\n\n    private val ret = mutableSetOf<String>()\n    private var board: Array<CharArray> = arrayOf<CharArray>()\n\n    private var m: Int = -1\n    private var n: Int = -1\n    private var visited: BooleanArray = booleanArrayOf()\n\n    private fun find(i: Int, j: Int, cur: TrieNode, sb: StringBuilder) {\n        if (board[i][j] in cur.children) {\n            visited[i * n + j] = true\n            sb.append(board[i][j])\n            val next = cur.children[board[i][j]]!!\n            if (next.isLeaf) {\n                ret.add(sb.toString())\n            }\n\n            if (i > 0 && !visited[(i - 1) * n + j]) find(i - 1, j, next, sb)\n            if (i < m - 1 && !visited[(i + 1) * n + j]) find(i + 1, j, next, sb)\n            if (j > 0 && !visited[i * n + j - 1]) find(i, j - 1, next, sb)\n            if (j < n - 1 && !visited[i * n + j + 1]) find(i, j + 1, next, sb)\n\n            sb.deleteCharAt(sb.lastIndex)\n            visited[i * n + j] = false\n        }\n    }\n\n    // O(m * n * max(word length))\n    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {\n\n        this.board = board\n\n        val trieRoot = TrieNode()\n\n        for (word in words) {\n            var cur = trieRoot\n            for (ch in word) {\n                if (ch !in cur.children) {\n                    cur.children[ch] = TrieNode()\n                }\n                cur = cur.children[ch]!!\n            }\n            cur.isLeaf = true\n        }\n\n        m = board.size\n        n = board[0].size\n\n        for (i in 0 until m) {\n            for (j in 0 until n) {\n                visited = BooleanArray(m * n) {false}\n                val sb = StringBuilder()\n                find(i, j, trieRoot, sb)\n            }\n        }\n\n        return ret.toList()\n    }\n\n}\n\nfun main() {\n    println(WordSearchII().findWords(arrayOf(\n        charArrayOf('a','b','c','e'),\n        charArrayOf('x','x','c','d'),\n        charArrayOf('x','x','b','a')),\n        arrayOf(\"abc\",\"abcd\")))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "fab7f275fbbafeeb79c520622995216f6c7d8642", "size": 2105, "name": "LeetcodeGoogleInterview", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/aoc2023/Day07.kt", "owner": "davidsheldon", "repo_id": 565946579, "is_fork": false, "languages_distribution": "{\"Kotlin\": 161960}", "content": "package aoc2023\n\nimport utils.InputUtils\n\nenum class HandTypes {\n    FIVE_KIND, FOUR_KIND, FULL_HOUSE, THREE_KIND, TWO_PAIR, ONE_PAIR, HIGH_CARD\n}\nval scores = \"23456789TJQKA\".mapIndexed { index, c -> c to index }.toMap()\nval jScore = scores['J']!!\nfun typeForHand(cards: String): HandTypes {\n    val counts = cards.groupingBy { it }.eachCount().values.sortedDescending()\n    if (counts[0] == 5) { return HandTypes.FIVE_KIND }\n    val (c1, c2) = counts\n    return if (c1 == 4) { HandTypes.FOUR_KIND }\n    else if (c1 == 3 && c2 == 2) { HandTypes.FULL_HOUSE }\n    else if (c1 == 3) { HandTypes.THREE_KIND }\n    else if (c1 == 2 && c2 == 2) { HandTypes.TWO_PAIR }\n    else if (c1 == 2) { HandTypes.ONE_PAIR }\n    else HandTypes.HIGH_CARD\n}\n\nfun wildTypeForHand(cards: String): HandTypes {\n    val counts = cards.groupingBy { it }.eachCount()\n    val jCount = counts['J'] ?: 0\n    return if (jCount in 1..4) {\n        val highest = (counts - 'J').entries.maxByOrNull { it.value }!!.key\n        typeForHand(cards.replace('J', highest))\n    } else {\n        typeForHand(cards)\n    }\n}\n\nfun String.asListOfScores() = map { scores[it]!! }\nfun sortHands(a: String, b: String) = a.asListOfScores().zip(b.asListOfScores()).map { compareValues(it.first, it.second) }.first { it != 0 }\n\n\nclass Hand(val cards: String, val bid: Long): Comparable<Hand> {\n    val type = typeForHand(cards)\n\n    val sortScore = cards.asListOfScores()\n        .fold(0) { acc, x -> (acc * 16) + x}\n\n\n\n    override fun compareTo(other: Hand): Int = (compareByDescending<Hand> { it.type }.thenBy { it.sortScore }).compare(this, other)\n    override fun toString(): String {\n        return \"Hand(cards='$cards', bid=$bid, type=$type)\"\n    }\n\n}\n\n\nclass Hand2(val cards: String, val bid: Long): Comparable<Hand2> {\n    val type = wildTypeForHand(cards)\n\n    val sortScore = cards.asListOfScores()\n        .map { if (it == jScore) { 0 } else { it + 1 } }\n        .fold(0) { acc, x -> (acc * 16) + x}\n\n\n\n    override fun compareTo(other: Hand2): Int = (compareByDescending<Hand2> { it.type }.thenBy { it.sortScore }).compare(this, other)\n    override fun toString(): String {\n        return \"Hand(cards='$cards', bid=$bid, type=$type)\"\n    }\n\n}\n\n\nfun main() {\n    val testInput = \"\"\"32T3K 765\nT55J5 684\nKK677 28\nKTJJT 220\nQQQJA 483\"\"\".trimIndent().split(\"\\n\")\n\n\n    fun part1(input: List<String>): Long {\n        val hands = input.map { Hand(it.substringBefore(' '), it.substringAfter(' ').toLong()) }\n        return hands\n            .sorted()\n            .mapIndexed { index, hand -> index + 1 to hand.bid }\n            .onEach { println(it) }\n            .sumOf { it.first * it.second }\n\n    }\n\n\n    fun part2(input: List<String>): Long {\n        val hands = input.map { Hand2(it.substringBefore(' '), it.substringAfter(' ').toLong()) }\n        return hands\n            .sorted()\n            .mapIndexed { index, hand -> index + 1 to hand.bid }\n            .onEach { println(it) }\n            .sumOf { it.first * it.second }\n\n    }\n\n    // test if implementation meets criteria from the description, like:\n    val testValue = part1(testInput)\n    println(testValue)\n    check(testValue == 6440L)\n\n    println(part2(testInput))\n\n    val puzzleInput = InputUtils.downloadAndGetLines(2023, 7)\n    val input = puzzleInput.toList()\n\n    println(part1(input))\n    println(part2(input))\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "5abc9e479bed21ae58c093c8efbe4d343eee7714", "size": 3343, "name": "aoc-2022-kotlin", "license": "Apache License 2.0"}
{"path": "src/main/kotlin/day02/RockPaperScissors.kt", "owner": "iamwent", "repo_id": 572947468, "is_fork": false, "languages_distribution": "{\"Kotlin\": 18217}", "content": "package day02\n\nimport readInput\n\nclass RockPaperScissors(\n    private val name: String\n) {\n    private fun readRockPaperScissors(): List<Pair<Char, Char>> {\n        return readInput(name).map { line ->\n            return@map (line.first()) to (line.last())\n        }\n    }\n\n    fun part1(): Int {\n        return readRockPaperScissors()\n            .map { round ->\n                (round.first - 'A' + 1) to (round.second - 'X' + 1)\n            }\n            .fold(0) { score, round ->\n                val outcome = when (round.second - round.first) {\n                    0 -> 3\n                    1 -> 6\n                    -2 -> 6\n                    else -> 0\n                }\n                val shape = round.second\n                return@fold score + shape + outcome\n            }\n    }\n\n    fun part2(): Int {\n        val strategy = listOf(3, 1, 2, 3, 1)\n        return readRockPaperScissors()\n            .map { round ->\n                val shape = round.first - 'A' + 1\n                return@map when (round.second) {\n                    'X' -> 0 + strategy[shape - 1]\n                    'Y' -> 3 + shape\n                    else -> 6 + strategy[shape + 1]\n                }\n            }\n            .sum()\n    }\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "77ce9ea5b227b29bc6424d9a3bc486d7e08f7f58", "size": 1228, "name": "advent-of-code-kotlin", "license": "Apache License 2.0"}
{"path": "app/src/test/java/com/terencepeh/leetcodepractice/RecursiveSum.kt", "owner": "tieren1", "repo_id": 560012707, "is_fork": false, "languages_distribution": "{\"Kotlin\": 26346}", "content": "package com.terencepeh.leetcodepractice\n\nfun sum(arr: IntArray): Int {\n    println(\"Size = ${arr.size}\")\n    return when {\n        arr.isEmpty() -> 0\n        else -> arr[0] + sum(arr.copyOfRange(1, arr.size))\n    }\n}\n\nfun count(list: List<Any>): Int {\n    return when {\n        list.isEmpty() -> 0\n        else -> 1 + count(list.subList(1, list.size))\n    }\n}\n\nprivate fun max(list: IntArray): Int = when {\n    list.size == 2 -> if (list[0] > list[1]) list[0] else list[1]\n    else -> {\n        val subMax = max(list.copyOfRange(1, list.size))\n        if (list[0] > subMax) list[0] else subMax\n    }\n}\n\nfun main() {\n    println(sum(intArrayOf(1, 2, 3, 4, 5)))\n    println(count(listOf(1, 2, 3, 4, 5)))\n    println(max(intArrayOf(1, 5, 10, 25, 16, 1))) // 25\n}\n", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "427fa2855c01fbc1e85a840d0be381cbb4eec858", "size": 760, "name": "LeetCodePractice", "license": "MIT License"}
{"path": "src/main/kotlin/days_2021/Day8.kt", "owner": "BasKiers", "repo_id": 434124805, "is_fork": false, "languages_distribution": "{\"Kotlin\": 40804}", "content": "package days_2021\n\nimport util.Day\nimport kotlin.math.pow\n\nclass Day8 : Day(8) {\n    val input = inputList.map { it.split(\" | \") }.map { (examples, answer) ->\n        examples.split(\" \").map(String::toCharArray).map(CharArray::toSet) to answer.split(\" \").map(String::toCharArray).map(CharArray::toSet)\n    }\n\n    class SevenSegmentDisplay(mapping: Map<Int, Set<Char>>, words: List<Set<Char>>) {\n        val values: List<Int>\n        val value: Int\n\n        init {\n            values = words.map { word -> mapping.toList().first { (_, charSet) -> charSet == word }.first }\n            value = values.reversed().reduceIndexed { index, acc, it -> acc + (it * (10F.pow(index))).toInt() }\n        }\n\n\n        companion object {\n            fun from(examples: List<Set<Char>>, words: List<Set<Char>>): SevenSegmentDisplay {\n                val numberToSegmentMapping: MutableMap<Int, Set<Char>> = mutableMapOf();\n                for (number in listOf(2, 3, 4, 7, 6, 5)) {\n                    for (example in examples.filter { it.size == number }) {\n                        when (example.size) {\n                            2 -> numberToSegmentMapping[1] = example\n                            3 -> numberToSegmentMapping[7] = example\n                            4 -> numberToSegmentMapping[4] = example\n                            7 -> numberToSegmentMapping[8] = example\n                            6 -> { // 6 9 0\n                                val overlaps7 = numberToSegmentMapping[7]!!.all { char -> example.contains(char) }\n                                val overlaps4 = numberToSegmentMapping[4]!!.all { char -> example.contains(char) }\n\n                                if (overlaps7 && overlaps4) {\n                                    numberToSegmentMapping[9] = example\n                                } else if (overlaps7) {\n                                    numberToSegmentMapping[0] = example\n                                } else {\n                                    numberToSegmentMapping[6] = example\n                                }\n                            }\n                            5 -> { // 2, 5, 3\n                                val overlaps7 = numberToSegmentMapping[7]!!.all { char -> example.contains(char) }\n                                val rightTop = numberToSegmentMapping[1]!!.filter { char ->\n                                    !numberToSegmentMapping[6]!!.contains(char)\n                                }\n                                val overlapsRightTop = rightTop.all { char -> example.contains(char) }\n\n                                if (overlaps7) {\n                                    numberToSegmentMapping[3] = example\n                                } else if (overlapsRightTop) {\n                                    numberToSegmentMapping[2] = example\n                                } else {\n                                    numberToSegmentMapping[5] = example\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return SevenSegmentDisplay(numberToSegmentMapping, words)\n            }\n        }\n    }\n\n    override fun partOne(): Any {\n        return input.sumOf { (examples, words) ->\n            SevenSegmentDisplay.from(examples, words).values.filter {\n                listOf(\n                    1,\n                    4,\n                    7,\n                    8\n                ).contains(it)\n            }.size\n        }\n    }\n\n    override fun partTwo(): Any {\n        return input.sumOf { (examples, words) -> SevenSegmentDisplay.from(examples, words).value }\n    }\n\n}", "issues": 0.0, "main_language": "Kotlin", "forks": 0, "stars": 0, "commit_sha": "870715c172f595b731ee6de275687c2d77caf2f3", "size": 3633, "name": "advent-of-code-2021", "license": "Creative Commons Zero v1.0 Universal"}
